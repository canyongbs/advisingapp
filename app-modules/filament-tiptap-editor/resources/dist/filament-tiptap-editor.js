var GN = Object.create;
var ay = Object.defineProperty;
var qN = Object.getOwnPropertyDescriptor;
var YN = Object.getOwnPropertyNames;
var JN = Object.getPrototypeOf,
    XN = Object.prototype.hasOwnProperty;
var Vd = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var ZN = (t, e, n, r) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
        for (let i of YN(e))
            !XN.call(t, i) && i !== n && ay(t, i, { get: () => e[i], enumerable: !(r = qN(e, i)) || r.enumerable });
    return t;
};
var Gd = (t, e, n) => (
    (n = t != null ? GN(JN(t)) : {}),
    ZN(e || !t || !t.__esModule ? ay(n, 'default', { value: t, enumerable: !0 }) : n, t)
);
var nS = Vd((nq, tS) => {
    function W_(t) {
        return (
            t instanceof Map
                ? (t.clear =
                      t.delete =
                      t.set =
                          function () {
                              throw new Error('map is read-only');
                          })
                : t instanceof Set &&
                  (t.add =
                      t.clear =
                      t.delete =
                          function () {
                              throw new Error('set is read-only');
                          }),
            Object.freeze(t),
            Object.getOwnPropertyNames(t).forEach((e) => {
                let n = t[e],
                    r = typeof n;
                (r === 'object' || r === 'function') && !Object.isFrozen(n) && W_(n);
            }),
            t
        );
    }
    var wu = class {
        constructor(e) {
            e.data === void 0 && (e.data = {}), (this.data = e.data), (this.isMatchIgnored = !1);
        }
        ignoreMatch() {
            this.isMatchIgnored = !0;
        }
    };
    function K_(t) {
        return t
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    function Si(t, ...e) {
        let n = Object.create(null);
        for (let r in t) n[r] = t[r];
        return (
            e.forEach(function (r) {
                for (let i in r) n[i] = r[i];
            }),
            n
        );
    }
    var BF = '</span>',
        B_ = (t) => !!t.scope,
        FF = (t, { prefix: e }) => {
            if (t.startsWith('language:')) return t.replace('language:', 'language-');
            if (t.includes('.')) {
                let n = t.split('.');
                return [`${e}${n.shift()}`, ...n.map((r, i) => `${r}${'_'.repeat(i + 1)}`)].join(' ');
            }
            return `${e}${t}`;
        },
        xm = class {
            constructor(e, n) {
                (this.buffer = ''), (this.classPrefix = n.classPrefix), e.walk(this);
            }
            addText(e) {
                this.buffer += K_(e);
            }
            openNode(e) {
                if (!B_(e)) return;
                let n = FF(e.scope, { prefix: this.classPrefix });
                this.span(n);
            }
            closeNode(e) {
                B_(e) && (this.buffer += BF);
            }
            value() {
                return this.buffer;
            }
            span(e) {
                this.buffer += `<span class="${e}">`;
            }
        },
        F_ = (t = {}) => {
            let e = { children: [] };
            return Object.assign(e, t), e;
        },
        _m = class t {
            constructor() {
                (this.rootNode = F_()), (this.stack = [this.rootNode]);
            }
            get top() {
                return this.stack[this.stack.length - 1];
            }
            get root() {
                return this.rootNode;
            }
            add(e) {
                this.top.children.push(e);
            }
            openNode(e) {
                let n = F_({ scope: e });
                this.add(n), this.stack.push(n);
            }
            closeNode() {
                if (this.stack.length > 1) return this.stack.pop();
            }
            closeAllNodes() {
                for (; this.closeNode(); );
            }
            toJSON() {
                return JSON.stringify(this.rootNode, null, 4);
            }
            walk(e) {
                return this.constructor._walk(e, this.rootNode);
            }
            static _walk(e, n) {
                return (
                    typeof n == 'string'
                        ? e.addText(n)
                        : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)),
                    e
                );
            }
            static _collapse(e) {
                typeof e != 'string' &&
                    e.children &&
                    (e.children.every((n) => typeof n == 'string')
                        ? (e.children = [e.children.join('')])
                        : e.children.forEach((n) => {
                              t._collapse(n);
                          }));
            }
        },
        Sm = class extends _m {
            constructor(e) {
                super(), (this.options = e);
            }
            addText(e) {
                e !== '' && this.add(e);
            }
            startScope(e) {
                this.openNode(e);
            }
            endScope() {
                this.closeNode();
            }
            __addSublanguage(e, n) {
                let r = e.root;
                n && (r.scope = `language:${n}`), this.add(r);
            }
            toHTML() {
                return new xm(this, this.options).value();
            }
            finalize() {
                return this.closeAllNodes(), !0;
            }
        };
    function Ea(t) {
        return t ? (typeof t == 'string' ? t : t.source) : null;
    }
    function V_(t) {
        return yo('(?=', t, ')');
    }
    function HF(t) {
        return yo('(?:', t, ')*');
    }
    function zF(t) {
        return yo('(?:', t, ')?');
    }
    function yo(...t) {
        return t.map((n) => Ea(n)).join('');
    }
    function $F(t) {
        let e = t[t.length - 1];
        return typeof e == 'object' && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
    }
    function Mm(...t) {
        return '(' + ($F(t).capture ? '' : '?:') + t.map((r) => Ea(r)).join('|') + ')';
    }
    function G_(t) {
        return new RegExp(t.toString() + '|').exec('').length - 1;
    }
    function UF(t, e) {
        let n = t && t.exec(e);
        return n && n.index === 0;
    }
    var WF = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function Am(t, { joinWith: e }) {
        let n = 0;
        return t
            .map((r) => {
                n += 1;
                let i = n,
                    o = Ea(r),
                    s = '';
                for (; o.length > 0; ) {
                    let l = WF.exec(o);
                    if (!l) {
                        s += o;
                        break;
                    }
                    (s += o.substring(0, l.index)),
                        (o = o.substring(l.index + l[0].length)),
                        l[0][0] === '\\' && l[1]
                            ? (s += '\\' + String(Number(l[1]) + i))
                            : ((s += l[0]), l[0] === '(' && n++);
                }
                return s;
            })
            .map((r) => `(${r})`)
            .join(e);
    }
    var KF = /\b\B/,
        q_ = '[a-zA-Z]\\w*',
        Cm = '[a-zA-Z_]\\w*',
        Y_ = '\\b\\d+(\\.\\d+)?',
        J_ = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
        X_ = '\\b(0b[01]+)',
        VF =
            '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~',
        GF = (t = {}) => {
            let e = /^#![ ]*\//;
            return (
                t.binary && (t.begin = yo(e, /.*\b/, t.binary, /\b.*/)),
                Si(
                    {
                        scope: 'meta',
                        begin: e,
                        end: /$/,
                        relevance: 0,
                        'on:begin': (n, r) => {
                            n.index !== 0 && r.ignoreMatch();
                        },
                    },
                    t,
                )
            );
        },
        va = { begin: '\\\\[\\s\\S]', relevance: 0 },
        qF = { scope: 'string', begin: "'", end: "'", illegal: '\\n', contains: [va] },
        YF = { scope: 'string', begin: '"', end: '"', illegal: '\\n', contains: [va] },
        JF = {
            begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
        },
        _u = function (t, e, n = {}) {
            let r = Si({ scope: 'comment', begin: t, end: e, contains: [] }, n);
            r.contains.push({
                scope: 'doctag',
                begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
                end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
                excludeBegin: !0,
                relevance: 0,
            });
            let i = Mm(
                'I',
                'a',
                'is',
                'so',
                'us',
                'to',
                'at',
                'if',
                'in',
                'it',
                'on',
                /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
                /[A-Za-z]+[-][a-z]+/,
                /[A-Za-z][a-z]{2,}/,
            );
            return r.contains.push({ begin: yo(/[ ]+/, '(', i, /[.]?[:]?([.][ ]|[ ])/, '){3}') }), r;
        },
        XF = _u('//', '$'),
        ZF = _u('/\\*', '\\*/'),
        jF = _u('#', '$'),
        QF = { scope: 'number', begin: Y_, relevance: 0 },
        eH = { scope: 'number', begin: J_, relevance: 0 },
        tH = { scope: 'number', begin: X_, relevance: 0 },
        nH = {
            begin: /(?=\/[^/\n]*\/)/,
            contains: [
                {
                    scope: 'regexp',
                    begin: /\//,
                    end: /\/[gimuy]*/,
                    illegal: /\n/,
                    contains: [va, { begin: /\[/, end: /\]/, relevance: 0, contains: [va] }],
                },
            ],
        },
        rH = { scope: 'title', begin: q_, relevance: 0 },
        iH = { scope: 'title', begin: Cm, relevance: 0 },
        oH = { begin: '\\.\\s*' + Cm, relevance: 0 },
        sH = function (t) {
            return Object.assign(t, {
                'on:begin': (e, n) => {
                    n.data._beginMatch = e[1];
                },
                'on:end': (e, n) => {
                    n.data._beginMatch !== e[1] && n.ignoreMatch();
                },
            });
        },
        vu = Object.freeze({
            __proto__: null,
            MATCH_NOTHING_RE: KF,
            IDENT_RE: q_,
            UNDERSCORE_IDENT_RE: Cm,
            NUMBER_RE: Y_,
            C_NUMBER_RE: J_,
            BINARY_NUMBER_RE: X_,
            RE_STARTERS_RE: VF,
            SHEBANG: GF,
            BACKSLASH_ESCAPE: va,
            APOS_STRING_MODE: qF,
            QUOTE_STRING_MODE: YF,
            PHRASAL_WORDS_MODE: JF,
            COMMENT: _u,
            C_LINE_COMMENT_MODE: XF,
            C_BLOCK_COMMENT_MODE: ZF,
            HASH_COMMENT_MODE: jF,
            NUMBER_MODE: QF,
            C_NUMBER_MODE: eH,
            BINARY_NUMBER_MODE: tH,
            REGEXP_MODE: nH,
            TITLE_MODE: rH,
            UNDERSCORE_TITLE_MODE: iH,
            METHOD_GUARD: oH,
            END_SAME_AS_BEGIN: sH,
        });
    function aH(t, e) {
        t.input[t.index - 1] === '.' && e.ignoreMatch();
    }
    function lH(t, e) {
        t.className !== void 0 && ((t.scope = t.className), delete t.className);
    }
    function cH(t, e) {
        e &&
            t.beginKeywords &&
            ((t.begin = '\\b(' + t.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)'),
            (t.__beforeBegin = aH),
            (t.keywords = t.keywords || t.beginKeywords),
            delete t.beginKeywords,
            t.relevance === void 0 && (t.relevance = 0));
    }
    function uH(t, e) {
        Array.isArray(t.illegal) && (t.illegal = Mm(...t.illegal));
    }
    function dH(t, e) {
        if (t.match) {
            if (t.begin || t.end) throw new Error('begin & end are not supported with match');
            (t.begin = t.match), delete t.match;
        }
    }
    function fH(t, e) {
        t.relevance === void 0 && (t.relevance = 1);
    }
    var pH = (t, e) => {
            if (!t.beforeMatch) return;
            if (t.starts) throw new Error('beforeMatch cannot be used with starts');
            let n = Object.assign({}, t);
            Object.keys(t).forEach((r) => {
                delete t[r];
            }),
                (t.keywords = n.keywords),
                (t.begin = yo(n.beforeMatch, V_(n.begin))),
                (t.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: !0 })] }),
                (t.relevance = 0),
                delete n.beforeMatch;
        },
        hH = ['of', 'and', 'for', 'in', 'not', 'or', 'if', 'then', 'parent', 'list', 'value'],
        mH = 'keyword';
    function Z_(t, e, n = mH) {
        let r = Object.create(null);
        return (
            typeof t == 'string'
                ? i(n, t.split(' '))
                : Array.isArray(t)
                  ? i(n, t)
                  : Object.keys(t).forEach(function (o) {
                        Object.assign(r, Z_(t[o], e, o));
                    }),
            r
        );
        function i(o, s) {
            e && (s = s.map((l) => l.toLowerCase())),
                s.forEach(function (l) {
                    let u = l.split('|');
                    r[u[0]] = [o, gH(u[0], u[1])];
                });
        }
    }
    function gH(t, e) {
        return e ? Number(e) : bH(t) ? 0 : 1;
    }
    function bH(t) {
        return hH.includes(t.toLowerCase());
    }
    var H_ = {},
        bo = (t) => {
            console.error(t);
        },
        z_ = (t, ...e) => {
            console.log(`WARN: ${t}`, ...e);
        },
        cs = (t, e) => {
            H_[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), (H_[`${t}/${e}`] = !0));
        },
        xu = new Error();
    function j_(t, e, { key: n }) {
        let r = 0,
            i = t[n],
            o = {},
            s = {};
        for (let l = 1; l <= e.length; l++) (s[l + r] = i[l]), (o[l + r] = !0), (r += G_(e[l - 1]));
        (t[n] = s), (t[n]._emit = o), (t[n]._multi = !0);
    }
    function yH(t) {
        if (Array.isArray(t.begin)) {
            if (t.skip || t.excludeBegin || t.returnBegin)
                throw (bo('skip, excludeBegin, returnBegin not compatible with beginScope: {}'), xu);
            if (typeof t.beginScope != 'object' || t.beginScope === null) throw (bo('beginScope must be object'), xu);
            j_(t, t.begin, { key: 'beginScope' }), (t.begin = Am(t.begin, { joinWith: '' }));
        }
    }
    function EH(t) {
        if (Array.isArray(t.end)) {
            if (t.skip || t.excludeEnd || t.returnEnd)
                throw (bo('skip, excludeEnd, returnEnd not compatible with endScope: {}'), xu);
            if (typeof t.endScope != 'object' || t.endScope === null) throw (bo('endScope must be object'), xu);
            j_(t, t.end, { key: 'endScope' }), (t.end = Am(t.end, { joinWith: '' }));
        }
    }
    function vH(t) {
        t.scope && typeof t.scope == 'object' && t.scope !== null && ((t.beginScope = t.scope), delete t.scope);
    }
    function wH(t) {
        vH(t),
            typeof t.beginScope == 'string' && (t.beginScope = { _wrap: t.beginScope }),
            typeof t.endScope == 'string' && (t.endScope = { _wrap: t.endScope }),
            yH(t),
            EH(t);
    }
    function xH(t) {
        function e(s, l) {
            return new RegExp(
                Ea(s),
                'm' + (t.case_insensitive ? 'i' : '') + (t.unicodeRegex ? 'u' : '') + (l ? 'g' : ''),
            );
        }
        class n {
            constructor() {
                (this.matchIndexes = {}), (this.regexes = []), (this.matchAt = 1), (this.position = 0);
            }
            addRule(l, u) {
                (u.position = this.position++),
                    (this.matchIndexes[this.matchAt] = u),
                    this.regexes.push([u, l]),
                    (this.matchAt += G_(l) + 1);
            }
            compile() {
                this.regexes.length === 0 && (this.exec = () => null);
                let l = this.regexes.map((u) => u[1]);
                (this.matcherRe = e(Am(l, { joinWith: '|' }), !0)), (this.lastIndex = 0);
            }
            exec(l) {
                this.matcherRe.lastIndex = this.lastIndex;
                let u = this.matcherRe.exec(l);
                if (!u) return null;
                let d = u.findIndex((h, m) => m > 0 && h !== void 0),
                    f = this.matchIndexes[d];
                return u.splice(0, d), Object.assign(u, f);
            }
        }
        class r {
            constructor() {
                (this.rules = []),
                    (this.multiRegexes = []),
                    (this.count = 0),
                    (this.lastIndex = 0),
                    (this.regexIndex = 0);
            }
            getMatcher(l) {
                if (this.multiRegexes[l]) return this.multiRegexes[l];
                let u = new n();
                return (
                    this.rules.slice(l).forEach(([d, f]) => u.addRule(d, f)), u.compile(), (this.multiRegexes[l] = u), u
                );
            }
            resumingScanAtSamePosition() {
                return this.regexIndex !== 0;
            }
            considerAll() {
                this.regexIndex = 0;
            }
            addRule(l, u) {
                this.rules.push([l, u]), u.type === 'begin' && this.count++;
            }
            exec(l) {
                let u = this.getMatcher(this.regexIndex);
                u.lastIndex = this.lastIndex;
                let d = u.exec(l);
                if (this.resumingScanAtSamePosition() && !(d && d.index === this.lastIndex)) {
                    let f = this.getMatcher(0);
                    (f.lastIndex = this.lastIndex + 1), (d = f.exec(l));
                }
                return (
                    d && ((this.regexIndex += d.position + 1), this.regexIndex === this.count && this.considerAll()), d
                );
            }
        }
        function i(s) {
            let l = new r();
            return (
                s.contains.forEach((u) => l.addRule(u.begin, { rule: u, type: 'begin' })),
                s.terminatorEnd && l.addRule(s.terminatorEnd, { type: 'end' }),
                s.illegal && l.addRule(s.illegal, { type: 'illegal' }),
                l
            );
        }
        function o(s, l) {
            let u = s;
            if (s.isCompiled) return u;
            [lH, dH, wH, pH].forEach((f) => f(s, l)),
                t.compilerExtensions.forEach((f) => f(s, l)),
                (s.__beforeBegin = null),
                [cH, uH, fH].forEach((f) => f(s, l)),
                (s.isCompiled = !0);
            let d = null;
            return (
                typeof s.keywords == 'object' &&
                    s.keywords.$pattern &&
                    ((s.keywords = Object.assign({}, s.keywords)),
                    (d = s.keywords.$pattern),
                    delete s.keywords.$pattern),
                (d = d || /\w+/),
                s.keywords && (s.keywords = Z_(s.keywords, t.case_insensitive)),
                (u.keywordPatternRe = e(d, !0)),
                l &&
                    (s.begin || (s.begin = /\B|\b/),
                    (u.beginRe = e(u.begin)),
                    !s.end && !s.endsWithParent && (s.end = /\B|\b/),
                    s.end && (u.endRe = e(u.end)),
                    (u.terminatorEnd = Ea(u.end) || ''),
                    s.endsWithParent && l.terminatorEnd && (u.terminatorEnd += (s.end ? '|' : '') + l.terminatorEnd)),
                s.illegal && (u.illegalRe = e(s.illegal)),
                s.contains || (s.contains = []),
                (s.contains = [].concat(
                    ...s.contains.map(function (f) {
                        return _H(f === 'self' ? s : f);
                    }),
                )),
                s.contains.forEach(function (f) {
                    o(f, u);
                }),
                s.starts && o(s.starts, l),
                (u.matcher = i(u)),
                u
            );
        }
        if ((t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes('self')))
            throw new Error(
                'ERR: contains `self` is not supported at the top-level of a language.  See documentation.',
            );
        return (t.classNameAliases = Si(t.classNameAliases || {})), o(t);
    }
    function Q_(t) {
        return t ? t.endsWithParent || Q_(t.starts) : !1;
    }
    function _H(t) {
        return (
            t.variants &&
                !t.cachedVariants &&
                (t.cachedVariants = t.variants.map(function (e) {
                    return Si(t, { variants: null }, e);
                })),
            t.cachedVariants
                ? t.cachedVariants
                : Q_(t)
                  ? Si(t, { starts: t.starts ? Si(t.starts) : null })
                  : Object.isFrozen(t)
                    ? Si(t)
                    : t
        );
    }
    var SH = '11.8.0',
        Tm = class extends Error {
            constructor(e, n) {
                super(e), (this.name = 'HTMLInjectionError'), (this.html = n);
            }
        },
        wm = K_,
        $_ = Si,
        U_ = Symbol('nomatch'),
        TH = 7,
        eS = function (t) {
            let e = Object.create(null),
                n = Object.create(null),
                r = [],
                i = !0,
                o = "Could not find the language '{}', did you forget to load/include a language module?",
                s = { disableAutodetect: !0, name: 'Plain text', contains: [] },
                l = {
                    ignoreUnescapedHTML: !1,
                    throwUnescapedHTML: !1,
                    noHighlightRe: /^(no-?highlight)$/i,
                    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
                    classPrefix: 'hljs-',
                    cssSelector: 'pre code',
                    languages: null,
                    __emitter: Sm,
                };
            function u(O) {
                return l.noHighlightRe.test(O);
            }
            function d(O) {
                let R = O.className + ' ';
                R += O.parentNode ? O.parentNode.className : '';
                let V = l.languageDetectRe.exec(R);
                if (V) {
                    let Q = $(V[1]);
                    return (
                        Q || (z_(o.replace('{}', V[1])), z_('Falling back to no-highlight mode for this block.', O)),
                        Q ? V[1] : 'no-highlight'
                    );
                }
                return R.split(/\s+/).find((Q) => u(Q) || $(Q));
            }
            function f(O, R, V) {
                let Q = '',
                    he = '';
                typeof R == 'object'
                    ? ((Q = O), (V = R.ignoreIllegals), (he = R.language))
                    : (cs('10.7.0', 'highlight(lang, code, ...args) has been deprecated.'),
                      cs(
                          '10.7.0',
                          `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`,
                      ),
                      (he = O),
                      (Q = R)),
                    V === void 0 && (V = !0);
                let xe = { code: Q, language: he };
                Ee('before:highlight', xe);
                let Ue = xe.result ? xe.result : h(xe.language, xe.code, V);
                return (Ue.code = xe.code), Ee('after:highlight', Ue), Ue;
            }
            function h(O, R, V, Q) {
                let he = Object.create(null);
                function xe(H, Y) {
                    return H.keywords[Y];
                }
                function Ue() {
                    if (!ee.keywords) {
                        Ke.addText(Re);
                        return;
                    }
                    let H = 0;
                    ee.keywordPatternRe.lastIndex = 0;
                    let Y = ee.keywordPatternRe.exec(Re),
                        ue = '';
                    for (; Y; ) {
                        ue += Re.substring(H, Y.index);
                        let Ae = ft.case_insensitive ? Y[0].toLowerCase() : Y[0],
                            ct = xe(ee, Ae);
                        if (ct) {
                            let [Vt, Mi] = ct;
                            if (
                                (Ke.addText(ue),
                                (ue = ''),
                                (he[Ae] = (he[Ae] || 0) + 1),
                                he[Ae] <= TH && (mt += Mi),
                                Vt.startsWith('_'))
                            )
                                ue += Y[0];
                            else {
                                let B = ft.classNameAliases[Vt] || Vt;
                                Xe(Y[0], B);
                            }
                        } else ue += Y[0];
                        (H = ee.keywordPatternRe.lastIndex), (Y = ee.keywordPatternRe.exec(Re));
                    }
                    (ue += Re.substring(H)), Ke.addText(ue);
                }
                function We() {
                    if (Re === '') return;
                    let H = null;
                    if (typeof ee.subLanguage == 'string') {
                        if (!e[ee.subLanguage]) {
                            Ke.addText(Re);
                            return;
                        }
                        (H = h(ee.subLanguage, Re, !0, Ce[ee.subLanguage])), (Ce[ee.subLanguage] = H._top);
                    } else H = b(Re, ee.subLanguage.length ? ee.subLanguage : null);
                    ee.relevance > 0 && (mt += H.relevance), Ke.__addSublanguage(H._emitter, H.language);
                }
                function He() {
                    ee.subLanguage != null ? We() : Ue(), (Re = '');
                }
                function Xe(H, Y) {
                    H !== '' && (Ke.startScope(Y), Ke.addText(H), Ke.endScope());
                }
                function xt(H, Y) {
                    let ue = 1,
                        Ae = Y.length - 1;
                    for (; ue <= Ae; ) {
                        if (!H._emit[ue]) {
                            ue++;
                            continue;
                        }
                        let ct = ft.classNameAliases[H[ue]] || H[ue],
                            Vt = Y[ue];
                        ct ? Xe(Vt, ct) : ((Re = Vt), Ue(), (Re = '')), ue++;
                    }
                }
                function Pt(H, Y) {
                    return (
                        H.scope && typeof H.scope == 'string' && Ke.openNode(ft.classNameAliases[H.scope] || H.scope),
                        H.beginScope &&
                            (H.beginScope._wrap
                                ? (Xe(Re, ft.classNameAliases[H.beginScope._wrap] || H.beginScope._wrap), (Re = ''))
                                : H.beginScope._multi && (xt(H.beginScope, Y), (Re = ''))),
                        (ee = Object.create(H, { parent: { value: ee } })),
                        ee
                    );
                }
                function De(H, Y, ue) {
                    let Ae = UF(H.endRe, ue);
                    if (Ae) {
                        if (H['on:end']) {
                            let ct = new wu(H);
                            H['on:end'](Y, ct), ct.isMatchIgnored && (Ae = !1);
                        }
                        if (Ae) {
                            for (; H.endsParent && H.parent; ) H = H.parent;
                            return H;
                        }
                    }
                    if (H.endsWithParent) return De(H.parent, Y, ue);
                }
                function _t(H) {
                    return ee.matcher.regexIndex === 0 ? ((Re += H[0]), 1) : ((re = !0), 0);
                }
                function Zt(H) {
                    let Y = H[0],
                        ue = H.rule,
                        Ae = new wu(ue),
                        ct = [ue.__beforeBegin, ue['on:begin']];
                    for (let Vt of ct) if (Vt && (Vt(H, Ae), Ae.isMatchIgnored)) return _t(Y);
                    return (
                        ue.skip
                            ? (Re += Y)
                            : (ue.excludeBegin && (Re += Y), He(), !ue.returnBegin && !ue.excludeBegin && (Re = Y)),
                        Pt(ue, H),
                        ue.returnBegin ? 0 : Y.length
                    );
                }
                function st(H) {
                    let Y = H[0],
                        ue = R.substring(H.index),
                        Ae = De(ee, H, ue);
                    if (!Ae) return U_;
                    let ct = ee;
                    ee.endScope && ee.endScope._wrap
                        ? (He(), Xe(Y, ee.endScope._wrap))
                        : ee.endScope && ee.endScope._multi
                          ? (He(), xt(ee.endScope, H))
                          : ct.skip
                            ? (Re += Y)
                            : (ct.returnEnd || ct.excludeEnd || (Re += Y), He(), ct.excludeEnd && (Re = Y));
                    do
                        ee.scope && Ke.closeNode(),
                            !ee.skip && !ee.subLanguage && (mt += ee.relevance),
                            (ee = ee.parent);
                    while (ee !== Ae.parent);
                    return Ae.starts && Pt(Ae.starts, H), ct.returnEnd ? 0 : Y.length;
                }
                function jt() {
                    let H = [];
                    for (let Y = ee; Y !== ft; Y = Y.parent) Y.scope && H.unshift(Y.scope);
                    H.forEach((Y) => Ke.openNode(Y));
                }
                let St = {};
                function Nt(H, Y) {
                    let ue = Y && Y[0];
                    if (((Re += H), ue == null)) return He(), 0;
                    if (St.type === 'begin' && Y.type === 'end' && St.index === Y.index && ue === '') {
                        if (((Re += R.slice(Y.index, Y.index + 1)), !i)) {
                            let Ae = new Error(`0 width match regex (${O})`);
                            throw ((Ae.languageName = O), (Ae.badRule = St.rule), Ae);
                        }
                        return 1;
                    }
                    if (((St = Y), Y.type === 'begin')) return Zt(Y);
                    if (Y.type === 'illegal' && !V) {
                        let Ae = new Error('Illegal lexeme "' + ue + '" for mode "' + (ee.scope || '<unnamed>') + '"');
                        throw ((Ae.mode = ee), Ae);
                    } else if (Y.type === 'end') {
                        let Ae = st(Y);
                        if (Ae !== U_) return Ae;
                    }
                    if (Y.type === 'illegal' && ue === '') return 1;
                    if (J > 1e5 && J > Y.index * 3)
                        throw new Error('potential infinite loop, way more iterations than matches');
                    return (Re += ue), ue.length;
                }
                let ft = $(O);
                if (!ft) throw (bo(o.replace('{}', O)), new Error('Unknown language: "' + O + '"'));
                let be = xH(ft),
                    Kt = '',
                    ee = Q || be,
                    Ce = {},
                    Ke = new l.__emitter(l);
                jt();
                let Re = '',
                    mt = 0,
                    Ot = 0,
                    J = 0,
                    re = !1;
                try {
                    if (ft.__emitTokens) ft.__emitTokens(R, Ke);
                    else {
                        for (ee.matcher.considerAll(); ; ) {
                            J++, re ? (re = !1) : ee.matcher.considerAll(), (ee.matcher.lastIndex = Ot);
                            let H = ee.matcher.exec(R);
                            if (!H) break;
                            let Y = R.substring(Ot, H.index),
                                ue = Nt(Y, H);
                            Ot = H.index + ue;
                        }
                        Nt(R.substring(Ot));
                    }
                    return (
                        Ke.finalize(),
                        (Kt = Ke.toHTML()),
                        { language: O, value: Kt, relevance: mt, illegal: !1, _emitter: Ke, _top: ee }
                    );
                } catch (H) {
                    if (H.message && H.message.includes('Illegal'))
                        return {
                            language: O,
                            value: wm(R),
                            illegal: !0,
                            relevance: 0,
                            _illegalBy: {
                                message: H.message,
                                index: Ot,
                                context: R.slice(Ot - 100, Ot + 100),
                                mode: H.mode,
                                resultSoFar: Kt,
                            },
                            _emitter: Ke,
                        };
                    if (i)
                        return {
                            language: O,
                            value: wm(R),
                            illegal: !1,
                            relevance: 0,
                            errorRaised: H,
                            _emitter: Ke,
                            _top: ee,
                        };
                    throw H;
                }
            }
            function m(O) {
                let R = { value: wm(O), illegal: !1, relevance: 0, _top: s, _emitter: new l.__emitter(l) };
                return R._emitter.addText(O), R;
            }
            function b(O, R) {
                R = R || l.languages || Object.keys(e);
                let V = m(O),
                    Q = R.filter($)
                        .filter(me)
                        .map((He) => h(He, O, !1));
                Q.unshift(V);
                let he = Q.sort((He, Xe) => {
                        if (He.relevance !== Xe.relevance) return Xe.relevance - He.relevance;
                        if (He.language && Xe.language) {
                            if ($(He.language).supersetOf === Xe.language) return 1;
                            if ($(Xe.language).supersetOf === He.language) return -1;
                        }
                        return 0;
                    }),
                    [xe, Ue] = he,
                    We = xe;
                return (We.secondBest = Ue), We;
            }
            function y(O, R, V) {
                let Q = (R && n[R]) || V;
                O.classList.add('hljs'), O.classList.add(`language-${Q}`);
            }
            function v(O) {
                let R = null,
                    V = d(O);
                if (u(V)) return;
                if (
                    (Ee('before:highlightElement', { el: O, language: V }),
                    O.children.length > 0 &&
                        (l.ignoreUnescapedHTML ||
                            (console.warn(
                                'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.',
                            ),
                            console.warn('https://github.com/highlightjs/highlight.js/wiki/security'),
                            console.warn('The element with unescaped HTML:'),
                            console.warn(O)),
                        l.throwUnescapedHTML))
                )
                    throw new Tm('One of your code blocks includes unescaped HTML.', O.innerHTML);
                R = O;
                let Q = R.textContent,
                    he = V ? f(Q, { language: V, ignoreIllegals: !0 }) : b(Q);
                (O.innerHTML = he.value),
                    y(O, V, he.language),
                    (O.result = { language: he.language, re: he.relevance, relevance: he.relevance }),
                    he.secondBest &&
                        (O.secondBest = { language: he.secondBest.language, relevance: he.secondBest.relevance }),
                    Ee('after:highlightElement', { el: O, result: he, text: Q });
            }
            function x(O) {
                l = $_(l, O);
            }
            let T = () => {
                S(), cs('10.6.0', 'initHighlighting() deprecated.  Use highlightAll() now.');
            };
            function D() {
                S(), cs('10.6.0', 'initHighlightingOnLoad() deprecated.  Use highlightAll() now.');
            }
            let I = !1;
            function S() {
                if (document.readyState === 'loading') {
                    I = !0;
                    return;
                }
                document.querySelectorAll(l.cssSelector).forEach(v);
            }
            function z() {
                I && S();
            }
            typeof window < 'u' && window.addEventListener && window.addEventListener('DOMContentLoaded', z, !1);
            function N(O, R) {
                let V = null;
                try {
                    V = R(t);
                } catch (Q) {
                    if ((bo("Language definition for '{}' could not be registered.".replace('{}', O)), i)) bo(Q);
                    else throw Q;
                    V = s;
                }
                V.name || (V.name = O),
                    (e[O] = V),
                    (V.rawDefinition = R.bind(null, t)),
                    V.aliases && oe(V.aliases, { languageName: O });
            }
            function q(O) {
                delete e[O];
                for (let R of Object.keys(n)) n[R] === O && delete n[R];
            }
            function ne() {
                return Object.keys(e);
            }
            function $(O) {
                return (O = (O || '').toLowerCase()), e[O] || e[n[O]];
            }
            function oe(O, { languageName: R }) {
                typeof O == 'string' && (O = [O]),
                    O.forEach((V) => {
                        n[V.toLowerCase()] = R;
                    });
            }
            function me(O) {
                let R = $(O);
                return R && !R.disableAutodetect;
            }
            function Te(O) {
                O['before:highlightBlock'] &&
                    !O['before:highlightElement'] &&
                    (O['before:highlightElement'] = (R) => {
                        O['before:highlightBlock'](Object.assign({ block: R.el }, R));
                    }),
                    O['after:highlightBlock'] &&
                        !O['after:highlightElement'] &&
                        (O['after:highlightElement'] = (R) => {
                            O['after:highlightBlock'](Object.assign({ block: R.el }, R));
                        });
            }
            function ge(O) {
                Te(O), r.push(O);
            }
            function Me(O) {
                let R = r.indexOf(O);
                R !== -1 && r.splice(R, 1);
            }
            function Ee(O, R) {
                let V = O;
                r.forEach(function (Q) {
                    Q[V] && Q[V](R);
                });
            }
            function P(O) {
                return (
                    cs('10.7.0', 'highlightBlock will be removed entirely in v12.0'),
                    cs('10.7.0', 'Please use highlightElement now.'),
                    v(O)
                );
            }
            Object.assign(t, {
                highlight: f,
                highlightAuto: b,
                highlightAll: S,
                highlightElement: v,
                highlightBlock: P,
                configure: x,
                initHighlighting: T,
                initHighlightingOnLoad: D,
                registerLanguage: N,
                unregisterLanguage: q,
                listLanguages: ne,
                getLanguage: $,
                registerAliases: oe,
                autoDetection: me,
                inherit: $_,
                addPlugin: ge,
                removePlugin: Me,
            }),
                (t.debugMode = function () {
                    i = !1;
                }),
                (t.safeMode = function () {
                    i = !0;
                }),
                (t.versionString = SH),
                (t.regex = { concat: yo, lookahead: V_, either: Mm, optional: zF, anyNumberOfTimes: HF });
            for (let O in vu) typeof vu[O] == 'object' && W_(vu[O]);
            return Object.assign(t, vu), t;
        },
        us = eS({});
    us.newInstance = () => eS({});
    tS.exports = us;
    us.HighlightJS = us;
    us.default = us;
});
var iS = Vd((iq, km) => {
    (function () {
        var t;
        typeof km < 'u'
            ? (t = km.exports = r)
            : (t = (function () {
                  return this || (0, eval)('this');
              })()),
            (t.format = r),
            (t.vsprintf = n),
            typeof console < 'u' && typeof console.log == 'function' && (t.printf = e);
        function e() {
            console.log(r.apply(null, arguments));
        }
        function n(i, o) {
            return r.apply(null, [i].concat(o));
        }
        function r(i) {
            for (
                var o = 1,
                    s = [].slice.call(arguments),
                    l = 0,
                    u = i.length,
                    d = '',
                    f,
                    h = !1,
                    m,
                    b,
                    y = !1,
                    v,
                    x = function () {
                        return s[o++];
                    },
                    T = function () {
                        for (var D = ''; /\d/.test(i[l]); ) (D += i[l++]), (f = i[l]);
                        return D.length > 0 ? parseInt(D) : null;
                    };
                l < u;
                ++l
            )
                if (((f = i[l]), h))
                    switch (
                        ((h = !1),
                        f == '.'
                            ? ((y = !1), (f = i[++l]))
                            : f == '0' && i[l + 1] == '.'
                              ? ((y = !0), (l += 2), (f = i[l]))
                              : (y = !0),
                        (v = T()),
                        f)
                    ) {
                        case 'b':
                            d += parseInt(x(), 10).toString(2);
                            break;
                        case 'c':
                            (m = x()),
                                typeof m == 'string' || m instanceof String
                                    ? (d += m)
                                    : (d += String.fromCharCode(parseInt(m, 10)));
                            break;
                        case 'd':
                            d += parseInt(x(), 10);
                            break;
                        case 'f':
                            (b = String(parseFloat(x()).toFixed(v || 6))), (d += y ? b : b.replace(/^0/, ''));
                            break;
                        case 'j':
                            d += JSON.stringify(x());
                            break;
                        case 'o':
                            d += '0' + parseInt(x(), 10).toString(8);
                            break;
                        case 's':
                            d += x();
                            break;
                        case 'x':
                            d += '0x' + parseInt(x(), 10).toString(16);
                            break;
                        case 'X':
                            d += '0x' + parseInt(x(), 10).toString(16).toUpperCase();
                            break;
                        default:
                            d += f;
                            break;
                    }
                else f === '%' ? (h = !0) : (d += f);
            return d;
        }
    })();
});
var vS = Vd((ps, Sa) => {
    (function () {
        var t,
            e = '4.17.21',
            n = 200,
            r = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
            i = 'Expected a function',
            o = 'Invalid `variable` option passed into `_.template`',
            s = '__lodash_hash_undefined__',
            l = 500,
            u = '__lodash_placeholder__',
            d = 1,
            f = 2,
            h = 4,
            m = 1,
            b = 2,
            y = 1,
            v = 2,
            x = 4,
            T = 8,
            D = 16,
            I = 32,
            S = 64,
            z = 128,
            N = 256,
            q = 512,
            ne = 30,
            $ = '...',
            oe = 800,
            me = 16,
            Te = 1,
            ge = 2,
            Me = 3,
            Ee = 1 / 0,
            P = 9007199254740991,
            O = 17976931348623157e292,
            R = NaN,
            V = 4294967295,
            Q = V - 1,
            he = V >>> 1,
            xe = [
                ['ary', z],
                ['bind', y],
                ['bindKey', v],
                ['curry', T],
                ['curryRight', D],
                ['flip', q],
                ['partial', I],
                ['partialRight', S],
                ['rearg', N],
            ],
            Ue = '[object Arguments]',
            We = '[object Array]',
            He = '[object AsyncFunction]',
            Xe = '[object Boolean]',
            xt = '[object Date]',
            Pt = '[object DOMException]',
            De = '[object Error]',
            _t = '[object Function]',
            Zt = '[object GeneratorFunction]',
            st = '[object Map]',
            jt = '[object Number]',
            St = '[object Null]',
            Nt = '[object Object]',
            ft = '[object Promise]',
            be = '[object Proxy]',
            Kt = '[object RegExp]',
            ee = '[object Set]',
            Ce = '[object String]',
            Ke = '[object Symbol]',
            Re = '[object Undefined]',
            mt = '[object WeakMap]',
            Ot = '[object WeakSet]',
            J = '[object ArrayBuffer]',
            re = '[object DataView]',
            H = '[object Float32Array]',
            Y = '[object Float64Array]',
            ue = '[object Int8Array]',
            Ae = '[object Int16Array]',
            ct = '[object Int32Array]',
            Vt = '[object Uint8Array]',
            Mi = '[object Uint8ClampedArray]',
            B = '[object Uint16Array]',
            le = '[object Uint32Array]',
            _e = /\b__p \+= '';/g,
            Ze = /\b(__p \+=) '' \+/g,
            qe = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            Bt = /&(?:amp|lt|gt|quot|#39);/g,
            an = /[&<>"']/g,
            qr = RegExp(Bt.source),
            Ta = RegExp(an.source),
            xr = /<%-([\s\S]+?)%>/g,
            hs = /<%([\s\S]+?)%>/g,
            Ai = /<%=([\s\S]+?)%>/g,
            Yr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            Iu = /^\w*$/,
            ms = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Jr = /[\\^$.*+?()[\]{}|]/g,
            _S = RegExp(Jr.source),
            Lu = /^\s+/,
            SS = /\s/,
            TS = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            MS = /\{\n\/\* \[wrapped with (.+)\] \*/,
            AS = /,? & /,
            CS = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            kS = /[()=,{}\[\]\/\s]/,
            NS = /\\(\\)?/g,
            OS = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            Dm = /\w*$/,
            RS = /^[-+]0x[0-9a-f]+$/i,
            IS = /^0b[01]+$/i,
            LS = /^\[object .+?Constructor\]$/,
            DS = /^0o[0-7]+$/i,
            PS = /^(?:0|[1-9]\d*)$/,
            BS = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            Ma = /($^)/,
            FS = /['\n\r\u2028\u2029\\]/g,
            Aa = '\\ud800-\\udfff',
            HS = '\\u0300-\\u036f',
            zS = '\\ufe20-\\ufe2f',
            $S = '\\u20d0-\\u20ff',
            Pm = HS + zS + $S,
            Bm = '\\u2700-\\u27bf',
            Fm = 'a-z\\xdf-\\xf6\\xf8-\\xff',
            US = '\\xac\\xb1\\xd7\\xf7',
            WS = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
            KS = '\\u2000-\\u206f',
            VS =
                ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
            Hm = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
            zm = '\\ufe0e\\ufe0f',
            $m = US + WS + KS + VS,
            Du = "['\u2019]",
            GS = '[' + Aa + ']',
            Um = '[' + $m + ']',
            Ca = '[' + Pm + ']',
            Wm = '\\d+',
            qS = '[' + Bm + ']',
            Km = '[' + Fm + ']',
            Vm = '[^' + Aa + $m + Wm + Bm + Fm + Hm + ']',
            Pu = '\\ud83c[\\udffb-\\udfff]',
            YS = '(?:' + Ca + '|' + Pu + ')',
            Gm = '[^' + Aa + ']',
            Bu = '(?:\\ud83c[\\udde6-\\uddff]){2}',
            Fu = '[\\ud800-\\udbff][\\udc00-\\udfff]',
            vo = '[' + Hm + ']',
            qm = '\\u200d',
            Ym = '(?:' + Km + '|' + Vm + ')',
            JS = '(?:' + vo + '|' + Vm + ')',
            Jm = '(?:' + Du + '(?:d|ll|m|re|s|t|ve))?',
            Xm = '(?:' + Du + '(?:D|LL|M|RE|S|T|VE))?',
            Zm = YS + '?',
            jm = '[' + zm + ']?',
            XS = '(?:' + qm + '(?:' + [Gm, Bu, Fu].join('|') + ')' + jm + Zm + ')*',
            ZS = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
            jS = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
            Qm = jm + Zm + XS,
            QS = '(?:' + [qS, Bu, Fu].join('|') + ')' + Qm,
            e1 = '(?:' + [Gm + Ca + '?', Ca, Bu, Fu, GS].join('|') + ')',
            t1 = RegExp(Du, 'g'),
            n1 = RegExp(Ca, 'g'),
            Hu = RegExp(Pu + '(?=' + Pu + ')|' + e1 + Qm, 'g'),
            r1 = RegExp(
                [
                    vo + '?' + Km + '+' + Jm + '(?=' + [Um, vo, '$'].join('|') + ')',
                    JS + '+' + Xm + '(?=' + [Um, vo + Ym, '$'].join('|') + ')',
                    vo + '?' + Ym + '+' + Jm,
                    vo + '+' + Xm,
                    jS,
                    ZS,
                    Wm,
                    QS,
                ].join('|'),
                'g',
            ),
            i1 = RegExp('[' + qm + Aa + Pm + zm + ']'),
            o1 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            s1 = [
                'Array',
                'Buffer',
                'DataView',
                'Date',
                'Error',
                'Float32Array',
                'Float64Array',
                'Function',
                'Int8Array',
                'Int16Array',
                'Int32Array',
                'Map',
                'Math',
                'Object',
                'Promise',
                'RegExp',
                'Set',
                'String',
                'Symbol',
                'TypeError',
                'Uint8Array',
                'Uint8ClampedArray',
                'Uint16Array',
                'Uint32Array',
                'WeakMap',
                '_',
                'clearTimeout',
                'isFinite',
                'parseInt',
                'setTimeout',
            ],
            a1 = -1,
            at = {};
        (at[H] = at[Y] = at[ue] = at[Ae] = at[ct] = at[Vt] = at[Mi] = at[B] = at[le] = !0),
            (at[Ue] =
                at[We] =
                at[J] =
                at[Xe] =
                at[re] =
                at[xt] =
                at[De] =
                at[_t] =
                at[st] =
                at[jt] =
                at[Nt] =
                at[Kt] =
                at[ee] =
                at[Ce] =
                at[mt] =
                    !1);
        var it = {};
        (it[Ue] =
            it[We] =
            it[J] =
            it[re] =
            it[Xe] =
            it[xt] =
            it[H] =
            it[Y] =
            it[ue] =
            it[Ae] =
            it[ct] =
            it[st] =
            it[jt] =
            it[Nt] =
            it[Kt] =
            it[ee] =
            it[Ce] =
            it[Ke] =
            it[Vt] =
            it[Mi] =
            it[B] =
            it[le] =
                !0),
            (it[De] = it[_t] = it[mt] = !1);
        var l1 = {
                : 'A',
                : 'A',
                : 'A',
                : 'A',
                : 'A',
                : 'A',
                : 'a',
                : 'a',
                : 'a',
                : 'a',
                : 'a',
                : 'a',
                : 'C',
                : 'c',
                : 'D',
                : 'd',
                : 'E',
                : 'E',
                : 'E',
                : 'E',
                : 'e',
                : 'e',
                : 'e',
                : 'e',
                : 'I',
                : 'I',
                : 'I',
                : 'I',
                : 'i',
                : 'i',
                : 'i',
                : 'i',
                : 'N',
                : 'n',
                : 'O',
                : 'O',
                : 'O',
                : 'O',
                : 'O',
                : 'O',
                : 'o',
                : 'o',
                : 'o',
                : 'o',
                : 'o',
                : 'o',
                : 'U',
                : 'U',
                : 'U',
                : 'U',
                : 'u',
                : 'u',
                : 'u',
                : 'u',
                : 'Y',
                : 'y',
                : 'y',
                : 'Ae',
                : 'ae',
                : 'Th',
                : 'th',
                : 'ss',
                : 'A',
                : 'A',
                : 'A',
                : 'a',
                : 'a',
                : 'a',
                : 'C',
                : 'C',
                : 'C',
                : 'C',
                : 'c',
                : 'c',
                : 'c',
                : 'c',
                : 'D',
                : 'D',
                : 'd',
                : 'd',
                : 'E',
                : 'E',
                : 'E',
                : 'E',
                : 'E',
                : 'e',
                : 'e',
                : 'e',
                : 'e',
                : 'e',
                : 'G',
                : 'G',
                : 'G',
                : 'G',
                : 'g',
                : 'g',
                : 'g',
                : 'g',
                : 'H',
                : 'H',
                : 'h',
                : 'h',
                : 'I',
                : 'I',
                : 'I',
                : 'I',
                : 'I',
                : 'i',
                : 'i',
                : 'i',
                : 'i',
                : 'i',
                : 'J',
                : 'j',
                : 'K',
                : 'k',
                : 'k',
                : 'L',
                : 'L',
                : 'L',
                : 'L',
                : 'L',
                : 'l',
                : 'l',
                : 'l',
                : 'l',
                : 'l',
                : 'N',
                : 'N',
                : 'N',
                : 'N',
                : 'n',
                : 'n',
                : 'n',
                : 'n',
                : 'O',
                : 'O',
                : 'O',
                : 'o',
                : 'o',
                : 'o',
                : 'R',
                : 'R',
                : 'R',
                : 'r',
                : 'r',
                : 'r',
                : 'S',
                : 'S',
                : 'S',
                : 'S',
                : 's',
                : 's',
                : 's',
                : 's',
                : 'T',
                : 'T',
                : 'T',
                : 't',
                : 't',
                : 't',
                : 'U',
                : 'U',
                : 'U',
                : 'U',
                : 'U',
                : 'U',
                : 'u',
                : 'u',
                : 'u',
                : 'u',
                : 'u',
                : 'u',
                : 'W',
                : 'w',
                : 'Y',
                : 'y',
                : 'Y',
                : 'Z',
                : 'Z',
                : 'Z',
                : 'z',
                : 'z',
                : 'z',
                : 'IJ',
                : 'ij',
                : 'Oe',
                : 'oe',
                : "'n",
                : 's',
            },
            c1 = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' },
            u1 = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#39;': "'" },
            d1 = { '\\': '\\', "'": "'", '\n': 'n', '\r': 'r', '\u2028': 'u2028', '\u2029': 'u2029' },
            f1 = parseFloat,
            p1 = parseInt,
            eg = typeof global == 'object' && global && global.Object === Object && global,
            h1 = typeof self == 'object' && self && self.Object === Object && self,
            Ft = eg || h1 || Function('return this')(),
            zu = typeof ps == 'object' && ps && !ps.nodeType && ps,
            Ci = zu && typeof Sa == 'object' && Sa && !Sa.nodeType && Sa,
            tg = Ci && Ci.exports === zu,
            $u = tg && eg.process,
            On = (function () {
                try {
                    var C = Ci && Ci.require && Ci.require('util').types;
                    return C || ($u && $u.binding && $u.binding('util'));
                } catch {}
            })(),
            ng = On && On.isArrayBuffer,
            rg = On && On.isDate,
            ig = On && On.isMap,
            og = On && On.isRegExp,
            sg = On && On.isSet,
            ag = On && On.isTypedArray;
        function Sn(C, F, L) {
            switch (L.length) {
                case 0:
                    return C.call(F);
                case 1:
                    return C.call(F, L[0]);
                case 2:
                    return C.call(F, L[0], L[1]);
                case 3:
                    return C.call(F, L[0], L[1], L[2]);
            }
            return C.apply(F, L);
        }
        function m1(C, F, L, se) {
            for (var ke = -1, je = C == null ? 0 : C.length; ++ke < je; ) {
                var Rt = C[ke];
                F(se, Rt, L(Rt), C);
            }
            return se;
        }
        function Rn(C, F) {
            for (var L = -1, se = C == null ? 0 : C.length; ++L < se && F(C[L], L, C) !== !1; );
            return C;
        }
        function g1(C, F) {
            for (var L = C == null ? 0 : C.length; L-- && F(C[L], L, C) !== !1; );
            return C;
        }
        function lg(C, F) {
            for (var L = -1, se = C == null ? 0 : C.length; ++L < se; ) if (!F(C[L], L, C)) return !1;
            return !0;
        }
        function Xr(C, F) {
            for (var L = -1, se = C == null ? 0 : C.length, ke = 0, je = []; ++L < se; ) {
                var Rt = C[L];
                F(Rt, L, C) && (je[ke++] = Rt);
            }
            return je;
        }
        function ka(C, F) {
            var L = C == null ? 0 : C.length;
            return !!L && wo(C, F, 0) > -1;
        }
        function Uu(C, F, L) {
            for (var se = -1, ke = C == null ? 0 : C.length; ++se < ke; ) if (L(F, C[se])) return !0;
            return !1;
        }
        function ut(C, F) {
            for (var L = -1, se = C == null ? 0 : C.length, ke = Array(se); ++L < se; ) ke[L] = F(C[L], L, C);
            return ke;
        }
        function Zr(C, F) {
            for (var L = -1, se = F.length, ke = C.length; ++L < se; ) C[ke + L] = F[L];
            return C;
        }
        function Wu(C, F, L, se) {
            var ke = -1,
                je = C == null ? 0 : C.length;
            for (se && je && (L = C[++ke]); ++ke < je; ) L = F(L, C[ke], ke, C);
            return L;
        }
        function b1(C, F, L, se) {
            var ke = C == null ? 0 : C.length;
            for (se && ke && (L = C[--ke]); ke--; ) L = F(L, C[ke], ke, C);
            return L;
        }
        function Ku(C, F) {
            for (var L = -1, se = C == null ? 0 : C.length; ++L < se; ) if (F(C[L], L, C)) return !0;
            return !1;
        }
        var y1 = Vu('length');
        function E1(C) {
            return C.split('');
        }
        function v1(C) {
            return C.match(CS) || [];
        }
        function cg(C, F, L) {
            var se;
            return (
                L(C, function (ke, je, Rt) {
                    if (F(ke, je, Rt)) return (se = je), !1;
                }),
                se
            );
        }
        function Na(C, F, L, se) {
            for (var ke = C.length, je = L + (se ? 1 : -1); se ? je-- : ++je < ke; ) if (F(C[je], je, C)) return je;
            return -1;
        }
        function wo(C, F, L) {
            return F === F ? R1(C, F, L) : Na(C, ug, L);
        }
        function w1(C, F, L, se) {
            for (var ke = L - 1, je = C.length; ++ke < je; ) if (se(C[ke], F)) return ke;
            return -1;
        }
        function ug(C) {
            return C !== C;
        }
        function dg(C, F) {
            var L = C == null ? 0 : C.length;
            return L ? qu(C, F) / L : R;
        }
        function Vu(C) {
            return function (F) {
                return F == null ? t : F[C];
            };
        }
        function Gu(C) {
            return function (F) {
                return C == null ? t : C[F];
            };
        }
        function fg(C, F, L, se, ke) {
            return (
                ke(C, function (je, Rt, nt) {
                    L = se ? ((se = !1), je) : F(L, je, Rt, nt);
                }),
                L
            );
        }
        function x1(C, F) {
            var L = C.length;
            for (C.sort(F); L--; ) C[L] = C[L].value;
            return C;
        }
        function qu(C, F) {
            for (var L, se = -1, ke = C.length; ++se < ke; ) {
                var je = F(C[se]);
                je !== t && (L = L === t ? je : L + je);
            }
            return L;
        }
        function Yu(C, F) {
            for (var L = -1, se = Array(C); ++L < C; ) se[L] = F(L);
            return se;
        }
        function _1(C, F) {
            return ut(F, function (L) {
                return [L, C[L]];
            });
        }
        function pg(C) {
            return C && C.slice(0, bg(C) + 1).replace(Lu, '');
        }
        function Tn(C) {
            return function (F) {
                return C(F);
            };
        }
        function Ju(C, F) {
            return ut(F, function (L) {
                return C[L];
            });
        }
        function gs(C, F) {
            return C.has(F);
        }
        function hg(C, F) {
            for (var L = -1, se = C.length; ++L < se && wo(F, C[L], 0) > -1; );
            return L;
        }
        function mg(C, F) {
            for (var L = C.length; L-- && wo(F, C[L], 0) > -1; );
            return L;
        }
        function S1(C, F) {
            for (var L = C.length, se = 0; L--; ) C[L] === F && ++se;
            return se;
        }
        var T1 = Gu(l1),
            M1 = Gu(c1);
        function A1(C) {
            return '\\' + d1[C];
        }
        function C1(C, F) {
            return C == null ? t : C[F];
        }
        function xo(C) {
            return i1.test(C);
        }
        function k1(C) {
            return o1.test(C);
        }
        function N1(C) {
            for (var F, L = []; !(F = C.next()).done; ) L.push(F.value);
            return L;
        }
        function Xu(C) {
            var F = -1,
                L = Array(C.size);
            return (
                C.forEach(function (se, ke) {
                    L[++F] = [ke, se];
                }),
                L
            );
        }
        function gg(C, F) {
            return function (L) {
                return C(F(L));
            };
        }
        function jr(C, F) {
            for (var L = -1, se = C.length, ke = 0, je = []; ++L < se; ) {
                var Rt = C[L];
                (Rt === F || Rt === u) && ((C[L] = u), (je[ke++] = L));
            }
            return je;
        }
        function Oa(C) {
            var F = -1,
                L = Array(C.size);
            return (
                C.forEach(function (se) {
                    L[++F] = se;
                }),
                L
            );
        }
        function O1(C) {
            var F = -1,
                L = Array(C.size);
            return (
                C.forEach(function (se) {
                    L[++F] = [se, se];
                }),
                L
            );
        }
        function R1(C, F, L) {
            for (var se = L - 1, ke = C.length; ++se < ke; ) if (C[se] === F) return se;
            return -1;
        }
        function I1(C, F, L) {
            for (var se = L + 1; se--; ) if (C[se] === F) return se;
            return se;
        }
        function _o(C) {
            return xo(C) ? D1(C) : y1(C);
        }
        function Xn(C) {
            return xo(C) ? P1(C) : E1(C);
        }
        function bg(C) {
            for (var F = C.length; F-- && SS.test(C.charAt(F)); );
            return F;
        }
        var L1 = Gu(u1);
        function D1(C) {
            for (var F = (Hu.lastIndex = 0); Hu.test(C); ) ++F;
            return F;
        }
        function P1(C) {
            return C.match(Hu) || [];
        }
        function B1(C) {
            return C.match(r1) || [];
        }
        var F1 = function C(F) {
                F = F == null ? Ft : Qr.defaults(Ft.Object(), F, Qr.pick(Ft, s1));
                var L = F.Array,
                    se = F.Date,
                    ke = F.Error,
                    je = F.Function,
                    Rt = F.Math,
                    nt = F.Object,
                    Zu = F.RegExp,
                    H1 = F.String,
                    In = F.TypeError,
                    Ra = L.prototype,
                    z1 = je.prototype,
                    So = nt.prototype,
                    Ia = F['__core-js_shared__'],
                    La = z1.toString,
                    et = So.hasOwnProperty,
                    $1 = 0,
                    yg = (function () {
                        var a = /[^.]+$/.exec((Ia && Ia.keys && Ia.keys.IE_PROTO) || '');
                        return a ? 'Symbol(src)_1.' + a : '';
                    })(),
                    Da = So.toString,
                    U1 = La.call(nt),
                    W1 = Ft._,
                    K1 = Zu(
                        '^' +
                            La.call(et)
                                .replace(Jr, '\\$&')
                                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
                            '$',
                    ),
                    Pa = tg ? F.Buffer : t,
                    ei = F.Symbol,
                    Ba = F.Uint8Array,
                    Eg = Pa ? Pa.allocUnsafe : t,
                    Fa = gg(nt.getPrototypeOf, nt),
                    vg = nt.create,
                    wg = So.propertyIsEnumerable,
                    Ha = Ra.splice,
                    xg = ei ? ei.isConcatSpreadable : t,
                    bs = ei ? ei.iterator : t,
                    ki = ei ? ei.toStringTag : t,
                    za = (function () {
                        try {
                            var a = Li(nt, 'defineProperty');
                            return a({}, '', {}), a;
                        } catch {}
                    })(),
                    V1 = F.clearTimeout !== Ft.clearTimeout && F.clearTimeout,
                    G1 = se && se.now !== Ft.Date.now && se.now,
                    q1 = F.setTimeout !== Ft.setTimeout && F.setTimeout,
                    $a = Rt.ceil,
                    Ua = Rt.floor,
                    ju = nt.getOwnPropertySymbols,
                    Y1 = Pa ? Pa.isBuffer : t,
                    _g = F.isFinite,
                    J1 = Ra.join,
                    X1 = gg(nt.keys, nt),
                    It = Rt.max,
                    Qt = Rt.min,
                    Z1 = se.now,
                    j1 = F.parseInt,
                    Sg = Rt.random,
                    Q1 = Ra.reverse,
                    Qu = Li(F, 'DataView'),
                    ys = Li(F, 'Map'),
                    ed = Li(F, 'Promise'),
                    To = Li(F, 'Set'),
                    Es = Li(F, 'WeakMap'),
                    vs = Li(nt, 'create'),
                    Wa = Es && new Es(),
                    Mo = {},
                    eT = Di(Qu),
                    tT = Di(ys),
                    nT = Di(ed),
                    rT = Di(To),
                    iT = Di(Es),
                    Ka = ei ? ei.prototype : t,
                    ws = Ka ? Ka.valueOf : t,
                    Tg = Ka ? Ka.toString : t;
                function w(a) {
                    if (gt(a) && !Ne(a) && !(a instanceof Ve)) {
                        if (a instanceof Ln) return a;
                        if (et.call(a, '__wrapped__')) return Mb(a);
                    }
                    return new Ln(a);
                }
                var Ao = (function () {
                    function a() {}
                    return function (c) {
                        if (!pt(c)) return {};
                        if (vg) return vg(c);
                        a.prototype = c;
                        var p = new a();
                        return (a.prototype = t), p;
                    };
                })();
                function Va() {}
                function Ln(a, c) {
                    (this.__wrapped__ = a),
                        (this.__actions__ = []),
                        (this.__chain__ = !!c),
                        (this.__index__ = 0),
                        (this.__values__ = t);
                }
                (w.templateSettings = { escape: xr, evaluate: hs, interpolate: Ai, variable: '', imports: { _: w } }),
                    (w.prototype = Va.prototype),
                    (w.prototype.constructor = w),
                    (Ln.prototype = Ao(Va.prototype)),
                    (Ln.prototype.constructor = Ln);
                function Ve(a) {
                    (this.__wrapped__ = a),
                        (this.__actions__ = []),
                        (this.__dir__ = 1),
                        (this.__filtered__ = !1),
                        (this.__iteratees__ = []),
                        (this.__takeCount__ = V),
                        (this.__views__ = []);
                }
                function oT() {
                    var a = new Ve(this.__wrapped__);
                    return (
                        (a.__actions__ = gn(this.__actions__)),
                        (a.__dir__ = this.__dir__),
                        (a.__filtered__ = this.__filtered__),
                        (a.__iteratees__ = gn(this.__iteratees__)),
                        (a.__takeCount__ = this.__takeCount__),
                        (a.__views__ = gn(this.__views__)),
                        a
                    );
                }
                function sT() {
                    if (this.__filtered__) {
                        var a = new Ve(this);
                        (a.__dir__ = -1), (a.__filtered__ = !0);
                    } else (a = this.clone()), (a.__dir__ *= -1);
                    return a;
                }
                function aT() {
                    var a = this.__wrapped__.value(),
                        c = this.__dir__,
                        p = Ne(a),
                        g = c < 0,
                        E = p ? a.length : 0,
                        _ = EM(0, E, this.__views__),
                        M = _.start,
                        A = _.end,
                        k = A - M,
                        U = g ? A : M - 1,
                        W = this.__iteratees__,
                        G = W.length,
                        te = 0,
                        de = Qt(k, this.__takeCount__);
                    if (!p || (!g && E == k && de == k)) return Jg(a, this.__actions__);
                    var ve = [];
                    e: for (; k-- && te < de; ) {
                        U += c;
                        for (var Pe = -1, we = a[U]; ++Pe < G; ) {
                            var $e = W[Pe],
                                Ye = $e.iteratee,
                                Cn = $e.type,
                                un = Ye(we);
                            if (Cn == ge) we = un;
                            else if (!un) {
                                if (Cn == Te) continue e;
                                break e;
                            }
                        }
                        ve[te++] = we;
                    }
                    return ve;
                }
                (Ve.prototype = Ao(Va.prototype)), (Ve.prototype.constructor = Ve);
                function Ni(a) {
                    var c = -1,
                        p = a == null ? 0 : a.length;
                    for (this.clear(); ++c < p; ) {
                        var g = a[c];
                        this.set(g[0], g[1]);
                    }
                }
                function lT() {
                    (this.__data__ = vs ? vs(null) : {}), (this.size = 0);
                }
                function cT(a) {
                    var c = this.has(a) && delete this.__data__[a];
                    return (this.size -= c ? 1 : 0), c;
                }
                function uT(a) {
                    var c = this.__data__;
                    if (vs) {
                        var p = c[a];
                        return p === s ? t : p;
                    }
                    return et.call(c, a) ? c[a] : t;
                }
                function dT(a) {
                    var c = this.__data__;
                    return vs ? c[a] !== t : et.call(c, a);
                }
                function fT(a, c) {
                    var p = this.__data__;
                    return (this.size += this.has(a) ? 0 : 1), (p[a] = vs && c === t ? s : c), this;
                }
                (Ni.prototype.clear = lT),
                    (Ni.prototype.delete = cT),
                    (Ni.prototype.get = uT),
                    (Ni.prototype.has = dT),
                    (Ni.prototype.set = fT);
                function _r(a) {
                    var c = -1,
                        p = a == null ? 0 : a.length;
                    for (this.clear(); ++c < p; ) {
                        var g = a[c];
                        this.set(g[0], g[1]);
                    }
                }
                function pT() {
                    (this.__data__ = []), (this.size = 0);
                }
                function hT(a) {
                    var c = this.__data__,
                        p = Ga(c, a);
                    if (p < 0) return !1;
                    var g = c.length - 1;
                    return p == g ? c.pop() : Ha.call(c, p, 1), --this.size, !0;
                }
                function mT(a) {
                    var c = this.__data__,
                        p = Ga(c, a);
                    return p < 0 ? t : c[p][1];
                }
                function gT(a) {
                    return Ga(this.__data__, a) > -1;
                }
                function bT(a, c) {
                    var p = this.__data__,
                        g = Ga(p, a);
                    return g < 0 ? (++this.size, p.push([a, c])) : (p[g][1] = c), this;
                }
                (_r.prototype.clear = pT),
                    (_r.prototype.delete = hT),
                    (_r.prototype.get = mT),
                    (_r.prototype.has = gT),
                    (_r.prototype.set = bT);
                function Sr(a) {
                    var c = -1,
                        p = a == null ? 0 : a.length;
                    for (this.clear(); ++c < p; ) {
                        var g = a[c];
                        this.set(g[0], g[1]);
                    }
                }
                function yT() {
                    (this.size = 0), (this.__data__ = { hash: new Ni(), map: new (ys || _r)(), string: new Ni() });
                }
                function ET(a) {
                    var c = il(this, a).delete(a);
                    return (this.size -= c ? 1 : 0), c;
                }
                function vT(a) {
                    return il(this, a).get(a);
                }
                function wT(a) {
                    return il(this, a).has(a);
                }
                function xT(a, c) {
                    var p = il(this, a),
                        g = p.size;
                    return p.set(a, c), (this.size += p.size == g ? 0 : 1), this;
                }
                (Sr.prototype.clear = yT),
                    (Sr.prototype.delete = ET),
                    (Sr.prototype.get = vT),
                    (Sr.prototype.has = wT),
                    (Sr.prototype.set = xT);
                function Oi(a) {
                    var c = -1,
                        p = a == null ? 0 : a.length;
                    for (this.__data__ = new Sr(); ++c < p; ) this.add(a[c]);
                }
                function _T(a) {
                    return this.__data__.set(a, s), this;
                }
                function ST(a) {
                    return this.__data__.has(a);
                }
                (Oi.prototype.add = Oi.prototype.push = _T), (Oi.prototype.has = ST);
                function Zn(a) {
                    var c = (this.__data__ = new _r(a));
                    this.size = c.size;
                }
                function TT() {
                    (this.__data__ = new _r()), (this.size = 0);
                }
                function MT(a) {
                    var c = this.__data__,
                        p = c.delete(a);
                    return (this.size = c.size), p;
                }
                function AT(a) {
                    return this.__data__.get(a);
                }
                function CT(a) {
                    return this.__data__.has(a);
                }
                function kT(a, c) {
                    var p = this.__data__;
                    if (p instanceof _r) {
                        var g = p.__data__;
                        if (!ys || g.length < n - 1) return g.push([a, c]), (this.size = ++p.size), this;
                        p = this.__data__ = new Sr(g);
                    }
                    return p.set(a, c), (this.size = p.size), this;
                }
                (Zn.prototype.clear = TT),
                    (Zn.prototype.delete = MT),
                    (Zn.prototype.get = AT),
                    (Zn.prototype.has = CT),
                    (Zn.prototype.set = kT);
                function Mg(a, c) {
                    var p = Ne(a),
                        g = !p && Pi(a),
                        E = !p && !g && oi(a),
                        _ = !p && !g && !E && Oo(a),
                        M = p || g || E || _,
                        A = M ? Yu(a.length, H1) : [],
                        k = A.length;
                    for (var U in a)
                        (c || et.call(a, U)) &&
                            !(
                                M &&
                                (U == 'length' ||
                                    (E && (U == 'offset' || U == 'parent')) ||
                                    (_ && (U == 'buffer' || U == 'byteLength' || U == 'byteOffset')) ||
                                    Cr(U, k))
                            ) &&
                            A.push(U);
                    return A;
                }
                function Ag(a) {
                    var c = a.length;
                    return c ? a[dd(0, c - 1)] : t;
                }
                function NT(a, c) {
                    return ol(gn(a), Ri(c, 0, a.length));
                }
                function OT(a) {
                    return ol(gn(a));
                }
                function td(a, c, p) {
                    ((p !== t && !jn(a[c], p)) || (p === t && !(c in a))) && Tr(a, c, p);
                }
                function xs(a, c, p) {
                    var g = a[c];
                    (!(et.call(a, c) && jn(g, p)) || (p === t && !(c in a))) && Tr(a, c, p);
                }
                function Ga(a, c) {
                    for (var p = a.length; p--; ) if (jn(a[p][0], c)) return p;
                    return -1;
                }
                function RT(a, c, p, g) {
                    return (
                        ti(a, function (E, _, M) {
                            c(g, E, p(E), M);
                        }),
                        g
                    );
                }
                function Cg(a, c) {
                    return a && ur(c, Ht(c), a);
                }
                function IT(a, c) {
                    return a && ur(c, yn(c), a);
                }
                function Tr(a, c, p) {
                    c == '__proto__' && za
                        ? za(a, c, { configurable: !0, enumerable: !0, value: p, writable: !0 })
                        : (a[c] = p);
                }
                function nd(a, c) {
                    for (var p = -1, g = c.length, E = L(g), _ = a == null; ++p < g; ) E[p] = _ ? t : Pd(a, c[p]);
                    return E;
                }
                function Ri(a, c, p) {
                    return a === a && (p !== t && (a = a <= p ? a : p), c !== t && (a = a >= c ? a : c)), a;
                }
                function Dn(a, c, p, g, E, _) {
                    var M,
                        A = c & d,
                        k = c & f,
                        U = c & h;
                    if ((p && (M = E ? p(a, g, E, _) : p(a)), M !== t)) return M;
                    if (!pt(a)) return a;
                    var W = Ne(a);
                    if (W) {
                        if (((M = wM(a)), !A)) return gn(a, M);
                    } else {
                        var G = en(a),
                            te = G == _t || G == Zt;
                        if (oi(a)) return jg(a, A);
                        if (G == Nt || G == Ue || (te && !E)) {
                            if (((M = k || te ? {} : bb(a)), !A)) return k ? uM(a, IT(M, a)) : cM(a, Cg(M, a));
                        } else {
                            if (!it[G]) return E ? a : {};
                            M = xM(a, G, A);
                        }
                    }
                    _ || (_ = new Zn());
                    var de = _.get(a);
                    if (de) return de;
                    _.set(a, M),
                        Gb(a)
                            ? a.forEach(function (we) {
                                  M.add(Dn(we, c, p, we, a, _));
                              })
                            : Kb(a) &&
                              a.forEach(function (we, $e) {
                                  M.set($e, Dn(we, c, p, $e, a, _));
                              });
                    var ve = U ? (k ? xd : wd) : k ? yn : Ht,
                        Pe = W ? t : ve(a);
                    return (
                        Rn(Pe || a, function (we, $e) {
                            Pe && (($e = we), (we = a[$e])), xs(M, $e, Dn(we, c, p, $e, a, _));
                        }),
                        M
                    );
                }
                function LT(a) {
                    var c = Ht(a);
                    return function (p) {
                        return kg(p, a, c);
                    };
                }
                function kg(a, c, p) {
                    var g = p.length;
                    if (a == null) return !g;
                    for (a = nt(a); g--; ) {
                        var E = p[g],
                            _ = c[E],
                            M = a[E];
                        if ((M === t && !(E in a)) || !_(M)) return !1;
                    }
                    return !0;
                }
                function Ng(a, c, p) {
                    if (typeof a != 'function') throw new In(i);
                    return ks(function () {
                        a.apply(t, p);
                    }, c);
                }
                function _s(a, c, p, g) {
                    var E = -1,
                        _ = ka,
                        M = !0,
                        A = a.length,
                        k = [],
                        U = c.length;
                    if (!A) return k;
                    p && (c = ut(c, Tn(p))),
                        g ? ((_ = Uu), (M = !1)) : c.length >= n && ((_ = gs), (M = !1), (c = new Oi(c)));
                    e: for (; ++E < A; ) {
                        var W = a[E],
                            G = p == null ? W : p(W);
                        if (((W = g || W !== 0 ? W : 0), M && G === G)) {
                            for (var te = U; te--; ) if (c[te] === G) continue e;
                            k.push(W);
                        } else _(c, G, g) || k.push(W);
                    }
                    return k;
                }
                var ti = rb(cr),
                    Og = rb(id, !0);
                function DT(a, c) {
                    var p = !0;
                    return (
                        ti(a, function (g, E, _) {
                            return (p = !!c(g, E, _)), p;
                        }),
                        p
                    );
                }
                function qa(a, c, p) {
                    for (var g = -1, E = a.length; ++g < E; ) {
                        var _ = a[g],
                            M = c(_);
                        if (M != null && (A === t ? M === M && !An(M) : p(M, A)))
                            var A = M,
                                k = _;
                    }
                    return k;
                }
                function PT(a, c, p, g) {
                    var E = a.length;
                    for (
                        p = Ie(p),
                            p < 0 && (p = -p > E ? 0 : E + p),
                            g = g === t || g > E ? E : Ie(g),
                            g < 0 && (g += E),
                            g = p > g ? 0 : Yb(g);
                        p < g;

                    )
                        a[p++] = c;
                    return a;
                }
                function Rg(a, c) {
                    var p = [];
                    return (
                        ti(a, function (g, E, _) {
                            c(g, E, _) && p.push(g);
                        }),
                        p
                    );
                }
                function Gt(a, c, p, g, E) {
                    var _ = -1,
                        M = a.length;
                    for (p || (p = SM), E || (E = []); ++_ < M; ) {
                        var A = a[_];
                        c > 0 && p(A) ? (c > 1 ? Gt(A, c - 1, p, g, E) : Zr(E, A)) : g || (E[E.length] = A);
                    }
                    return E;
                }
                var rd = ib(),
                    Ig = ib(!0);
                function cr(a, c) {
                    return a && rd(a, c, Ht);
                }
                function id(a, c) {
                    return a && Ig(a, c, Ht);
                }
                function Ya(a, c) {
                    return Xr(c, function (p) {
                        return kr(a[p]);
                    });
                }
                function Ii(a, c) {
                    c = ri(c, a);
                    for (var p = 0, g = c.length; a != null && p < g; ) a = a[dr(c[p++])];
                    return p && p == g ? a : t;
                }
                function Lg(a, c, p) {
                    var g = c(a);
                    return Ne(a) ? g : Zr(g, p(a));
                }
                function ln(a) {
                    return a == null ? (a === t ? Re : St) : ki && ki in nt(a) ? yM(a) : OM(a);
                }
                function od(a, c) {
                    return a > c;
                }
                function BT(a, c) {
                    return a != null && et.call(a, c);
                }
                function FT(a, c) {
                    return a != null && c in nt(a);
                }
                function HT(a, c, p) {
                    return a >= Qt(c, p) && a < It(c, p);
                }
                function sd(a, c, p) {
                    for (
                        var g = p ? Uu : ka, E = a[0].length, _ = a.length, M = _, A = L(_), k = 1 / 0, U = [];
                        M--;

                    ) {
                        var W = a[M];
                        M && c && (W = ut(W, Tn(c))),
                            (k = Qt(W.length, k)),
                            (A[M] = !p && (c || (E >= 120 && W.length >= 120)) ? new Oi(M && W) : t);
                    }
                    W = a[0];
                    var G = -1,
                        te = A[0];
                    e: for (; ++G < E && U.length < k; ) {
                        var de = W[G],
                            ve = c ? c(de) : de;
                        if (((de = p || de !== 0 ? de : 0), !(te ? gs(te, ve) : g(U, ve, p)))) {
                            for (M = _; --M; ) {
                                var Pe = A[M];
                                if (!(Pe ? gs(Pe, ve) : g(a[M], ve, p))) continue e;
                            }
                            te && te.push(ve), U.push(de);
                        }
                    }
                    return U;
                }
                function zT(a, c, p, g) {
                    return (
                        cr(a, function (E, _, M) {
                            c(g, p(E), _, M);
                        }),
                        g
                    );
                }
                function Ss(a, c, p) {
                    (c = ri(c, a)), (a = wb(a, c));
                    var g = a == null ? a : a[dr(Bn(c))];
                    return g == null ? t : Sn(g, a, p);
                }
                function Dg(a) {
                    return gt(a) && ln(a) == Ue;
                }
                function $T(a) {
                    return gt(a) && ln(a) == J;
                }
                function UT(a) {
                    return gt(a) && ln(a) == xt;
                }
                function Ts(a, c, p, g, E) {
                    return a === c
                        ? !0
                        : a == null || c == null || (!gt(a) && !gt(c))
                          ? a !== a && c !== c
                          : WT(a, c, p, g, Ts, E);
                }
                function WT(a, c, p, g, E, _) {
                    var M = Ne(a),
                        A = Ne(c),
                        k = M ? We : en(a),
                        U = A ? We : en(c);
                    (k = k == Ue ? Nt : k), (U = U == Ue ? Nt : U);
                    var W = k == Nt,
                        G = U == Nt,
                        te = k == U;
                    if (te && oi(a)) {
                        if (!oi(c)) return !1;
                        (M = !0), (W = !1);
                    }
                    if (te && !W)
                        return _ || (_ = new Zn()), M || Oo(a) ? hb(a, c, p, g, E, _) : gM(a, c, k, p, g, E, _);
                    if (!(p & m)) {
                        var de = W && et.call(a, '__wrapped__'),
                            ve = G && et.call(c, '__wrapped__');
                        if (de || ve) {
                            var Pe = de ? a.value() : a,
                                we = ve ? c.value() : c;
                            return _ || (_ = new Zn()), E(Pe, we, p, g, _);
                        }
                    }
                    return te ? (_ || (_ = new Zn()), bM(a, c, p, g, E, _)) : !1;
                }
                function KT(a) {
                    return gt(a) && en(a) == st;
                }
                function ad(a, c, p, g) {
                    var E = p.length,
                        _ = E,
                        M = !g;
                    if (a == null) return !_;
                    for (a = nt(a); E--; ) {
                        var A = p[E];
                        if (M && A[2] ? A[1] !== a[A[0]] : !(A[0] in a)) return !1;
                    }
                    for (; ++E < _; ) {
                        A = p[E];
                        var k = A[0],
                            U = a[k],
                            W = A[1];
                        if (M && A[2]) {
                            if (U === t && !(k in a)) return !1;
                        } else {
                            var G = new Zn();
                            if (g) var te = g(U, W, k, a, c, G);
                            if (!(te === t ? Ts(W, U, m | b, g, G) : te)) return !1;
                        }
                    }
                    return !0;
                }
                function Pg(a) {
                    if (!pt(a) || MM(a)) return !1;
                    var c = kr(a) ? K1 : LS;
                    return c.test(Di(a));
                }
                function VT(a) {
                    return gt(a) && ln(a) == Kt;
                }
                function GT(a) {
                    return gt(a) && en(a) == ee;
                }
                function qT(a) {
                    return gt(a) && dl(a.length) && !!at[ln(a)];
                }
                function Bg(a) {
                    return typeof a == 'function'
                        ? a
                        : a == null
                          ? En
                          : typeof a == 'object'
                            ? Ne(a)
                                ? zg(a[0], a[1])
                                : Hg(a)
                            : oy(a);
                }
                function ld(a) {
                    if (!Cs(a)) return X1(a);
                    var c = [];
                    for (var p in nt(a)) et.call(a, p) && p != 'constructor' && c.push(p);
                    return c;
                }
                function YT(a) {
                    if (!pt(a)) return NM(a);
                    var c = Cs(a),
                        p = [];
                    for (var g in a) (g == 'constructor' && (c || !et.call(a, g))) || p.push(g);
                    return p;
                }
                function cd(a, c) {
                    return a < c;
                }
                function Fg(a, c) {
                    var p = -1,
                        g = bn(a) ? L(a.length) : [];
                    return (
                        ti(a, function (E, _, M) {
                            g[++p] = c(E, _, M);
                        }),
                        g
                    );
                }
                function Hg(a) {
                    var c = Sd(a);
                    return c.length == 1 && c[0][2]
                        ? Eb(c[0][0], c[0][1])
                        : function (p) {
                              return p === a || ad(p, a, c);
                          };
                }
                function zg(a, c) {
                    return Md(a) && yb(c)
                        ? Eb(dr(a), c)
                        : function (p) {
                              var g = Pd(p, a);
                              return g === t && g === c ? Bd(p, a) : Ts(c, g, m | b);
                          };
                }
                function Ja(a, c, p, g, E) {
                    a !== c &&
                        rd(
                            c,
                            function (_, M) {
                                if ((E || (E = new Zn()), pt(_))) JT(a, c, M, p, Ja, g, E);
                                else {
                                    var A = g ? g(Cd(a, M), _, M + '', a, c, E) : t;
                                    A === t && (A = _), td(a, M, A);
                                }
                            },
                            yn,
                        );
                }
                function JT(a, c, p, g, E, _, M) {
                    var A = Cd(a, p),
                        k = Cd(c, p),
                        U = M.get(k);
                    if (U) {
                        td(a, p, U);
                        return;
                    }
                    var W = _ ? _(A, k, p + '', a, c, M) : t,
                        G = W === t;
                    if (G) {
                        var te = Ne(k),
                            de = !te && oi(k),
                            ve = !te && !de && Oo(k);
                        (W = k),
                            te || de || ve
                                ? Ne(A)
                                    ? (W = A)
                                    : Et(A)
                                      ? (W = gn(A))
                                      : de
                                        ? ((G = !1), (W = jg(k, !0)))
                                        : ve
                                          ? ((G = !1), (W = Qg(k, !0)))
                                          : (W = [])
                                : Ns(k) || Pi(k)
                                  ? ((W = A), Pi(A) ? (W = Jb(A)) : (!pt(A) || kr(A)) && (W = bb(k)))
                                  : (G = !1);
                    }
                    G && (M.set(k, W), E(W, k, g, _, M), M.delete(k)), td(a, p, W);
                }
                function $g(a, c) {
                    var p = a.length;
                    if (p) return (c += c < 0 ? p : 0), Cr(c, p) ? a[c] : t;
                }
                function Ug(a, c, p) {
                    c.length
                        ? (c = ut(c, function (_) {
                              return Ne(_)
                                  ? function (M) {
                                        return Ii(M, _.length === 1 ? _[0] : _);
                                    }
                                  : _;
                          }))
                        : (c = [En]);
                    var g = -1;
                    c = ut(c, Tn(ye()));
                    var E = Fg(a, function (_, M, A) {
                        var k = ut(c, function (U) {
                            return U(_);
                        });
                        return { criteria: k, index: ++g, value: _ };
                    });
                    return x1(E, function (_, M) {
                        return lM(_, M, p);
                    });
                }
                function XT(a, c) {
                    return Wg(a, c, function (p, g) {
                        return Bd(a, g);
                    });
                }
                function Wg(a, c, p) {
                    for (var g = -1, E = c.length, _ = {}; ++g < E; ) {
                        var M = c[g],
                            A = Ii(a, M);
                        p(A, M) && Ms(_, ri(M, a), A);
                    }
                    return _;
                }
                function ZT(a) {
                    return function (c) {
                        return Ii(c, a);
                    };
                }
                function ud(a, c, p, g) {
                    var E = g ? w1 : wo,
                        _ = -1,
                        M = c.length,
                        A = a;
                    for (a === c && (c = gn(c)), p && (A = ut(a, Tn(p))); ++_ < M; )
                        for (var k = 0, U = c[_], W = p ? p(U) : U; (k = E(A, W, k, g)) > -1; )
                            A !== a && Ha.call(A, k, 1), Ha.call(a, k, 1);
                    return a;
                }
                function Kg(a, c) {
                    for (var p = a ? c.length : 0, g = p - 1; p--; ) {
                        var E = c[p];
                        if (p == g || E !== _) {
                            var _ = E;
                            Cr(E) ? Ha.call(a, E, 1) : hd(a, E);
                        }
                    }
                    return a;
                }
                function dd(a, c) {
                    return a + Ua(Sg() * (c - a + 1));
                }
                function jT(a, c, p, g) {
                    for (var E = -1, _ = It($a((c - a) / (p || 1)), 0), M = L(_); _--; ) (M[g ? _ : ++E] = a), (a += p);
                    return M;
                }
                function fd(a, c) {
                    var p = '';
                    if (!a || c < 1 || c > P) return p;
                    do c % 2 && (p += a), (c = Ua(c / 2)), c && (a += a);
                    while (c);
                    return p;
                }
                function Fe(a, c) {
                    return kd(vb(a, c, En), a + '');
                }
                function QT(a) {
                    return Ag(Ro(a));
                }
                function eM(a, c) {
                    var p = Ro(a);
                    return ol(p, Ri(c, 0, p.length));
                }
                function Ms(a, c, p, g) {
                    if (!pt(a)) return a;
                    c = ri(c, a);
                    for (var E = -1, _ = c.length, M = _ - 1, A = a; A != null && ++E < _; ) {
                        var k = dr(c[E]),
                            U = p;
                        if (k === '__proto__' || k === 'constructor' || k === 'prototype') return a;
                        if (E != M) {
                            var W = A[k];
                            (U = g ? g(W, k, A) : t), U === t && (U = pt(W) ? W : Cr(c[E + 1]) ? [] : {});
                        }
                        xs(A, k, U), (A = A[k]);
                    }
                    return a;
                }
                var Vg = Wa
                        ? function (a, c) {
                              return Wa.set(a, c), a;
                          }
                        : En,
                    tM = za
                        ? function (a, c) {
                              return za(a, 'toString', {
                                  configurable: !0,
                                  enumerable: !1,
                                  value: Hd(c),
                                  writable: !0,
                              });
                          }
                        : En;
                function nM(a) {
                    return ol(Ro(a));
                }
                function Pn(a, c, p) {
                    var g = -1,
                        E = a.length;
                    c < 0 && (c = -c > E ? 0 : E + c),
                        (p = p > E ? E : p),
                        p < 0 && (p += E),
                        (E = c > p ? 0 : (p - c) >>> 0),
                        (c >>>= 0);
                    for (var _ = L(E); ++g < E; ) _[g] = a[g + c];
                    return _;
                }
                function rM(a, c) {
                    var p;
                    return (
                        ti(a, function (g, E, _) {
                            return (p = c(g, E, _)), !p;
                        }),
                        !!p
                    );
                }
                function Xa(a, c, p) {
                    var g = 0,
                        E = a == null ? g : a.length;
                    if (typeof c == 'number' && c === c && E <= he) {
                        for (; g < E; ) {
                            var _ = (g + E) >>> 1,
                                M = a[_];
                            M !== null && !An(M) && (p ? M <= c : M < c) ? (g = _ + 1) : (E = _);
                        }
                        return E;
                    }
                    return pd(a, c, En, p);
                }
                function pd(a, c, p, g) {
                    var E = 0,
                        _ = a == null ? 0 : a.length;
                    if (_ === 0) return 0;
                    c = p(c);
                    for (var M = c !== c, A = c === null, k = An(c), U = c === t; E < _; ) {
                        var W = Ua((E + _) / 2),
                            G = p(a[W]),
                            te = G !== t,
                            de = G === null,
                            ve = G === G,
                            Pe = An(G);
                        if (M) var we = g || ve;
                        else
                            U
                                ? (we = ve && (g || te))
                                : A
                                  ? (we = ve && te && (g || !de))
                                  : k
                                    ? (we = ve && te && !de && (g || !Pe))
                                    : de || Pe
                                      ? (we = !1)
                                      : (we = g ? G <= c : G < c);
                        we ? (E = W + 1) : (_ = W);
                    }
                    return Qt(_, Q);
                }
                function Gg(a, c) {
                    for (var p = -1, g = a.length, E = 0, _ = []; ++p < g; ) {
                        var M = a[p],
                            A = c ? c(M) : M;
                        if (!p || !jn(A, k)) {
                            var k = A;
                            _[E++] = M === 0 ? 0 : M;
                        }
                    }
                    return _;
                }
                function qg(a) {
                    return typeof a == 'number' ? a : An(a) ? R : +a;
                }
                function Mn(a) {
                    if (typeof a == 'string') return a;
                    if (Ne(a)) return ut(a, Mn) + '';
                    if (An(a)) return Tg ? Tg.call(a) : '';
                    var c = a + '';
                    return c == '0' && 1 / a == -Ee ? '-0' : c;
                }
                function ni(a, c, p) {
                    var g = -1,
                        E = ka,
                        _ = a.length,
                        M = !0,
                        A = [],
                        k = A;
                    if (p) (M = !1), (E = Uu);
                    else if (_ >= n) {
                        var U = c ? null : hM(a);
                        if (U) return Oa(U);
                        (M = !1), (E = gs), (k = new Oi());
                    } else k = c ? [] : A;
                    e: for (; ++g < _; ) {
                        var W = a[g],
                            G = c ? c(W) : W;
                        if (((W = p || W !== 0 ? W : 0), M && G === G)) {
                            for (var te = k.length; te--; ) if (k[te] === G) continue e;
                            c && k.push(G), A.push(W);
                        } else E(k, G, p) || (k !== A && k.push(G), A.push(W));
                    }
                    return A;
                }
                function hd(a, c) {
                    return (c = ri(c, a)), (a = wb(a, c)), a == null || delete a[dr(Bn(c))];
                }
                function Yg(a, c, p, g) {
                    return Ms(a, c, p(Ii(a, c)), g);
                }
                function Za(a, c, p, g) {
                    for (var E = a.length, _ = g ? E : -1; (g ? _-- : ++_ < E) && c(a[_], _, a); );
                    return p ? Pn(a, g ? 0 : _, g ? _ + 1 : E) : Pn(a, g ? _ + 1 : 0, g ? E : _);
                }
                function Jg(a, c) {
                    var p = a;
                    return (
                        p instanceof Ve && (p = p.value()),
                        Wu(
                            c,
                            function (g, E) {
                                return E.func.apply(E.thisArg, Zr([g], E.args));
                            },
                            p,
                        )
                    );
                }
                function md(a, c, p) {
                    var g = a.length;
                    if (g < 2) return g ? ni(a[0]) : [];
                    for (var E = -1, _ = L(g); ++E < g; )
                        for (var M = a[E], A = -1; ++A < g; ) A != E && (_[E] = _s(_[E] || M, a[A], c, p));
                    return ni(Gt(_, 1), c, p);
                }
                function Xg(a, c, p) {
                    for (var g = -1, E = a.length, _ = c.length, M = {}; ++g < E; ) {
                        var A = g < _ ? c[g] : t;
                        p(M, a[g], A);
                    }
                    return M;
                }
                function gd(a) {
                    return Et(a) ? a : [];
                }
                function bd(a) {
                    return typeof a == 'function' ? a : En;
                }
                function ri(a, c) {
                    return Ne(a) ? a : Md(a, c) ? [a] : Tb(Qe(a));
                }
                var iM = Fe;
                function ii(a, c, p) {
                    var g = a.length;
                    return (p = p === t ? g : p), !c && p >= g ? a : Pn(a, c, p);
                }
                var Zg =
                    V1 ||
                    function (a) {
                        return Ft.clearTimeout(a);
                    };
                function jg(a, c) {
                    if (c) return a.slice();
                    var p = a.length,
                        g = Eg ? Eg(p) : new a.constructor(p);
                    return a.copy(g), g;
                }
                function yd(a) {
                    var c = new a.constructor(a.byteLength);
                    return new Ba(c).set(new Ba(a)), c;
                }
                function oM(a, c) {
                    var p = c ? yd(a.buffer) : a.buffer;
                    return new a.constructor(p, a.byteOffset, a.byteLength);
                }
                function sM(a) {
                    var c = new a.constructor(a.source, Dm.exec(a));
                    return (c.lastIndex = a.lastIndex), c;
                }
                function aM(a) {
                    return ws ? nt(ws.call(a)) : {};
                }
                function Qg(a, c) {
                    var p = c ? yd(a.buffer) : a.buffer;
                    return new a.constructor(p, a.byteOffset, a.length);
                }
                function eb(a, c) {
                    if (a !== c) {
                        var p = a !== t,
                            g = a === null,
                            E = a === a,
                            _ = An(a),
                            M = c !== t,
                            A = c === null,
                            k = c === c,
                            U = An(c);
                        if ((!A && !U && !_ && a > c) || (_ && M && k && !A && !U) || (g && M && k) || (!p && k) || !E)
                            return 1;
                        if ((!g && !_ && !U && a < c) || (U && p && E && !g && !_) || (A && p && E) || (!M && E) || !k)
                            return -1;
                    }
                    return 0;
                }
                function lM(a, c, p) {
                    for (var g = -1, E = a.criteria, _ = c.criteria, M = E.length, A = p.length; ++g < M; ) {
                        var k = eb(E[g], _[g]);
                        if (k) {
                            if (g >= A) return k;
                            var U = p[g];
                            return k * (U == 'desc' ? -1 : 1);
                        }
                    }
                    return a.index - c.index;
                }
                function tb(a, c, p, g) {
                    for (
                        var E = -1,
                            _ = a.length,
                            M = p.length,
                            A = -1,
                            k = c.length,
                            U = It(_ - M, 0),
                            W = L(k + U),
                            G = !g;
                        ++A < k;

                    )
                        W[A] = c[A];
                    for (; ++E < M; ) (G || E < _) && (W[p[E]] = a[E]);
                    for (; U--; ) W[A++] = a[E++];
                    return W;
                }
                function nb(a, c, p, g) {
                    for (
                        var E = -1,
                            _ = a.length,
                            M = -1,
                            A = p.length,
                            k = -1,
                            U = c.length,
                            W = It(_ - A, 0),
                            G = L(W + U),
                            te = !g;
                        ++E < W;

                    )
                        G[E] = a[E];
                    for (var de = E; ++k < U; ) G[de + k] = c[k];
                    for (; ++M < A; ) (te || E < _) && (G[de + p[M]] = a[E++]);
                    return G;
                }
                function gn(a, c) {
                    var p = -1,
                        g = a.length;
                    for (c || (c = L(g)); ++p < g; ) c[p] = a[p];
                    return c;
                }
                function ur(a, c, p, g) {
                    var E = !p;
                    p || (p = {});
                    for (var _ = -1, M = c.length; ++_ < M; ) {
                        var A = c[_],
                            k = g ? g(p[A], a[A], A, p, a) : t;
                        k === t && (k = a[A]), E ? Tr(p, A, k) : xs(p, A, k);
                    }
                    return p;
                }
                function cM(a, c) {
                    return ur(a, Td(a), c);
                }
                function uM(a, c) {
                    return ur(a, mb(a), c);
                }
                function ja(a, c) {
                    return function (p, g) {
                        var E = Ne(p) ? m1 : RT,
                            _ = c ? c() : {};
                        return E(p, a, ye(g, 2), _);
                    };
                }
                function Co(a) {
                    return Fe(function (c, p) {
                        var g = -1,
                            E = p.length,
                            _ = E > 1 ? p[E - 1] : t,
                            M = E > 2 ? p[2] : t;
                        for (
                            _ = a.length > 3 && typeof _ == 'function' ? (E--, _) : t,
                                M && cn(p[0], p[1], M) && ((_ = E < 3 ? t : _), (E = 1)),
                                c = nt(c);
                            ++g < E;

                        ) {
                            var A = p[g];
                            A && a(c, A, g, _);
                        }
                        return c;
                    });
                }
                function rb(a, c) {
                    return function (p, g) {
                        if (p == null) return p;
                        if (!bn(p)) return a(p, g);
                        for (
                            var E = p.length, _ = c ? E : -1, M = nt(p);
                            (c ? _-- : ++_ < E) && g(M[_], _, M) !== !1;

                        );
                        return p;
                    };
                }
                function ib(a) {
                    return function (c, p, g) {
                        for (var E = -1, _ = nt(c), M = g(c), A = M.length; A--; ) {
                            var k = M[a ? A : ++E];
                            if (p(_[k], k, _) === !1) break;
                        }
                        return c;
                    };
                }
                function dM(a, c, p) {
                    var g = c & y,
                        E = As(a);
                    function _() {
                        var M = this && this !== Ft && this instanceof _ ? E : a;
                        return M.apply(g ? p : this, arguments);
                    }
                    return _;
                }
                function ob(a) {
                    return function (c) {
                        c = Qe(c);
                        var p = xo(c) ? Xn(c) : t,
                            g = p ? p[0] : c.charAt(0),
                            E = p ? ii(p, 1).join('') : c.slice(1);
                        return g[a]() + E;
                    };
                }
                function ko(a) {
                    return function (c) {
                        return Wu(ry(ny(c).replace(t1, '')), a, '');
                    };
                }
                function As(a) {
                    return function () {
                        var c = arguments;
                        switch (c.length) {
                            case 0:
                                return new a();
                            case 1:
                                return new a(c[0]);
                            case 2:
                                return new a(c[0], c[1]);
                            case 3:
                                return new a(c[0], c[1], c[2]);
                            case 4:
                                return new a(c[0], c[1], c[2], c[3]);
                            case 5:
                                return new a(c[0], c[1], c[2], c[3], c[4]);
                            case 6:
                                return new a(c[0], c[1], c[2], c[3], c[4], c[5]);
                            case 7:
                                return new a(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
                        }
                        var p = Ao(a.prototype),
                            g = a.apply(p, c);
                        return pt(g) ? g : p;
                    };
                }
                function fM(a, c, p) {
                    var g = As(a);
                    function E() {
                        for (var _ = arguments.length, M = L(_), A = _, k = No(E); A--; ) M[A] = arguments[A];
                        var U = _ < 3 && M[0] !== k && M[_ - 1] !== k ? [] : jr(M, k);
                        if (((_ -= U.length), _ < p)) return ub(a, c, Qa, E.placeholder, t, M, U, t, t, p - _);
                        var W = this && this !== Ft && this instanceof E ? g : a;
                        return Sn(W, this, M);
                    }
                    return E;
                }
                function sb(a) {
                    return function (c, p, g) {
                        var E = nt(c);
                        if (!bn(c)) {
                            var _ = ye(p, 3);
                            (c = Ht(c)),
                                (p = function (A) {
                                    return _(E[A], A, E);
                                });
                        }
                        var M = a(c, p, g);
                        return M > -1 ? E[_ ? c[M] : M] : t;
                    };
                }
                function ab(a) {
                    return Ar(function (c) {
                        var p = c.length,
                            g = p,
                            E = Ln.prototype.thru;
                        for (a && c.reverse(); g--; ) {
                            var _ = c[g];
                            if (typeof _ != 'function') throw new In(i);
                            if (E && !M && rl(_) == 'wrapper') var M = new Ln([], !0);
                        }
                        for (g = M ? g : p; ++g < p; ) {
                            _ = c[g];
                            var A = rl(_),
                                k = A == 'wrapper' ? _d(_) : t;
                            k && Ad(k[0]) && k[1] == (z | T | I | N) && !k[4].length && k[9] == 1
                                ? (M = M[rl(k[0])].apply(M, k[3]))
                                : (M = _.length == 1 && Ad(_) ? M[A]() : M.thru(_));
                        }
                        return function () {
                            var U = arguments,
                                W = U[0];
                            if (M && U.length == 1 && Ne(W)) return M.plant(W).value();
                            for (var G = 0, te = p ? c[G].apply(this, U) : W; ++G < p; ) te = c[G].call(this, te);
                            return te;
                        };
                    });
                }
                function Qa(a, c, p, g, E, _, M, A, k, U) {
                    var W = c & z,
                        G = c & y,
                        te = c & v,
                        de = c & (T | D),
                        ve = c & q,
                        Pe = te ? t : As(a);
                    function we() {
                        for (var $e = arguments.length, Ye = L($e), Cn = $e; Cn--; ) Ye[Cn] = arguments[Cn];
                        if (de)
                            var un = No(we),
                                kn = S1(Ye, un);
                        if ((g && (Ye = tb(Ye, g, E, de)), _ && (Ye = nb(Ye, _, M, de)), ($e -= kn), de && $e < U)) {
                            var vt = jr(Ye, un);
                            return ub(a, c, Qa, we.placeholder, p, Ye, vt, A, k, U - $e);
                        }
                        var Qn = G ? p : this,
                            Or = te ? Qn[a] : a;
                        return (
                            ($e = Ye.length),
                            A ? (Ye = RM(Ye, A)) : ve && $e > 1 && Ye.reverse(),
                            W && k < $e && (Ye.length = k),
                            this && this !== Ft && this instanceof we && (Or = Pe || As(Or)),
                            Or.apply(Qn, Ye)
                        );
                    }
                    return we;
                }
                function lb(a, c) {
                    return function (p, g) {
                        return zT(p, a, c(g), {});
                    };
                }
                function el(a, c) {
                    return function (p, g) {
                        var E;
                        if (p === t && g === t) return c;
                        if ((p !== t && (E = p), g !== t)) {
                            if (E === t) return g;
                            typeof p == 'string' || typeof g == 'string'
                                ? ((p = Mn(p)), (g = Mn(g)))
                                : ((p = qg(p)), (g = qg(g))),
                                (E = a(p, g));
                        }
                        return E;
                    };
                }
                function Ed(a) {
                    return Ar(function (c) {
                        return (
                            (c = ut(c, Tn(ye()))),
                            Fe(function (p) {
                                var g = this;
                                return a(c, function (E) {
                                    return Sn(E, g, p);
                                });
                            })
                        );
                    });
                }
                function tl(a, c) {
                    c = c === t ? ' ' : Mn(c);
                    var p = c.length;
                    if (p < 2) return p ? fd(c, a) : c;
                    var g = fd(c, $a(a / _o(c)));
                    return xo(c) ? ii(Xn(g), 0, a).join('') : g.slice(0, a);
                }
                function pM(a, c, p, g) {
                    var E = c & y,
                        _ = As(a);
                    function M() {
                        for (
                            var A = -1,
                                k = arguments.length,
                                U = -1,
                                W = g.length,
                                G = L(W + k),
                                te = this && this !== Ft && this instanceof M ? _ : a;
                            ++U < W;

                        )
                            G[U] = g[U];
                        for (; k--; ) G[U++] = arguments[++A];
                        return Sn(te, E ? p : this, G);
                    }
                    return M;
                }
                function cb(a) {
                    return function (c, p, g) {
                        return (
                            g && typeof g != 'number' && cn(c, p, g) && (p = g = t),
                            (c = Nr(c)),
                            p === t ? ((p = c), (c = 0)) : (p = Nr(p)),
                            (g = g === t ? (c < p ? 1 : -1) : Nr(g)),
                            jT(c, p, g, a)
                        );
                    };
                }
                function nl(a) {
                    return function (c, p) {
                        return (typeof c == 'string' && typeof p == 'string') || ((c = Fn(c)), (p = Fn(p))), a(c, p);
                    };
                }
                function ub(a, c, p, g, E, _, M, A, k, U) {
                    var W = c & T,
                        G = W ? M : t,
                        te = W ? t : M,
                        de = W ? _ : t,
                        ve = W ? t : _;
                    (c |= W ? I : S), (c &= ~(W ? S : I)), c & x || (c &= ~(y | v));
                    var Pe = [a, c, E, de, G, ve, te, A, k, U],
                        we = p.apply(t, Pe);
                    return Ad(a) && xb(we, Pe), (we.placeholder = g), _b(we, a, c);
                }
                function vd(a) {
                    var c = Rt[a];
                    return function (p, g) {
                        if (((p = Fn(p)), (g = g == null ? 0 : Qt(Ie(g), 292)), g && _g(p))) {
                            var E = (Qe(p) + 'e').split('e'),
                                _ = c(E[0] + 'e' + (+E[1] + g));
                            return (E = (Qe(_) + 'e').split('e')), +(E[0] + 'e' + (+E[1] - g));
                        }
                        return c(p);
                    };
                }
                var hM =
                    To && 1 / Oa(new To([, -0]))[1] == Ee
                        ? function (a) {
                              return new To(a);
                          }
                        : Ud;
                function db(a) {
                    return function (c) {
                        var p = en(c);
                        return p == st ? Xu(c) : p == ee ? O1(c) : _1(c, a(c));
                    };
                }
                function Mr(a, c, p, g, E, _, M, A) {
                    var k = c & v;
                    if (!k && typeof a != 'function') throw new In(i);
                    var U = g ? g.length : 0;
                    if (
                        (U || ((c &= ~(I | S)), (g = E = t)),
                        (M = M === t ? M : It(Ie(M), 0)),
                        (A = A === t ? A : Ie(A)),
                        (U -= E ? E.length : 0),
                        c & S)
                    ) {
                        var W = g,
                            G = E;
                        g = E = t;
                    }
                    var te = k ? t : _d(a),
                        de = [a, c, p, g, E, W, G, _, M, A];
                    if (
                        (te && kM(de, te),
                        (a = de[0]),
                        (c = de[1]),
                        (p = de[2]),
                        (g = de[3]),
                        (E = de[4]),
                        (A = de[9] = de[9] === t ? (k ? 0 : a.length) : It(de[9] - U, 0)),
                        !A && c & (T | D) && (c &= ~(T | D)),
                        !c || c == y)
                    )
                        var ve = dM(a, c, p);
                    else
                        c == T || c == D
                            ? (ve = fM(a, c, A))
                            : (c == I || c == (y | I)) && !E.length
                              ? (ve = pM(a, c, p, g))
                              : (ve = Qa.apply(t, de));
                    var Pe = te ? Vg : xb;
                    return _b(Pe(ve, de), a, c);
                }
                function fb(a, c, p, g) {
                    return a === t || (jn(a, So[p]) && !et.call(g, p)) ? c : a;
                }
                function pb(a, c, p, g, E, _) {
                    return pt(a) && pt(c) && (_.set(c, a), Ja(a, c, t, pb, _), _.delete(c)), a;
                }
                function mM(a) {
                    return Ns(a) ? t : a;
                }
                function hb(a, c, p, g, E, _) {
                    var M = p & m,
                        A = a.length,
                        k = c.length;
                    if (A != k && !(M && k > A)) return !1;
                    var U = _.get(a),
                        W = _.get(c);
                    if (U && W) return U == c && W == a;
                    var G = -1,
                        te = !0,
                        de = p & b ? new Oi() : t;
                    for (_.set(a, c), _.set(c, a); ++G < A; ) {
                        var ve = a[G],
                            Pe = c[G];
                        if (g) var we = M ? g(Pe, ve, G, c, a, _) : g(ve, Pe, G, a, c, _);
                        if (we !== t) {
                            if (we) continue;
                            te = !1;
                            break;
                        }
                        if (de) {
                            if (
                                !Ku(c, function ($e, Ye) {
                                    if (!gs(de, Ye) && (ve === $e || E(ve, $e, p, g, _))) return de.push(Ye);
                                })
                            ) {
                                te = !1;
                                break;
                            }
                        } else if (!(ve === Pe || E(ve, Pe, p, g, _))) {
                            te = !1;
                            break;
                        }
                    }
                    return _.delete(a), _.delete(c), te;
                }
                function gM(a, c, p, g, E, _, M) {
                    switch (p) {
                        case re:
                            if (a.byteLength != c.byteLength || a.byteOffset != c.byteOffset) return !1;
                            (a = a.buffer), (c = c.buffer);
                        case J:
                            return !(a.byteLength != c.byteLength || !_(new Ba(a), new Ba(c)));
                        case Xe:
                        case xt:
                        case jt:
                            return jn(+a, +c);
                        case De:
                            return a.name == c.name && a.message == c.message;
                        case Kt:
                        case Ce:
                            return a == c + '';
                        case st:
                            var A = Xu;
                        case ee:
                            var k = g & m;
                            if ((A || (A = Oa), a.size != c.size && !k)) return !1;
                            var U = M.get(a);
                            if (U) return U == c;
                            (g |= b), M.set(a, c);
                            var W = hb(A(a), A(c), g, E, _, M);
                            return M.delete(a), W;
                        case Ke:
                            if (ws) return ws.call(a) == ws.call(c);
                    }
                    return !1;
                }
                function bM(a, c, p, g, E, _) {
                    var M = p & m,
                        A = wd(a),
                        k = A.length,
                        U = wd(c),
                        W = U.length;
                    if (k != W && !M) return !1;
                    for (var G = k; G--; ) {
                        var te = A[G];
                        if (!(M ? te in c : et.call(c, te))) return !1;
                    }
                    var de = _.get(a),
                        ve = _.get(c);
                    if (de && ve) return de == c && ve == a;
                    var Pe = !0;
                    _.set(a, c), _.set(c, a);
                    for (var we = M; ++G < k; ) {
                        te = A[G];
                        var $e = a[te],
                            Ye = c[te];
                        if (g) var Cn = M ? g(Ye, $e, te, c, a, _) : g($e, Ye, te, a, c, _);
                        if (!(Cn === t ? $e === Ye || E($e, Ye, p, g, _) : Cn)) {
                            Pe = !1;
                            break;
                        }
                        we || (we = te == 'constructor');
                    }
                    if (Pe && !we) {
                        var un = a.constructor,
                            kn = c.constructor;
                        un != kn &&
                            'constructor' in a &&
                            'constructor' in c &&
                            !(
                                typeof un == 'function' &&
                                un instanceof un &&
                                typeof kn == 'function' &&
                                kn instanceof kn
                            ) &&
                            (Pe = !1);
                    }
                    return _.delete(a), _.delete(c), Pe;
                }
                function Ar(a) {
                    return kd(vb(a, t, kb), a + '');
                }
                function wd(a) {
                    return Lg(a, Ht, Td);
                }
                function xd(a) {
                    return Lg(a, yn, mb);
                }
                var _d = Wa
                    ? function (a) {
                          return Wa.get(a);
                      }
                    : Ud;
                function rl(a) {
                    for (var c = a.name + '', p = Mo[c], g = et.call(Mo, c) ? p.length : 0; g--; ) {
                        var E = p[g],
                            _ = E.func;
                        if (_ == null || _ == a) return E.name;
                    }
                    return c;
                }
                function No(a) {
                    var c = et.call(w, 'placeholder') ? w : a;
                    return c.placeholder;
                }
                function ye() {
                    var a = w.iteratee || zd;
                    return (a = a === zd ? Bg : a), arguments.length ? a(arguments[0], arguments[1]) : a;
                }
                function il(a, c) {
                    var p = a.__data__;
                    return TM(c) ? p[typeof c == 'string' ? 'string' : 'hash'] : p.map;
                }
                function Sd(a) {
                    for (var c = Ht(a), p = c.length; p--; ) {
                        var g = c[p],
                            E = a[g];
                        c[p] = [g, E, yb(E)];
                    }
                    return c;
                }
                function Li(a, c) {
                    var p = C1(a, c);
                    return Pg(p) ? p : t;
                }
                function yM(a) {
                    var c = et.call(a, ki),
                        p = a[ki];
                    try {
                        a[ki] = t;
                        var g = !0;
                    } catch {}
                    var E = Da.call(a);
                    return g && (c ? (a[ki] = p) : delete a[ki]), E;
                }
                var Td = ju
                        ? function (a) {
                              return a == null
                                  ? []
                                  : ((a = nt(a)),
                                    Xr(ju(a), function (c) {
                                        return wg.call(a, c);
                                    }));
                          }
                        : Wd,
                    mb = ju
                        ? function (a) {
                              for (var c = []; a; ) Zr(c, Td(a)), (a = Fa(a));
                              return c;
                          }
                        : Wd,
                    en = ln;
                ((Qu && en(new Qu(new ArrayBuffer(1))) != re) ||
                    (ys && en(new ys()) != st) ||
                    (ed && en(ed.resolve()) != ft) ||
                    (To && en(new To()) != ee) ||
                    (Es && en(new Es()) != mt)) &&
                    (en = function (a) {
                        var c = ln(a),
                            p = c == Nt ? a.constructor : t,
                            g = p ? Di(p) : '';
                        if (g)
                            switch (g) {
                                case eT:
                                    return re;
                                case tT:
                                    return st;
                                case nT:
                                    return ft;
                                case rT:
                                    return ee;
                                case iT:
                                    return mt;
                            }
                        return c;
                    });
                function EM(a, c, p) {
                    for (var g = -1, E = p.length; ++g < E; ) {
                        var _ = p[g],
                            M = _.size;
                        switch (_.type) {
                            case 'drop':
                                a += M;
                                break;
                            case 'dropRight':
                                c -= M;
                                break;
                            case 'take':
                                c = Qt(c, a + M);
                                break;
                            case 'takeRight':
                                a = It(a, c - M);
                                break;
                        }
                    }
                    return { start: a, end: c };
                }
                function vM(a) {
                    var c = a.match(MS);
                    return c ? c[1].split(AS) : [];
                }
                function gb(a, c, p) {
                    c = ri(c, a);
                    for (var g = -1, E = c.length, _ = !1; ++g < E; ) {
                        var M = dr(c[g]);
                        if (!(_ = a != null && p(a, M))) break;
                        a = a[M];
                    }
                    return _ || ++g != E
                        ? _
                        : ((E = a == null ? 0 : a.length), !!E && dl(E) && Cr(M, E) && (Ne(a) || Pi(a)));
                }
                function wM(a) {
                    var c = a.length,
                        p = new a.constructor(c);
                    return (
                        c &&
                            typeof a[0] == 'string' &&
                            et.call(a, 'index') &&
                            ((p.index = a.index), (p.input = a.input)),
                        p
                    );
                }
                function bb(a) {
                    return typeof a.constructor == 'function' && !Cs(a) ? Ao(Fa(a)) : {};
                }
                function xM(a, c, p) {
                    var g = a.constructor;
                    switch (c) {
                        case J:
                            return yd(a);
                        case Xe:
                        case xt:
                            return new g(+a);
                        case re:
                            return oM(a, p);
                        case H:
                        case Y:
                        case ue:
                        case Ae:
                        case ct:
                        case Vt:
                        case Mi:
                        case B:
                        case le:
                            return Qg(a, p);
                        case st:
                            return new g();
                        case jt:
                        case Ce:
                            return new g(a);
                        case Kt:
                            return sM(a);
                        case ee:
                            return new g();
                        case Ke:
                            return aM(a);
                    }
                }
                function _M(a, c) {
                    var p = c.length;
                    if (!p) return a;
                    var g = p - 1;
                    return (
                        (c[g] = (p > 1 ? '& ' : '') + c[g]),
                        (c = c.join(p > 2 ? ', ' : ' ')),
                        a.replace(
                            TS,
                            `{
/* [wrapped with ` +
                                c +
                                `] */
`,
                        )
                    );
                }
                function SM(a) {
                    return Ne(a) || Pi(a) || !!(xg && a && a[xg]);
                }
                function Cr(a, c) {
                    var p = typeof a;
                    return (
                        (c = c ?? P),
                        !!c && (p == 'number' || (p != 'symbol' && PS.test(a))) && a > -1 && a % 1 == 0 && a < c
                    );
                }
                function cn(a, c, p) {
                    if (!pt(p)) return !1;
                    var g = typeof c;
                    return (g == 'number' ? bn(p) && Cr(c, p.length) : g == 'string' && c in p) ? jn(p[c], a) : !1;
                }
                function Md(a, c) {
                    if (Ne(a)) return !1;
                    var p = typeof a;
                    return p == 'number' || p == 'symbol' || p == 'boolean' || a == null || An(a)
                        ? !0
                        : Iu.test(a) || !Yr.test(a) || (c != null && a in nt(c));
                }
                function TM(a) {
                    var c = typeof a;
                    return c == 'string' || c == 'number' || c == 'symbol' || c == 'boolean'
                        ? a !== '__proto__'
                        : a === null;
                }
                function Ad(a) {
                    var c = rl(a),
                        p = w[c];
                    if (typeof p != 'function' || !(c in Ve.prototype)) return !1;
                    if (a === p) return !0;
                    var g = _d(p);
                    return !!g && a === g[0];
                }
                function MM(a) {
                    return !!yg && yg in a;
                }
                var AM = Ia ? kr : Kd;
                function Cs(a) {
                    var c = a && a.constructor,
                        p = (typeof c == 'function' && c.prototype) || So;
                    return a === p;
                }
                function yb(a) {
                    return a === a && !pt(a);
                }
                function Eb(a, c) {
                    return function (p) {
                        return p == null ? !1 : p[a] === c && (c !== t || a in nt(p));
                    };
                }
                function CM(a) {
                    var c = cl(a, function (g) {
                            return p.size === l && p.clear(), g;
                        }),
                        p = c.cache;
                    return c;
                }
                function kM(a, c) {
                    var p = a[1],
                        g = c[1],
                        E = p | g,
                        _ = E < (y | v | z),
                        M =
                            (g == z && p == T) ||
                            (g == z && p == N && a[7].length <= c[8]) ||
                            (g == (z | N) && c[7].length <= c[8] && p == T);
                    if (!(_ || M)) return a;
                    g & y && ((a[2] = c[2]), (E |= p & y ? 0 : x));
                    var A = c[3];
                    if (A) {
                        var k = a[3];
                        (a[3] = k ? tb(k, A, c[4]) : A), (a[4] = k ? jr(a[3], u) : c[4]);
                    }
                    return (
                        (A = c[5]),
                        A && ((k = a[5]), (a[5] = k ? nb(k, A, c[6]) : A), (a[6] = k ? jr(a[5], u) : c[6])),
                        (A = c[7]),
                        A && (a[7] = A),
                        g & z && (a[8] = a[8] == null ? c[8] : Qt(a[8], c[8])),
                        a[9] == null && (a[9] = c[9]),
                        (a[0] = c[0]),
                        (a[1] = E),
                        a
                    );
                }
                function NM(a) {
                    var c = [];
                    if (a != null) for (var p in nt(a)) c.push(p);
                    return c;
                }
                function OM(a) {
                    return Da.call(a);
                }
                function vb(a, c, p) {
                    return (
                        (c = It(c === t ? a.length - 1 : c, 0)),
                        function () {
                            for (var g = arguments, E = -1, _ = It(g.length - c, 0), M = L(_); ++E < _; )
                                M[E] = g[c + E];
                            E = -1;
                            for (var A = L(c + 1); ++E < c; ) A[E] = g[E];
                            return (A[c] = p(M)), Sn(a, this, A);
                        }
                    );
                }
                function wb(a, c) {
                    return c.length < 2 ? a : Ii(a, Pn(c, 0, -1));
                }
                function RM(a, c) {
                    for (var p = a.length, g = Qt(c.length, p), E = gn(a); g--; ) {
                        var _ = c[g];
                        a[g] = Cr(_, p) ? E[_] : t;
                    }
                    return a;
                }
                function Cd(a, c) {
                    if (!(c === 'constructor' && typeof a[c] == 'function') && c != '__proto__') return a[c];
                }
                var xb = Sb(Vg),
                    ks =
                        q1 ||
                        function (a, c) {
                            return Ft.setTimeout(a, c);
                        },
                    kd = Sb(tM);
                function _b(a, c, p) {
                    var g = c + '';
                    return kd(a, _M(g, IM(vM(g), p)));
                }
                function Sb(a) {
                    var c = 0,
                        p = 0;
                    return function () {
                        var g = Z1(),
                            E = me - (g - p);
                        if (((p = g), E > 0)) {
                            if (++c >= oe) return arguments[0];
                        } else c = 0;
                        return a.apply(t, arguments);
                    };
                }
                function ol(a, c) {
                    var p = -1,
                        g = a.length,
                        E = g - 1;
                    for (c = c === t ? g : c; ++p < c; ) {
                        var _ = dd(p, E),
                            M = a[_];
                        (a[_] = a[p]), (a[p] = M);
                    }
                    return (a.length = c), a;
                }
                var Tb = CM(function (a) {
                    var c = [];
                    return (
                        a.charCodeAt(0) === 46 && c.push(''),
                        a.replace(ms, function (p, g, E, _) {
                            c.push(E ? _.replace(NS, '$1') : g || p);
                        }),
                        c
                    );
                });
                function dr(a) {
                    if (typeof a == 'string' || An(a)) return a;
                    var c = a + '';
                    return c == '0' && 1 / a == -Ee ? '-0' : c;
                }
                function Di(a) {
                    if (a != null) {
                        try {
                            return La.call(a);
                        } catch {}
                        try {
                            return a + '';
                        } catch {}
                    }
                    return '';
                }
                function IM(a, c) {
                    return (
                        Rn(xe, function (p) {
                            var g = '_.' + p[0];
                            c & p[1] && !ka(a, g) && a.push(g);
                        }),
                        a.sort()
                    );
                }
                function Mb(a) {
                    if (a instanceof Ve) return a.clone();
                    var c = new Ln(a.__wrapped__, a.__chain__);
                    return (
                        (c.__actions__ = gn(a.__actions__)),
                        (c.__index__ = a.__index__),
                        (c.__values__ = a.__values__),
                        c
                    );
                }
                function LM(a, c, p) {
                    (p ? cn(a, c, p) : c === t) ? (c = 1) : (c = It(Ie(c), 0));
                    var g = a == null ? 0 : a.length;
                    if (!g || c < 1) return [];
                    for (var E = 0, _ = 0, M = L($a(g / c)); E < g; ) M[_++] = Pn(a, E, (E += c));
                    return M;
                }
                function DM(a) {
                    for (var c = -1, p = a == null ? 0 : a.length, g = 0, E = []; ++c < p; ) {
                        var _ = a[c];
                        _ && (E[g++] = _);
                    }
                    return E;
                }
                function PM() {
                    var a = arguments.length;
                    if (!a) return [];
                    for (var c = L(a - 1), p = arguments[0], g = a; g--; ) c[g - 1] = arguments[g];
                    return Zr(Ne(p) ? gn(p) : [p], Gt(c, 1));
                }
                var BM = Fe(function (a, c) {
                        return Et(a) ? _s(a, Gt(c, 1, Et, !0)) : [];
                    }),
                    FM = Fe(function (a, c) {
                        var p = Bn(c);
                        return Et(p) && (p = t), Et(a) ? _s(a, Gt(c, 1, Et, !0), ye(p, 2)) : [];
                    }),
                    HM = Fe(function (a, c) {
                        var p = Bn(c);
                        return Et(p) && (p = t), Et(a) ? _s(a, Gt(c, 1, Et, !0), t, p) : [];
                    });
                function zM(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    return g ? ((c = p || c === t ? 1 : Ie(c)), Pn(a, c < 0 ? 0 : c, g)) : [];
                }
                function $M(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    return g ? ((c = p || c === t ? 1 : Ie(c)), (c = g - c), Pn(a, 0, c < 0 ? 0 : c)) : [];
                }
                function UM(a, c) {
                    return a && a.length ? Za(a, ye(c, 3), !0, !0) : [];
                }
                function WM(a, c) {
                    return a && a.length ? Za(a, ye(c, 3), !0) : [];
                }
                function KM(a, c, p, g) {
                    var E = a == null ? 0 : a.length;
                    return E ? (p && typeof p != 'number' && cn(a, c, p) && ((p = 0), (g = E)), PT(a, c, p, g)) : [];
                }
                function Ab(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    if (!g) return -1;
                    var E = p == null ? 0 : Ie(p);
                    return E < 0 && (E = It(g + E, 0)), Na(a, ye(c, 3), E);
                }
                function Cb(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    if (!g) return -1;
                    var E = g - 1;
                    return p !== t && ((E = Ie(p)), (E = p < 0 ? It(g + E, 0) : Qt(E, g - 1))), Na(a, ye(c, 3), E, !0);
                }
                function kb(a) {
                    var c = a == null ? 0 : a.length;
                    return c ? Gt(a, 1) : [];
                }
                function VM(a) {
                    var c = a == null ? 0 : a.length;
                    return c ? Gt(a, Ee) : [];
                }
                function GM(a, c) {
                    var p = a == null ? 0 : a.length;
                    return p ? ((c = c === t ? 1 : Ie(c)), Gt(a, c)) : [];
                }
                function qM(a) {
                    for (var c = -1, p = a == null ? 0 : a.length, g = {}; ++c < p; ) {
                        var E = a[c];
                        g[E[0]] = E[1];
                    }
                    return g;
                }
                function Nb(a) {
                    return a && a.length ? a[0] : t;
                }
                function YM(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    if (!g) return -1;
                    var E = p == null ? 0 : Ie(p);
                    return E < 0 && (E = It(g + E, 0)), wo(a, c, E);
                }
                function JM(a) {
                    var c = a == null ? 0 : a.length;
                    return c ? Pn(a, 0, -1) : [];
                }
                var XM = Fe(function (a) {
                        var c = ut(a, gd);
                        return c.length && c[0] === a[0] ? sd(c) : [];
                    }),
                    ZM = Fe(function (a) {
                        var c = Bn(a),
                            p = ut(a, gd);
                        return c === Bn(p) ? (c = t) : p.pop(), p.length && p[0] === a[0] ? sd(p, ye(c, 2)) : [];
                    }),
                    jM = Fe(function (a) {
                        var c = Bn(a),
                            p = ut(a, gd);
                        return (
                            (c = typeof c == 'function' ? c : t),
                            c && p.pop(),
                            p.length && p[0] === a[0] ? sd(p, t, c) : []
                        );
                    });
                function QM(a, c) {
                    return a == null ? '' : J1.call(a, c);
                }
                function Bn(a) {
                    var c = a == null ? 0 : a.length;
                    return c ? a[c - 1] : t;
                }
                function eA(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    if (!g) return -1;
                    var E = g;
                    return (
                        p !== t && ((E = Ie(p)), (E = E < 0 ? It(g + E, 0) : Qt(E, g - 1))),
                        c === c ? I1(a, c, E) : Na(a, ug, E, !0)
                    );
                }
                function tA(a, c) {
                    return a && a.length ? $g(a, Ie(c)) : t;
                }
                var nA = Fe(Ob);
                function Ob(a, c) {
                    return a && a.length && c && c.length ? ud(a, c) : a;
                }
                function rA(a, c, p) {
                    return a && a.length && c && c.length ? ud(a, c, ye(p, 2)) : a;
                }
                function iA(a, c, p) {
                    return a && a.length && c && c.length ? ud(a, c, t, p) : a;
                }
                var oA = Ar(function (a, c) {
                    var p = a == null ? 0 : a.length,
                        g = nd(a, c);
                    return (
                        Kg(
                            a,
                            ut(c, function (E) {
                                return Cr(E, p) ? +E : E;
                            }).sort(eb),
                        ),
                        g
                    );
                });
                function sA(a, c) {
                    var p = [];
                    if (!(a && a.length)) return p;
                    var g = -1,
                        E = [],
                        _ = a.length;
                    for (c = ye(c, 3); ++g < _; ) {
                        var M = a[g];
                        c(M, g, a) && (p.push(M), E.push(g));
                    }
                    return Kg(a, E), p;
                }
                function Nd(a) {
                    return a == null ? a : Q1.call(a);
                }
                function aA(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    return g
                        ? (p && typeof p != 'number' && cn(a, c, p)
                              ? ((c = 0), (p = g))
                              : ((c = c == null ? 0 : Ie(c)), (p = p === t ? g : Ie(p))),
                          Pn(a, c, p))
                        : [];
                }
                function lA(a, c) {
                    return Xa(a, c);
                }
                function cA(a, c, p) {
                    return pd(a, c, ye(p, 2));
                }
                function uA(a, c) {
                    var p = a == null ? 0 : a.length;
                    if (p) {
                        var g = Xa(a, c);
                        if (g < p && jn(a[g], c)) return g;
                    }
                    return -1;
                }
                function dA(a, c) {
                    return Xa(a, c, !0);
                }
                function fA(a, c, p) {
                    return pd(a, c, ye(p, 2), !0);
                }
                function pA(a, c) {
                    var p = a == null ? 0 : a.length;
                    if (p) {
                        var g = Xa(a, c, !0) - 1;
                        if (jn(a[g], c)) return g;
                    }
                    return -1;
                }
                function hA(a) {
                    return a && a.length ? Gg(a) : [];
                }
                function mA(a, c) {
                    return a && a.length ? Gg(a, ye(c, 2)) : [];
                }
                function gA(a) {
                    var c = a == null ? 0 : a.length;
                    return c ? Pn(a, 1, c) : [];
                }
                function bA(a, c, p) {
                    return a && a.length ? ((c = p || c === t ? 1 : Ie(c)), Pn(a, 0, c < 0 ? 0 : c)) : [];
                }
                function yA(a, c, p) {
                    var g = a == null ? 0 : a.length;
                    return g ? ((c = p || c === t ? 1 : Ie(c)), (c = g - c), Pn(a, c < 0 ? 0 : c, g)) : [];
                }
                function EA(a, c) {
                    return a && a.length ? Za(a, ye(c, 3), !1, !0) : [];
                }
                function vA(a, c) {
                    return a && a.length ? Za(a, ye(c, 3)) : [];
                }
                var wA = Fe(function (a) {
                        return ni(Gt(a, 1, Et, !0));
                    }),
                    xA = Fe(function (a) {
                        var c = Bn(a);
                        return Et(c) && (c = t), ni(Gt(a, 1, Et, !0), ye(c, 2));
                    }),
                    _A = Fe(function (a) {
                        var c = Bn(a);
                        return (c = typeof c == 'function' ? c : t), ni(Gt(a, 1, Et, !0), t, c);
                    });
                function SA(a) {
                    return a && a.length ? ni(a) : [];
                }
                function TA(a, c) {
                    return a && a.length ? ni(a, ye(c, 2)) : [];
                }
                function MA(a, c) {
                    return (c = typeof c == 'function' ? c : t), a && a.length ? ni(a, t, c) : [];
                }
                function Od(a) {
                    if (!(a && a.length)) return [];
                    var c = 0;
                    return (
                        (a = Xr(a, function (p) {
                            if (Et(p)) return (c = It(p.length, c)), !0;
                        })),
                        Yu(c, function (p) {
                            return ut(a, Vu(p));
                        })
                    );
                }
                function Rb(a, c) {
                    if (!(a && a.length)) return [];
                    var p = Od(a);
                    return c == null
                        ? p
                        : ut(p, function (g) {
                              return Sn(c, t, g);
                          });
                }
                var AA = Fe(function (a, c) {
                        return Et(a) ? _s(a, c) : [];
                    }),
                    CA = Fe(function (a) {
                        return md(Xr(a, Et));
                    }),
                    kA = Fe(function (a) {
                        var c = Bn(a);
                        return Et(c) && (c = t), md(Xr(a, Et), ye(c, 2));
                    }),
                    NA = Fe(function (a) {
                        var c = Bn(a);
                        return (c = typeof c == 'function' ? c : t), md(Xr(a, Et), t, c);
                    }),
                    OA = Fe(Od);
                function RA(a, c) {
                    return Xg(a || [], c || [], xs);
                }
                function IA(a, c) {
                    return Xg(a || [], c || [], Ms);
                }
                var LA = Fe(function (a) {
                    var c = a.length,
                        p = c > 1 ? a[c - 1] : t;
                    return (p = typeof p == 'function' ? (a.pop(), p) : t), Rb(a, p);
                });
                function Ib(a) {
                    var c = w(a);
                    return (c.__chain__ = !0), c;
                }
                function DA(a, c) {
                    return c(a), a;
                }
                function sl(a, c) {
                    return c(a);
                }
                var PA = Ar(function (a) {
                    var c = a.length,
                        p = c ? a[0] : 0,
                        g = this.__wrapped__,
                        E = function (_) {
                            return nd(_, a);
                        };
                    return c > 1 || this.__actions__.length || !(g instanceof Ve) || !Cr(p)
                        ? this.thru(E)
                        : ((g = g.slice(p, +p + (c ? 1 : 0))),
                          g.__actions__.push({ func: sl, args: [E], thisArg: t }),
                          new Ln(g, this.__chain__).thru(function (_) {
                              return c && !_.length && _.push(t), _;
                          }));
                });
                function BA() {
                    return Ib(this);
                }
                function FA() {
                    return new Ln(this.value(), this.__chain__);
                }
                function HA() {
                    this.__values__ === t && (this.__values__ = qb(this.value()));
                    var a = this.__index__ >= this.__values__.length,
                        c = a ? t : this.__values__[this.__index__++];
                    return { done: a, value: c };
                }
                function zA() {
                    return this;
                }
                function $A(a) {
                    for (var c, p = this; p instanceof Va; ) {
                        var g = Mb(p);
                        (g.__index__ = 0), (g.__values__ = t), c ? (E.__wrapped__ = g) : (c = g);
                        var E = g;
                        p = p.__wrapped__;
                    }
                    return (E.__wrapped__ = a), c;
                }
                function UA() {
                    var a = this.__wrapped__;
                    if (a instanceof Ve) {
                        var c = a;
                        return (
                            this.__actions__.length && (c = new Ve(this)),
                            (c = c.reverse()),
                            c.__actions__.push({ func: sl, args: [Nd], thisArg: t }),
                            new Ln(c, this.__chain__)
                        );
                    }
                    return this.thru(Nd);
                }
                function WA() {
                    return Jg(this.__wrapped__, this.__actions__);
                }
                var KA = ja(function (a, c, p) {
                    et.call(a, p) ? ++a[p] : Tr(a, p, 1);
                });
                function VA(a, c, p) {
                    var g = Ne(a) ? lg : DT;
                    return p && cn(a, c, p) && (c = t), g(a, ye(c, 3));
                }
                function GA(a, c) {
                    var p = Ne(a) ? Xr : Rg;
                    return p(a, ye(c, 3));
                }
                var qA = sb(Ab),
                    YA = sb(Cb);
                function JA(a, c) {
                    return Gt(al(a, c), 1);
                }
                function XA(a, c) {
                    return Gt(al(a, c), Ee);
                }
                function ZA(a, c, p) {
                    return (p = p === t ? 1 : Ie(p)), Gt(al(a, c), p);
                }
                function Lb(a, c) {
                    var p = Ne(a) ? Rn : ti;
                    return p(a, ye(c, 3));
                }
                function Db(a, c) {
                    var p = Ne(a) ? g1 : Og;
                    return p(a, ye(c, 3));
                }
                var jA = ja(function (a, c, p) {
                    et.call(a, p) ? a[p].push(c) : Tr(a, p, [c]);
                });
                function QA(a, c, p, g) {
                    (a = bn(a) ? a : Ro(a)), (p = p && !g ? Ie(p) : 0);
                    var E = a.length;
                    return (
                        p < 0 && (p = It(E + p, 0)), fl(a) ? p <= E && a.indexOf(c, p) > -1 : !!E && wo(a, c, p) > -1
                    );
                }
                var eC = Fe(function (a, c, p) {
                        var g = -1,
                            E = typeof c == 'function',
                            _ = bn(a) ? L(a.length) : [];
                        return (
                            ti(a, function (M) {
                                _[++g] = E ? Sn(c, M, p) : Ss(M, c, p);
                            }),
                            _
                        );
                    }),
                    tC = ja(function (a, c, p) {
                        Tr(a, p, c);
                    });
                function al(a, c) {
                    var p = Ne(a) ? ut : Fg;
                    return p(a, ye(c, 3));
                }
                function nC(a, c, p, g) {
                    return a == null
                        ? []
                        : (Ne(c) || (c = c == null ? [] : [c]),
                          (p = g ? t : p),
                          Ne(p) || (p = p == null ? [] : [p]),
                          Ug(a, c, p));
                }
                var rC = ja(
                    function (a, c, p) {
                        a[p ? 0 : 1].push(c);
                    },
                    function () {
                        return [[], []];
                    },
                );
                function iC(a, c, p) {
                    var g = Ne(a) ? Wu : fg,
                        E = arguments.length < 3;
                    return g(a, ye(c, 4), p, E, ti);
                }
                function oC(a, c, p) {
                    var g = Ne(a) ? b1 : fg,
                        E = arguments.length < 3;
                    return g(a, ye(c, 4), p, E, Og);
                }
                function sC(a, c) {
                    var p = Ne(a) ? Xr : Rg;
                    return p(a, ul(ye(c, 3)));
                }
                function aC(a) {
                    var c = Ne(a) ? Ag : QT;
                    return c(a);
                }
                function lC(a, c, p) {
                    (p ? cn(a, c, p) : c === t) ? (c = 1) : (c = Ie(c));
                    var g = Ne(a) ? NT : eM;
                    return g(a, c);
                }
                function cC(a) {
                    var c = Ne(a) ? OT : nM;
                    return c(a);
                }
                function uC(a) {
                    if (a == null) return 0;
                    if (bn(a)) return fl(a) ? _o(a) : a.length;
                    var c = en(a);
                    return c == st || c == ee ? a.size : ld(a).length;
                }
                function dC(a, c, p) {
                    var g = Ne(a) ? Ku : rM;
                    return p && cn(a, c, p) && (c = t), g(a, ye(c, 3));
                }
                var fC = Fe(function (a, c) {
                        if (a == null) return [];
                        var p = c.length;
                        return (
                            p > 1 && cn(a, c[0], c[1]) ? (c = []) : p > 2 && cn(c[0], c[1], c[2]) && (c = [c[0]]),
                            Ug(a, Gt(c, 1), [])
                        );
                    }),
                    ll =
                        G1 ||
                        function () {
                            return Ft.Date.now();
                        };
                function pC(a, c) {
                    if (typeof c != 'function') throw new In(i);
                    return (
                        (a = Ie(a)),
                        function () {
                            if (--a < 1) return c.apply(this, arguments);
                        }
                    );
                }
                function Pb(a, c, p) {
                    return (c = p ? t : c), (c = a && c == null ? a.length : c), Mr(a, z, t, t, t, t, c);
                }
                function Bb(a, c) {
                    var p;
                    if (typeof c != 'function') throw new In(i);
                    return (
                        (a = Ie(a)),
                        function () {
                            return --a > 0 && (p = c.apply(this, arguments)), a <= 1 && (c = t), p;
                        }
                    );
                }
                var Rd = Fe(function (a, c, p) {
                        var g = y;
                        if (p.length) {
                            var E = jr(p, No(Rd));
                            g |= I;
                        }
                        return Mr(a, g, c, p, E);
                    }),
                    Fb = Fe(function (a, c, p) {
                        var g = y | v;
                        if (p.length) {
                            var E = jr(p, No(Fb));
                            g |= I;
                        }
                        return Mr(c, g, a, p, E);
                    });
                function Hb(a, c, p) {
                    c = p ? t : c;
                    var g = Mr(a, T, t, t, t, t, t, c);
                    return (g.placeholder = Hb.placeholder), g;
                }
                function zb(a, c, p) {
                    c = p ? t : c;
                    var g = Mr(a, D, t, t, t, t, t, c);
                    return (g.placeholder = zb.placeholder), g;
                }
                function $b(a, c, p) {
                    var g,
                        E,
                        _,
                        M,
                        A,
                        k,
                        U = 0,
                        W = !1,
                        G = !1,
                        te = !0;
                    if (typeof a != 'function') throw new In(i);
                    (c = Fn(c) || 0),
                        pt(p) &&
                            ((W = !!p.leading),
                            (G = 'maxWait' in p),
                            (_ = G ? It(Fn(p.maxWait) || 0, c) : _),
                            (te = 'trailing' in p ? !!p.trailing : te));
                    function de(vt) {
                        var Qn = g,
                            Or = E;
                        return (g = E = t), (U = vt), (M = a.apply(Or, Qn)), M;
                    }
                    function ve(vt) {
                        return (U = vt), (A = ks($e, c)), W ? de(vt) : M;
                    }
                    function Pe(vt) {
                        var Qn = vt - k,
                            Or = vt - U,
                            sy = c - Qn;
                        return G ? Qt(sy, _ - Or) : sy;
                    }
                    function we(vt) {
                        var Qn = vt - k,
                            Or = vt - U;
                        return k === t || Qn >= c || Qn < 0 || (G && Or >= _);
                    }
                    function $e() {
                        var vt = ll();
                        if (we(vt)) return Ye(vt);
                        A = ks($e, Pe(vt));
                    }
                    function Ye(vt) {
                        return (A = t), te && g ? de(vt) : ((g = E = t), M);
                    }
                    function Cn() {
                        A !== t && Zg(A), (U = 0), (g = k = E = A = t);
                    }
                    function un() {
                        return A === t ? M : Ye(ll());
                    }
                    function kn() {
                        var vt = ll(),
                            Qn = we(vt);
                        if (((g = arguments), (E = this), (k = vt), Qn)) {
                            if (A === t) return ve(k);
                            if (G) return Zg(A), (A = ks($e, c)), de(k);
                        }
                        return A === t && (A = ks($e, c)), M;
                    }
                    return (kn.cancel = Cn), (kn.flush = un), kn;
                }
                var hC = Fe(function (a, c) {
                        return Ng(a, 1, c);
                    }),
                    mC = Fe(function (a, c, p) {
                        return Ng(a, Fn(c) || 0, p);
                    });
                function gC(a) {
                    return Mr(a, q);
                }
                function cl(a, c) {
                    if (typeof a != 'function' || (c != null && typeof c != 'function')) throw new In(i);
                    var p = function () {
                        var g = arguments,
                            E = c ? c.apply(this, g) : g[0],
                            _ = p.cache;
                        if (_.has(E)) return _.get(E);
                        var M = a.apply(this, g);
                        return (p.cache = _.set(E, M) || _), M;
                    };
                    return (p.cache = new (cl.Cache || Sr)()), p;
                }
                cl.Cache = Sr;
                function ul(a) {
                    if (typeof a != 'function') throw new In(i);
                    return function () {
                        var c = arguments;
                        switch (c.length) {
                            case 0:
                                return !a.call(this);
                            case 1:
                                return !a.call(this, c[0]);
                            case 2:
                                return !a.call(this, c[0], c[1]);
                            case 3:
                                return !a.call(this, c[0], c[1], c[2]);
                        }
                        return !a.apply(this, c);
                    };
                }
                function bC(a) {
                    return Bb(2, a);
                }
                var yC = iM(function (a, c) {
                        c = c.length == 1 && Ne(c[0]) ? ut(c[0], Tn(ye())) : ut(Gt(c, 1), Tn(ye()));
                        var p = c.length;
                        return Fe(function (g) {
                            for (var E = -1, _ = Qt(g.length, p); ++E < _; ) g[E] = c[E].call(this, g[E]);
                            return Sn(a, this, g);
                        });
                    }),
                    Id = Fe(function (a, c) {
                        var p = jr(c, No(Id));
                        return Mr(a, I, t, c, p);
                    }),
                    Ub = Fe(function (a, c) {
                        var p = jr(c, No(Ub));
                        return Mr(a, S, t, c, p);
                    }),
                    EC = Ar(function (a, c) {
                        return Mr(a, N, t, t, t, c);
                    });
                function vC(a, c) {
                    if (typeof a != 'function') throw new In(i);
                    return (c = c === t ? c : Ie(c)), Fe(a, c);
                }
                function wC(a, c) {
                    if (typeof a != 'function') throw new In(i);
                    return (
                        (c = c == null ? 0 : It(Ie(c), 0)),
                        Fe(function (p) {
                            var g = p[c],
                                E = ii(p, 0, c);
                            return g && Zr(E, g), Sn(a, this, E);
                        })
                    );
                }
                function xC(a, c, p) {
                    var g = !0,
                        E = !0;
                    if (typeof a != 'function') throw new In(i);
                    return (
                        pt(p) && ((g = 'leading' in p ? !!p.leading : g), (E = 'trailing' in p ? !!p.trailing : E)),
                        $b(a, c, { leading: g, maxWait: c, trailing: E })
                    );
                }
                function _C(a) {
                    return Pb(a, 1);
                }
                function SC(a, c) {
                    return Id(bd(c), a);
                }
                function TC() {
                    if (!arguments.length) return [];
                    var a = arguments[0];
                    return Ne(a) ? a : [a];
                }
                function MC(a) {
                    return Dn(a, h);
                }
                function AC(a, c) {
                    return (c = typeof c == 'function' ? c : t), Dn(a, h, c);
                }
                function CC(a) {
                    return Dn(a, d | h);
                }
                function kC(a, c) {
                    return (c = typeof c == 'function' ? c : t), Dn(a, d | h, c);
                }
                function NC(a, c) {
                    return c == null || kg(a, c, Ht(c));
                }
                function jn(a, c) {
                    return a === c || (a !== a && c !== c);
                }
                var OC = nl(od),
                    RC = nl(function (a, c) {
                        return a >= c;
                    }),
                    Pi = Dg(
                        (function () {
                            return arguments;
                        })(),
                    )
                        ? Dg
                        : function (a) {
                              return gt(a) && et.call(a, 'callee') && !wg.call(a, 'callee');
                          },
                    Ne = L.isArray,
                    IC = ng ? Tn(ng) : $T;
                function bn(a) {
                    return a != null && dl(a.length) && !kr(a);
                }
                function Et(a) {
                    return gt(a) && bn(a);
                }
                function LC(a) {
                    return a === !0 || a === !1 || (gt(a) && ln(a) == Xe);
                }
                var oi = Y1 || Kd,
                    DC = rg ? Tn(rg) : UT;
                function PC(a) {
                    return gt(a) && a.nodeType === 1 && !Ns(a);
                }
                function BC(a) {
                    if (a == null) return !0;
                    if (
                        bn(a) &&
                        (Ne(a) || typeof a == 'string' || typeof a.splice == 'function' || oi(a) || Oo(a) || Pi(a))
                    )
                        return !a.length;
                    var c = en(a);
                    if (c == st || c == ee) return !a.size;
                    if (Cs(a)) return !ld(a).length;
                    for (var p in a) if (et.call(a, p)) return !1;
                    return !0;
                }
                function FC(a, c) {
                    return Ts(a, c);
                }
                function HC(a, c, p) {
                    p = typeof p == 'function' ? p : t;
                    var g = p ? p(a, c) : t;
                    return g === t ? Ts(a, c, t, p) : !!g;
                }
                function Ld(a) {
                    if (!gt(a)) return !1;
                    var c = ln(a);
                    return c == De || c == Pt || (typeof a.message == 'string' && typeof a.name == 'string' && !Ns(a));
                }
                function zC(a) {
                    return typeof a == 'number' && _g(a);
                }
                function kr(a) {
                    if (!pt(a)) return !1;
                    var c = ln(a);
                    return c == _t || c == Zt || c == He || c == be;
                }
                function Wb(a) {
                    return typeof a == 'number' && a == Ie(a);
                }
                function dl(a) {
                    return typeof a == 'number' && a > -1 && a % 1 == 0 && a <= P;
                }
                function pt(a) {
                    var c = typeof a;
                    return a != null && (c == 'object' || c == 'function');
                }
                function gt(a) {
                    return a != null && typeof a == 'object';
                }
                var Kb = ig ? Tn(ig) : KT;
                function $C(a, c) {
                    return a === c || ad(a, c, Sd(c));
                }
                function UC(a, c, p) {
                    return (p = typeof p == 'function' ? p : t), ad(a, c, Sd(c), p);
                }
                function WC(a) {
                    return Vb(a) && a != +a;
                }
                function KC(a) {
                    if (AM(a)) throw new ke(r);
                    return Pg(a);
                }
                function VC(a) {
                    return a === null;
                }
                function GC(a) {
                    return a == null;
                }
                function Vb(a) {
                    return typeof a == 'number' || (gt(a) && ln(a) == jt);
                }
                function Ns(a) {
                    if (!gt(a) || ln(a) != Nt) return !1;
                    var c = Fa(a);
                    if (c === null) return !0;
                    var p = et.call(c, 'constructor') && c.constructor;
                    return typeof p == 'function' && p instanceof p && La.call(p) == U1;
                }
                var Dd = og ? Tn(og) : VT;
                function qC(a) {
                    return Wb(a) && a >= -P && a <= P;
                }
                var Gb = sg ? Tn(sg) : GT;
                function fl(a) {
                    return typeof a == 'string' || (!Ne(a) && gt(a) && ln(a) == Ce);
                }
                function An(a) {
                    return typeof a == 'symbol' || (gt(a) && ln(a) == Ke);
                }
                var Oo = ag ? Tn(ag) : qT;
                function YC(a) {
                    return a === t;
                }
                function JC(a) {
                    return gt(a) && en(a) == mt;
                }
                function XC(a) {
                    return gt(a) && ln(a) == Ot;
                }
                var ZC = nl(cd),
                    jC = nl(function (a, c) {
                        return a <= c;
                    });
                function qb(a) {
                    if (!a) return [];
                    if (bn(a)) return fl(a) ? Xn(a) : gn(a);
                    if (bs && a[bs]) return N1(a[bs]());
                    var c = en(a),
                        p = c == st ? Xu : c == ee ? Oa : Ro;
                    return p(a);
                }
                function Nr(a) {
                    if (!a) return a === 0 ? a : 0;
                    if (((a = Fn(a)), a === Ee || a === -Ee)) {
                        var c = a < 0 ? -1 : 1;
                        return c * O;
                    }
                    return a === a ? a : 0;
                }
                function Ie(a) {
                    var c = Nr(a),
                        p = c % 1;
                    return c === c ? (p ? c - p : c) : 0;
                }
                function Yb(a) {
                    return a ? Ri(Ie(a), 0, V) : 0;
                }
                function Fn(a) {
                    if (typeof a == 'number') return a;
                    if (An(a)) return R;
                    if (pt(a)) {
                        var c = typeof a.valueOf == 'function' ? a.valueOf() : a;
                        a = pt(c) ? c + '' : c;
                    }
                    if (typeof a != 'string') return a === 0 ? a : +a;
                    a = pg(a);
                    var p = IS.test(a);
                    return p || DS.test(a) ? p1(a.slice(2), p ? 2 : 8) : RS.test(a) ? R : +a;
                }
                function Jb(a) {
                    return ur(a, yn(a));
                }
                function QC(a) {
                    return a ? Ri(Ie(a), -P, P) : a === 0 ? a : 0;
                }
                function Qe(a) {
                    return a == null ? '' : Mn(a);
                }
                var ek = Co(function (a, c) {
                        if (Cs(c) || bn(c)) {
                            ur(c, Ht(c), a);
                            return;
                        }
                        for (var p in c) et.call(c, p) && xs(a, p, c[p]);
                    }),
                    Xb = Co(function (a, c) {
                        ur(c, yn(c), a);
                    }),
                    pl = Co(function (a, c, p, g) {
                        ur(c, yn(c), a, g);
                    }),
                    tk = Co(function (a, c, p, g) {
                        ur(c, Ht(c), a, g);
                    }),
                    nk = Ar(nd);
                function rk(a, c) {
                    var p = Ao(a);
                    return c == null ? p : Cg(p, c);
                }
                var ik = Fe(function (a, c) {
                        a = nt(a);
                        var p = -1,
                            g = c.length,
                            E = g > 2 ? c[2] : t;
                        for (E && cn(c[0], c[1], E) && (g = 1); ++p < g; )
                            for (var _ = c[p], M = yn(_), A = -1, k = M.length; ++A < k; ) {
                                var U = M[A],
                                    W = a[U];
                                (W === t || (jn(W, So[U]) && !et.call(a, U))) && (a[U] = _[U]);
                            }
                        return a;
                    }),
                    ok = Fe(function (a) {
                        return a.push(t, pb), Sn(Zb, t, a);
                    });
                function sk(a, c) {
                    return cg(a, ye(c, 3), cr);
                }
                function ak(a, c) {
                    return cg(a, ye(c, 3), id);
                }
                function lk(a, c) {
                    return a == null ? a : rd(a, ye(c, 3), yn);
                }
                function ck(a, c) {
                    return a == null ? a : Ig(a, ye(c, 3), yn);
                }
                function uk(a, c) {
                    return a && cr(a, ye(c, 3));
                }
                function dk(a, c) {
                    return a && id(a, ye(c, 3));
                }
                function fk(a) {
                    return a == null ? [] : Ya(a, Ht(a));
                }
                function pk(a) {
                    return a == null ? [] : Ya(a, yn(a));
                }
                function Pd(a, c, p) {
                    var g = a == null ? t : Ii(a, c);
                    return g === t ? p : g;
                }
                function hk(a, c) {
                    return a != null && gb(a, c, BT);
                }
                function Bd(a, c) {
                    return a != null && gb(a, c, FT);
                }
                var mk = lb(function (a, c, p) {
                        c != null && typeof c.toString != 'function' && (c = Da.call(c)), (a[c] = p);
                    }, Hd(En)),
                    gk = lb(function (a, c, p) {
                        c != null && typeof c.toString != 'function' && (c = Da.call(c)),
                            et.call(a, c) ? a[c].push(p) : (a[c] = [p]);
                    }, ye),
                    bk = Fe(Ss);
                function Ht(a) {
                    return bn(a) ? Mg(a) : ld(a);
                }
                function yn(a) {
                    return bn(a) ? Mg(a, !0) : YT(a);
                }
                function yk(a, c) {
                    var p = {};
                    return (
                        (c = ye(c, 3)),
                        cr(a, function (g, E, _) {
                            Tr(p, c(g, E, _), g);
                        }),
                        p
                    );
                }
                function Ek(a, c) {
                    var p = {};
                    return (
                        (c = ye(c, 3)),
                        cr(a, function (g, E, _) {
                            Tr(p, E, c(g, E, _));
                        }),
                        p
                    );
                }
                var vk = Co(function (a, c, p) {
                        Ja(a, c, p);
                    }),
                    Zb = Co(function (a, c, p, g) {
                        Ja(a, c, p, g);
                    }),
                    wk = Ar(function (a, c) {
                        var p = {};
                        if (a == null) return p;
                        var g = !1;
                        (c = ut(c, function (_) {
                            return (_ = ri(_, a)), g || (g = _.length > 1), _;
                        })),
                            ur(a, xd(a), p),
                            g && (p = Dn(p, d | f | h, mM));
                        for (var E = c.length; E--; ) hd(p, c[E]);
                        return p;
                    });
                function xk(a, c) {
                    return jb(a, ul(ye(c)));
                }
                var _k = Ar(function (a, c) {
                    return a == null ? {} : XT(a, c);
                });
                function jb(a, c) {
                    if (a == null) return {};
                    var p = ut(xd(a), function (g) {
                        return [g];
                    });
                    return (
                        (c = ye(c)),
                        Wg(a, p, function (g, E) {
                            return c(g, E[0]);
                        })
                    );
                }
                function Sk(a, c, p) {
                    c = ri(c, a);
                    var g = -1,
                        E = c.length;
                    for (E || ((E = 1), (a = t)); ++g < E; ) {
                        var _ = a == null ? t : a[dr(c[g])];
                        _ === t && ((g = E), (_ = p)), (a = kr(_) ? _.call(a) : _);
                    }
                    return a;
                }
                function Tk(a, c, p) {
                    return a == null ? a : Ms(a, c, p);
                }
                function Mk(a, c, p, g) {
                    return (g = typeof g == 'function' ? g : t), a == null ? a : Ms(a, c, p, g);
                }
                var Qb = db(Ht),
                    ey = db(yn);
                function Ak(a, c, p) {
                    var g = Ne(a),
                        E = g || oi(a) || Oo(a);
                    if (((c = ye(c, 4)), p == null)) {
                        var _ = a && a.constructor;
                        E ? (p = g ? new _() : []) : pt(a) ? (p = kr(_) ? Ao(Fa(a)) : {}) : (p = {});
                    }
                    return (
                        (E ? Rn : cr)(a, function (M, A, k) {
                            return c(p, M, A, k);
                        }),
                        p
                    );
                }
                function Ck(a, c) {
                    return a == null ? !0 : hd(a, c);
                }
                function kk(a, c, p) {
                    return a == null ? a : Yg(a, c, bd(p));
                }
                function Nk(a, c, p, g) {
                    return (g = typeof g == 'function' ? g : t), a == null ? a : Yg(a, c, bd(p), g);
                }
                function Ro(a) {
                    return a == null ? [] : Ju(a, Ht(a));
                }
                function Ok(a) {
                    return a == null ? [] : Ju(a, yn(a));
                }
                function Rk(a, c, p) {
                    return (
                        p === t && ((p = c), (c = t)),
                        p !== t && ((p = Fn(p)), (p = p === p ? p : 0)),
                        c !== t && ((c = Fn(c)), (c = c === c ? c : 0)),
                        Ri(Fn(a), c, p)
                    );
                }
                function Ik(a, c, p) {
                    return (c = Nr(c)), p === t ? ((p = c), (c = 0)) : (p = Nr(p)), (a = Fn(a)), HT(a, c, p);
                }
                function Lk(a, c, p) {
                    if (
                        (p && typeof p != 'boolean' && cn(a, c, p) && (c = p = t),
                        p === t &&
                            (typeof c == 'boolean' ? ((p = c), (c = t)) : typeof a == 'boolean' && ((p = a), (a = t))),
                        a === t && c === t
                            ? ((a = 0), (c = 1))
                            : ((a = Nr(a)), c === t ? ((c = a), (a = 0)) : (c = Nr(c))),
                        a > c)
                    ) {
                        var g = a;
                        (a = c), (c = g);
                    }
                    if (p || a % 1 || c % 1) {
                        var E = Sg();
                        return Qt(a + E * (c - a + f1('1e-' + ((E + '').length - 1))), c);
                    }
                    return dd(a, c);
                }
                var Dk = ko(function (a, c, p) {
                    return (c = c.toLowerCase()), a + (p ? ty(c) : c);
                });
                function ty(a) {
                    return Fd(Qe(a).toLowerCase());
                }
                function ny(a) {
                    return (a = Qe(a)), a && a.replace(BS, T1).replace(n1, '');
                }
                function Pk(a, c, p) {
                    (a = Qe(a)), (c = Mn(c));
                    var g = a.length;
                    p = p === t ? g : Ri(Ie(p), 0, g);
                    var E = p;
                    return (p -= c.length), p >= 0 && a.slice(p, E) == c;
                }
                function Bk(a) {
                    return (a = Qe(a)), a && Ta.test(a) ? a.replace(an, M1) : a;
                }
                function Fk(a) {
                    return (a = Qe(a)), a && _S.test(a) ? a.replace(Jr, '\\$&') : a;
                }
                var Hk = ko(function (a, c, p) {
                        return a + (p ? '-' : '') + c.toLowerCase();
                    }),
                    zk = ko(function (a, c, p) {
                        return a + (p ? ' ' : '') + c.toLowerCase();
                    }),
                    $k = ob('toLowerCase');
                function Uk(a, c, p) {
                    (a = Qe(a)), (c = Ie(c));
                    var g = c ? _o(a) : 0;
                    if (!c || g >= c) return a;
                    var E = (c - g) / 2;
                    return tl(Ua(E), p) + a + tl($a(E), p);
                }
                function Wk(a, c, p) {
                    (a = Qe(a)), (c = Ie(c));
                    var g = c ? _o(a) : 0;
                    return c && g < c ? a + tl(c - g, p) : a;
                }
                function Kk(a, c, p) {
                    (a = Qe(a)), (c = Ie(c));
                    var g = c ? _o(a) : 0;
                    return c && g < c ? tl(c - g, p) + a : a;
                }
                function Vk(a, c, p) {
                    return p || c == null ? (c = 0) : c && (c = +c), j1(Qe(a).replace(Lu, ''), c || 0);
                }
                function Gk(a, c, p) {
                    return (p ? cn(a, c, p) : c === t) ? (c = 1) : (c = Ie(c)), fd(Qe(a), c);
                }
                function qk() {
                    var a = arguments,
                        c = Qe(a[0]);
                    return a.length < 3 ? c : c.replace(a[1], a[2]);
                }
                var Yk = ko(function (a, c, p) {
                    return a + (p ? '_' : '') + c.toLowerCase();
                });
                function Jk(a, c, p) {
                    return (
                        p && typeof p != 'number' && cn(a, c, p) && (c = p = t),
                        (p = p === t ? V : p >>> 0),
                        p
                            ? ((a = Qe(a)),
                              a && (typeof c == 'string' || (c != null && !Dd(c))) && ((c = Mn(c)), !c && xo(a))
                                  ? ii(Xn(a), 0, p)
                                  : a.split(c, p))
                            : []
                    );
                }
                var Xk = ko(function (a, c, p) {
                    return a + (p ? ' ' : '') + Fd(c);
                });
                function Zk(a, c, p) {
                    return (
                        (a = Qe(a)),
                        (p = p == null ? 0 : Ri(Ie(p), 0, a.length)),
                        (c = Mn(c)),
                        a.slice(p, p + c.length) == c
                    );
                }
                function jk(a, c, p) {
                    var g = w.templateSettings;
                    p && cn(a, c, p) && (c = t), (a = Qe(a)), (c = pl({}, c, g, fb));
                    var E = pl({}, c.imports, g.imports, fb),
                        _ = Ht(E),
                        M = Ju(E, _),
                        A,
                        k,
                        U = 0,
                        W = c.interpolate || Ma,
                        G = "__p += '",
                        te = Zu(
                            (c.escape || Ma).source +
                                '|' +
                                W.source +
                                '|' +
                                (W === Ai ? OS : Ma).source +
                                '|' +
                                (c.evaluate || Ma).source +
                                '|$',
                            'g',
                        ),
                        de =
                            '//# sourceURL=' +
                            (et.call(c, 'sourceURL')
                                ? (c.sourceURL + '').replace(/\s/g, ' ')
                                : 'lodash.templateSources[' + ++a1 + ']') +
                            `
`;
                    a.replace(te, function (we, $e, Ye, Cn, un, kn) {
                        return (
                            Ye || (Ye = Cn),
                            (G += a.slice(U, kn).replace(FS, A1)),
                            $e &&
                                ((A = !0),
                                (G +=
                                    `' +
__e(` +
                                    $e +
                                    `) +
'`)),
                            un &&
                                ((k = !0),
                                (G +=
                                    `';
` +
                                    un +
                                    `;
__p += '`)),
                            Ye &&
                                (G +=
                                    `' +
((__t = (` +
                                    Ye +
                                    `)) == null ? '' : __t) +
'`),
                            (U = kn + we.length),
                            we
                        );
                    }),
                        (G += `';
`);
                    var ve = et.call(c, 'variable') && c.variable;
                    if (!ve)
                        G =
                            `with (obj) {
` +
                            G +
                            `
}
`;
                    else if (kS.test(ve)) throw new ke(o);
                    (G = (k ? G.replace(_e, '') : G).replace(Ze, '$1').replace(qe, '$1;')),
                        (G =
                            'function(' +
                            (ve || 'obj') +
                            `) {
` +
                            (ve
                                ? ''
                                : `obj || (obj = {});
`) +
                            "var __t, __p = ''" +
                            (A ? ', __e = _.escape' : '') +
                            (k
                                ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                                : `;
`) +
                            G +
                            `return __p
}`);
                    var Pe = iy(function () {
                        return je(_, de + 'return ' + G).apply(t, M);
                    });
                    if (((Pe.source = G), Ld(Pe))) throw Pe;
                    return Pe;
                }
                function Qk(a) {
                    return Qe(a).toLowerCase();
                }
                function eN(a) {
                    return Qe(a).toUpperCase();
                }
                function tN(a, c, p) {
                    if (((a = Qe(a)), a && (p || c === t))) return pg(a);
                    if (!a || !(c = Mn(c))) return a;
                    var g = Xn(a),
                        E = Xn(c),
                        _ = hg(g, E),
                        M = mg(g, E) + 1;
                    return ii(g, _, M).join('');
                }
                function nN(a, c, p) {
                    if (((a = Qe(a)), a && (p || c === t))) return a.slice(0, bg(a) + 1);
                    if (!a || !(c = Mn(c))) return a;
                    var g = Xn(a),
                        E = mg(g, Xn(c)) + 1;
                    return ii(g, 0, E).join('');
                }
                function rN(a, c, p) {
                    if (((a = Qe(a)), a && (p || c === t))) return a.replace(Lu, '');
                    if (!a || !(c = Mn(c))) return a;
                    var g = Xn(a),
                        E = hg(g, Xn(c));
                    return ii(g, E).join('');
                }
                function iN(a, c) {
                    var p = ne,
                        g = $;
                    if (pt(c)) {
                        var E = 'separator' in c ? c.separator : E;
                        (p = 'length' in c ? Ie(c.length) : p), (g = 'omission' in c ? Mn(c.omission) : g);
                    }
                    a = Qe(a);
                    var _ = a.length;
                    if (xo(a)) {
                        var M = Xn(a);
                        _ = M.length;
                    }
                    if (p >= _) return a;
                    var A = p - _o(g);
                    if (A < 1) return g;
                    var k = M ? ii(M, 0, A).join('') : a.slice(0, A);
                    if (E === t) return k + g;
                    if ((M && (A += k.length - A), Dd(E))) {
                        if (a.slice(A).search(E)) {
                            var U,
                                W = k;
                            for (
                                E.global || (E = Zu(E.source, Qe(Dm.exec(E)) + 'g')), E.lastIndex = 0;
                                (U = E.exec(W));

                            )
                                var G = U.index;
                            k = k.slice(0, G === t ? A : G);
                        }
                    } else if (a.indexOf(Mn(E), A) != A) {
                        var te = k.lastIndexOf(E);
                        te > -1 && (k = k.slice(0, te));
                    }
                    return k + g;
                }
                function oN(a) {
                    return (a = Qe(a)), a && qr.test(a) ? a.replace(Bt, L1) : a;
                }
                var sN = ko(function (a, c, p) {
                        return a + (p ? ' ' : '') + c.toUpperCase();
                    }),
                    Fd = ob('toUpperCase');
                function ry(a, c, p) {
                    return (a = Qe(a)), (c = p ? t : c), c === t ? (k1(a) ? B1(a) : v1(a)) : a.match(c) || [];
                }
                var iy = Fe(function (a, c) {
                        try {
                            return Sn(a, t, c);
                        } catch (p) {
                            return Ld(p) ? p : new ke(p);
                        }
                    }),
                    aN = Ar(function (a, c) {
                        return (
                            Rn(c, function (p) {
                                (p = dr(p)), Tr(a, p, Rd(a[p], a));
                            }),
                            a
                        );
                    });
                function lN(a) {
                    var c = a == null ? 0 : a.length,
                        p = ye();
                    return (
                        (a = c
                            ? ut(a, function (g) {
                                  if (typeof g[1] != 'function') throw new In(i);
                                  return [p(g[0]), g[1]];
                              })
                            : []),
                        Fe(function (g) {
                            for (var E = -1; ++E < c; ) {
                                var _ = a[E];
                                if (Sn(_[0], this, g)) return Sn(_[1], this, g);
                            }
                        })
                    );
                }
                function cN(a) {
                    return LT(Dn(a, d));
                }
                function Hd(a) {
                    return function () {
                        return a;
                    };
                }
                function uN(a, c) {
                    return a == null || a !== a ? c : a;
                }
                var dN = ab(),
                    fN = ab(!0);
                function En(a) {
                    return a;
                }
                function zd(a) {
                    return Bg(typeof a == 'function' ? a : Dn(a, d));
                }
                function pN(a) {
                    return Hg(Dn(a, d));
                }
                function hN(a, c) {
                    return zg(a, Dn(c, d));
                }
                var mN = Fe(function (a, c) {
                        return function (p) {
                            return Ss(p, a, c);
                        };
                    }),
                    gN = Fe(function (a, c) {
                        return function (p) {
                            return Ss(a, p, c);
                        };
                    });
                function $d(a, c, p) {
                    var g = Ht(c),
                        E = Ya(c, g);
                    p == null &&
                        !(pt(c) && (E.length || !g.length)) &&
                        ((p = c), (c = a), (a = this), (E = Ya(c, Ht(c))));
                    var _ = !(pt(p) && 'chain' in p) || !!p.chain,
                        M = kr(a);
                    return (
                        Rn(E, function (A) {
                            var k = c[A];
                            (a[A] = k),
                                M &&
                                    (a.prototype[A] = function () {
                                        var U = this.__chain__;
                                        if (_ || U) {
                                            var W = a(this.__wrapped__),
                                                G = (W.__actions__ = gn(this.__actions__));
                                            return (
                                                G.push({ func: k, args: arguments, thisArg: a }), (W.__chain__ = U), W
                                            );
                                        }
                                        return k.apply(a, Zr([this.value()], arguments));
                                    });
                        }),
                        a
                    );
                }
                function bN() {
                    return Ft._ === this && (Ft._ = W1), this;
                }
                function Ud() {}
                function yN(a) {
                    return (
                        (a = Ie(a)),
                        Fe(function (c) {
                            return $g(c, a);
                        })
                    );
                }
                var EN = Ed(ut),
                    vN = Ed(lg),
                    wN = Ed(Ku);
                function oy(a) {
                    return Md(a) ? Vu(dr(a)) : ZT(a);
                }
                function xN(a) {
                    return function (c) {
                        return a == null ? t : Ii(a, c);
                    };
                }
                var _N = cb(),
                    SN = cb(!0);
                function Wd() {
                    return [];
                }
                function Kd() {
                    return !1;
                }
                function TN() {
                    return {};
                }
                function MN() {
                    return '';
                }
                function AN() {
                    return !0;
                }
                function CN(a, c) {
                    if (((a = Ie(a)), a < 1 || a > P)) return [];
                    var p = V,
                        g = Qt(a, V);
                    (c = ye(c)), (a -= V);
                    for (var E = Yu(g, c); ++p < a; ) c(p);
                    return E;
                }
                function kN(a) {
                    return Ne(a) ? ut(a, dr) : An(a) ? [a] : gn(Tb(Qe(a)));
                }
                function NN(a) {
                    var c = ++$1;
                    return Qe(a) + c;
                }
                var ON = el(function (a, c) {
                        return a + c;
                    }, 0),
                    RN = vd('ceil'),
                    IN = el(function (a, c) {
                        return a / c;
                    }, 1),
                    LN = vd('floor');
                function DN(a) {
                    return a && a.length ? qa(a, En, od) : t;
                }
                function PN(a, c) {
                    return a && a.length ? qa(a, ye(c, 2), od) : t;
                }
                function BN(a) {
                    return dg(a, En);
                }
                function FN(a, c) {
                    return dg(a, ye(c, 2));
                }
                function HN(a) {
                    return a && a.length ? qa(a, En, cd) : t;
                }
                function zN(a, c) {
                    return a && a.length ? qa(a, ye(c, 2), cd) : t;
                }
                var $N = el(function (a, c) {
                        return a * c;
                    }, 1),
                    UN = vd('round'),
                    WN = el(function (a, c) {
                        return a - c;
                    }, 0);
                function KN(a) {
                    return a && a.length ? qu(a, En) : 0;
                }
                function VN(a, c) {
                    return a && a.length ? qu(a, ye(c, 2)) : 0;
                }
                return (
                    (w.after = pC),
                    (w.ary = Pb),
                    (w.assign = ek),
                    (w.assignIn = Xb),
                    (w.assignInWith = pl),
                    (w.assignWith = tk),
                    (w.at = nk),
                    (w.before = Bb),
                    (w.bind = Rd),
                    (w.bindAll = aN),
                    (w.bindKey = Fb),
                    (w.castArray = TC),
                    (w.chain = Ib),
                    (w.chunk = LM),
                    (w.compact = DM),
                    (w.concat = PM),
                    (w.cond = lN),
                    (w.conforms = cN),
                    (w.constant = Hd),
                    (w.countBy = KA),
                    (w.create = rk),
                    (w.curry = Hb),
                    (w.curryRight = zb),
                    (w.debounce = $b),
                    (w.defaults = ik),
                    (w.defaultsDeep = ok),
                    (w.defer = hC),
                    (w.delay = mC),
                    (w.difference = BM),
                    (w.differenceBy = FM),
                    (w.differenceWith = HM),
                    (w.drop = zM),
                    (w.dropRight = $M),
                    (w.dropRightWhile = UM),
                    (w.dropWhile = WM),
                    (w.fill = KM),
                    (w.filter = GA),
                    (w.flatMap = JA),
                    (w.flatMapDeep = XA),
                    (w.flatMapDepth = ZA),
                    (w.flatten = kb),
                    (w.flattenDeep = VM),
                    (w.flattenDepth = GM),
                    (w.flip = gC),
                    (w.flow = dN),
                    (w.flowRight = fN),
                    (w.fromPairs = qM),
                    (w.functions = fk),
                    (w.functionsIn = pk),
                    (w.groupBy = jA),
                    (w.initial = JM),
                    (w.intersection = XM),
                    (w.intersectionBy = ZM),
                    (w.intersectionWith = jM),
                    (w.invert = mk),
                    (w.invertBy = gk),
                    (w.invokeMap = eC),
                    (w.iteratee = zd),
                    (w.keyBy = tC),
                    (w.keys = Ht),
                    (w.keysIn = yn),
                    (w.map = al),
                    (w.mapKeys = yk),
                    (w.mapValues = Ek),
                    (w.matches = pN),
                    (w.matchesProperty = hN),
                    (w.memoize = cl),
                    (w.merge = vk),
                    (w.mergeWith = Zb),
                    (w.method = mN),
                    (w.methodOf = gN),
                    (w.mixin = $d),
                    (w.negate = ul),
                    (w.nthArg = yN),
                    (w.omit = wk),
                    (w.omitBy = xk),
                    (w.once = bC),
                    (w.orderBy = nC),
                    (w.over = EN),
                    (w.overArgs = yC),
                    (w.overEvery = vN),
                    (w.overSome = wN),
                    (w.partial = Id),
                    (w.partialRight = Ub),
                    (w.partition = rC),
                    (w.pick = _k),
                    (w.pickBy = jb),
                    (w.property = oy),
                    (w.propertyOf = xN),
                    (w.pull = nA),
                    (w.pullAll = Ob),
                    (w.pullAllBy = rA),
                    (w.pullAllWith = iA),
                    (w.pullAt = oA),
                    (w.range = _N),
                    (w.rangeRight = SN),
                    (w.rearg = EC),
                    (w.reject = sC),
                    (w.remove = sA),
                    (w.rest = vC),
                    (w.reverse = Nd),
                    (w.sampleSize = lC),
                    (w.set = Tk),
                    (w.setWith = Mk),
                    (w.shuffle = cC),
                    (w.slice = aA),
                    (w.sortBy = fC),
                    (w.sortedUniq = hA),
                    (w.sortedUniqBy = mA),
                    (w.split = Jk),
                    (w.spread = wC),
                    (w.tail = gA),
                    (w.take = bA),
                    (w.takeRight = yA),
                    (w.takeRightWhile = EA),
                    (w.takeWhile = vA),
                    (w.tap = DA),
                    (w.throttle = xC),
                    (w.thru = sl),
                    (w.toArray = qb),
                    (w.toPairs = Qb),
                    (w.toPairsIn = ey),
                    (w.toPath = kN),
                    (w.toPlainObject = Jb),
                    (w.transform = Ak),
                    (w.unary = _C),
                    (w.union = wA),
                    (w.unionBy = xA),
                    (w.unionWith = _A),
                    (w.uniq = SA),
                    (w.uniqBy = TA),
                    (w.uniqWith = MA),
                    (w.unset = Ck),
                    (w.unzip = Od),
                    (w.unzipWith = Rb),
                    (w.update = kk),
                    (w.updateWith = Nk),
                    (w.values = Ro),
                    (w.valuesIn = Ok),
                    (w.without = AA),
                    (w.words = ry),
                    (w.wrap = SC),
                    (w.xor = CA),
                    (w.xorBy = kA),
                    (w.xorWith = NA),
                    (w.zip = OA),
                    (w.zipObject = RA),
                    (w.zipObjectDeep = IA),
                    (w.zipWith = LA),
                    (w.entries = Qb),
                    (w.entriesIn = ey),
                    (w.extend = Xb),
                    (w.extendWith = pl),
                    $d(w, w),
                    (w.add = ON),
                    (w.attempt = iy),
                    (w.camelCase = Dk),
                    (w.capitalize = ty),
                    (w.ceil = RN),
                    (w.clamp = Rk),
                    (w.clone = MC),
                    (w.cloneDeep = CC),
                    (w.cloneDeepWith = kC),
                    (w.cloneWith = AC),
                    (w.conformsTo = NC),
                    (w.deburr = ny),
                    (w.defaultTo = uN),
                    (w.divide = IN),
                    (w.endsWith = Pk),
                    (w.eq = jn),
                    (w.escape = Bk),
                    (w.escapeRegExp = Fk),
                    (w.every = VA),
                    (w.find = qA),
                    (w.findIndex = Ab),
                    (w.findKey = sk),
                    (w.findLast = YA),
                    (w.findLastIndex = Cb),
                    (w.findLastKey = ak),
                    (w.floor = LN),
                    (w.forEach = Lb),
                    (w.forEachRight = Db),
                    (w.forIn = lk),
                    (w.forInRight = ck),
                    (w.forOwn = uk),
                    (w.forOwnRight = dk),
                    (w.get = Pd),
                    (w.gt = OC),
                    (w.gte = RC),
                    (w.has = hk),
                    (w.hasIn = Bd),
                    (w.head = Nb),
                    (w.identity = En),
                    (w.includes = QA),
                    (w.indexOf = YM),
                    (w.inRange = Ik),
                    (w.invoke = bk),
                    (w.isArguments = Pi),
                    (w.isArray = Ne),
                    (w.isArrayBuffer = IC),
                    (w.isArrayLike = bn),
                    (w.isArrayLikeObject = Et),
                    (w.isBoolean = LC),
                    (w.isBuffer = oi),
                    (w.isDate = DC),
                    (w.isElement = PC),
                    (w.isEmpty = BC),
                    (w.isEqual = FC),
                    (w.isEqualWith = HC),
                    (w.isError = Ld),
                    (w.isFinite = zC),
                    (w.isFunction = kr),
                    (w.isInteger = Wb),
                    (w.isLength = dl),
                    (w.isMap = Kb),
                    (w.isMatch = $C),
                    (w.isMatchWith = UC),
                    (w.isNaN = WC),
                    (w.isNative = KC),
                    (w.isNil = GC),
                    (w.isNull = VC),
                    (w.isNumber = Vb),
                    (w.isObject = pt),
                    (w.isObjectLike = gt),
                    (w.isPlainObject = Ns),
                    (w.isRegExp = Dd),
                    (w.isSafeInteger = qC),
                    (w.isSet = Gb),
                    (w.isString = fl),
                    (w.isSymbol = An),
                    (w.isTypedArray = Oo),
                    (w.isUndefined = YC),
                    (w.isWeakMap = JC),
                    (w.isWeakSet = XC),
                    (w.join = QM),
                    (w.kebabCase = Hk),
                    (w.last = Bn),
                    (w.lastIndexOf = eA),
                    (w.lowerCase = zk),
                    (w.lowerFirst = $k),
                    (w.lt = ZC),
                    (w.lte = jC),
                    (w.max = DN),
                    (w.maxBy = PN),
                    (w.mean = BN),
                    (w.meanBy = FN),
                    (w.min = HN),
                    (w.minBy = zN),
                    (w.stubArray = Wd),
                    (w.stubFalse = Kd),
                    (w.stubObject = TN),
                    (w.stubString = MN),
                    (w.stubTrue = AN),
                    (w.multiply = $N),
                    (w.nth = tA),
                    (w.noConflict = bN),
                    (w.noop = Ud),
                    (w.now = ll),
                    (w.pad = Uk),
                    (w.padEnd = Wk),
                    (w.padStart = Kk),
                    (w.parseInt = Vk),
                    (w.random = Lk),
                    (w.reduce = iC),
                    (w.reduceRight = oC),
                    (w.repeat = Gk),
                    (w.replace = qk),
                    (w.result = Sk),
                    (w.round = UN),
                    (w.runInContext = C),
                    (w.sample = aC),
                    (w.size = uC),
                    (w.snakeCase = Yk),
                    (w.some = dC),
                    (w.sortedIndex = lA),
                    (w.sortedIndexBy = cA),
                    (w.sortedIndexOf = uA),
                    (w.sortedLastIndex = dA),
                    (w.sortedLastIndexBy = fA),
                    (w.sortedLastIndexOf = pA),
                    (w.startCase = Xk),
                    (w.startsWith = Zk),
                    (w.subtract = WN),
                    (w.sum = KN),
                    (w.sumBy = VN),
                    (w.template = jk),
                    (w.times = CN),
                    (w.toFinite = Nr),
                    (w.toInteger = Ie),
                    (w.toLength = Yb),
                    (w.toLower = Qk),
                    (w.toNumber = Fn),
                    (w.toSafeInteger = QC),
                    (w.toString = Qe),
                    (w.toUpper = eN),
                    (w.trim = tN),
                    (w.trimEnd = nN),
                    (w.trimStart = rN),
                    (w.truncate = iN),
                    (w.unescape = oN),
                    (w.uniqueId = NN),
                    (w.upperCase = sN),
                    (w.upperFirst = Fd),
                    (w.each = Lb),
                    (w.eachRight = Db),
                    (w.first = Nb),
                    $d(
                        w,
                        (function () {
                            var a = {};
                            return (
                                cr(w, function (c, p) {
                                    et.call(w.prototype, p) || (a[p] = c);
                                }),
                                a
                            );
                        })(),
                        { chain: !1 },
                    ),
                    (w.VERSION = e),
                    Rn(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (a) {
                        w[a].placeholder = w;
                    }),
                    Rn(['drop', 'take'], function (a, c) {
                        (Ve.prototype[a] = function (p) {
                            p = p === t ? 1 : It(Ie(p), 0);
                            var g = this.__filtered__ && !c ? new Ve(this) : this.clone();
                            return (
                                g.__filtered__
                                    ? (g.__takeCount__ = Qt(p, g.__takeCount__))
                                    : g.__views__.push({ size: Qt(p, V), type: a + (g.__dir__ < 0 ? 'Right' : '') }),
                                g
                            );
                        }),
                            (Ve.prototype[a + 'Right'] = function (p) {
                                return this.reverse()[a](p).reverse();
                            });
                    }),
                    Rn(['filter', 'map', 'takeWhile'], function (a, c) {
                        var p = c + 1,
                            g = p == Te || p == Me;
                        Ve.prototype[a] = function (E) {
                            var _ = this.clone();
                            return (
                                _.__iteratees__.push({ iteratee: ye(E, 3), type: p }),
                                (_.__filtered__ = _.__filtered__ || g),
                                _
                            );
                        };
                    }),
                    Rn(['head', 'last'], function (a, c) {
                        var p = 'take' + (c ? 'Right' : '');
                        Ve.prototype[a] = function () {
                            return this[p](1).value()[0];
                        };
                    }),
                    Rn(['initial', 'tail'], function (a, c) {
                        var p = 'drop' + (c ? '' : 'Right');
                        Ve.prototype[a] = function () {
                            return this.__filtered__ ? new Ve(this) : this[p](1);
                        };
                    }),
                    (Ve.prototype.compact = function () {
                        return this.filter(En);
                    }),
                    (Ve.prototype.find = function (a) {
                        return this.filter(a).head();
                    }),
                    (Ve.prototype.findLast = function (a) {
                        return this.reverse().find(a);
                    }),
                    (Ve.prototype.invokeMap = Fe(function (a, c) {
                        return typeof a == 'function'
                            ? new Ve(this)
                            : this.map(function (p) {
                                  return Ss(p, a, c);
                              });
                    })),
                    (Ve.prototype.reject = function (a) {
                        return this.filter(ul(ye(a)));
                    }),
                    (Ve.prototype.slice = function (a, c) {
                        a = Ie(a);
                        var p = this;
                        return p.__filtered__ && (a > 0 || c < 0)
                            ? new Ve(p)
                            : (a < 0 ? (p = p.takeRight(-a)) : a && (p = p.drop(a)),
                              c !== t && ((c = Ie(c)), (p = c < 0 ? p.dropRight(-c) : p.take(c - a))),
                              p);
                    }),
                    (Ve.prototype.takeRightWhile = function (a) {
                        return this.reverse().takeWhile(a).reverse();
                    }),
                    (Ve.prototype.toArray = function () {
                        return this.take(V);
                    }),
                    cr(Ve.prototype, function (a, c) {
                        var p = /^(?:filter|find|map|reject)|While$/.test(c),
                            g = /^(?:head|last)$/.test(c),
                            E = w[g ? 'take' + (c == 'last' ? 'Right' : '') : c],
                            _ = g || /^find/.test(c);
                        E &&
                            (w.prototype[c] = function () {
                                var M = this.__wrapped__,
                                    A = g ? [1] : arguments,
                                    k = M instanceof Ve,
                                    U = A[0],
                                    W = k || Ne(M),
                                    G = function ($e) {
                                        var Ye = E.apply(w, Zr([$e], A));
                                        return g && te ? Ye[0] : Ye;
                                    };
                                W && p && typeof U == 'function' && U.length != 1 && (k = W = !1);
                                var te = this.__chain__,
                                    de = !!this.__actions__.length,
                                    ve = _ && !te,
                                    Pe = k && !de;
                                if (!_ && W) {
                                    M = Pe ? M : new Ve(this);
                                    var we = a.apply(M, A);
                                    return we.__actions__.push({ func: sl, args: [G], thisArg: t }), new Ln(we, te);
                                }
                                return ve && Pe
                                    ? a.apply(this, A)
                                    : ((we = this.thru(G)), ve ? (g ? we.value()[0] : we.value()) : we);
                            });
                    }),
                    Rn(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (a) {
                        var c = Ra[a],
                            p = /^(?:push|sort|unshift)$/.test(a) ? 'tap' : 'thru',
                            g = /^(?:pop|shift)$/.test(a);
                        w.prototype[a] = function () {
                            var E = arguments;
                            if (g && !this.__chain__) {
                                var _ = this.value();
                                return c.apply(Ne(_) ? _ : [], E);
                            }
                            return this[p](function (M) {
                                return c.apply(Ne(M) ? M : [], E);
                            });
                        };
                    }),
                    cr(Ve.prototype, function (a, c) {
                        var p = w[c];
                        if (p) {
                            var g = p.name + '';
                            et.call(Mo, g) || (Mo[g] = []), Mo[g].push({ name: c, func: p });
                        }
                    }),
                    (Mo[Qa(t, v).name] = [{ name: 'wrapper', func: t }]),
                    (Ve.prototype.clone = oT),
                    (Ve.prototype.reverse = sT),
                    (Ve.prototype.value = aT),
                    (w.prototype.at = PA),
                    (w.prototype.chain = BA),
                    (w.prototype.commit = FA),
                    (w.prototype.next = HA),
                    (w.prototype.plant = $A),
                    (w.prototype.reverse = UA),
                    (w.prototype.toJSON = w.prototype.valueOf = w.prototype.value = WA),
                    (w.prototype.first = w.prototype.head),
                    bs && (w.prototype[bs] = zA),
                    w
                );
            },
            Qr = F1();
        typeof define == 'function' && typeof define.amd == 'object' && define.amd
            ? ((Ft._ = Qr),
              define(function () {
                  return Qr;
              }))
            : Ci
              ? (((Ci.exports = Qr)._ = Qr), (zu._ = Qr))
              : (Ft._ = Qr);
    }).call(ps);
});
function tn(t) {
    this.content = t;
}
tn.prototype = {
    constructor: tn,
    find: function (t) {
        for (var e = 0; e < this.content.length; e += 2) if (this.content[e] === t) return e;
        return -1;
    },
    get: function (t) {
        var e = this.find(t);
        return e == -1 ? void 0 : this.content[e + 1];
    },
    update: function (t, e, n) {
        var r = n && n != t ? this.remove(n) : this,
            i = r.find(t),
            o = r.content.slice();
        return i == -1 ? o.push(n || t, e) : ((o[i + 1] = e), n && (o[i] = n)), new tn(o);
    },
    remove: function (t) {
        var e = this.find(t);
        if (e == -1) return this;
        var n = this.content.slice();
        return n.splice(e, 2), new tn(n);
    },
    addToStart: function (t, e) {
        return new tn([t, e].concat(this.remove(t).content));
    },
    addToEnd: function (t, e) {
        var n = this.remove(t).content.slice();
        return n.push(t, e), new tn(n);
    },
    addBefore: function (t, e, n) {
        var r = this.remove(e),
            i = r.content.slice(),
            o = r.find(t);
        return i.splice(o == -1 ? i.length : o, 0, e, n), new tn(i);
    },
    forEach: function (t) {
        for (var e = 0; e < this.content.length; e += 2) t(this.content[e], this.content[e + 1]);
    },
    prepend: function (t) {
        return (t = tn.from(t)), t.size ? new tn(t.content.concat(this.subtract(t).content)) : this;
    },
    append: function (t) {
        return (t = tn.from(t)), t.size ? new tn(this.subtract(t).content.concat(t.content)) : this;
    },
    subtract: function (t) {
        var e = this;
        t = tn.from(t);
        for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n]);
        return e;
    },
    toObject: function () {
        var t = {};
        return (
            this.forEach(function (e, n) {
                t[e] = n;
            }),
            t
        );
    },
    get size() {
        return this.content.length >> 1;
    },
};
tn.from = function (t) {
    if (t instanceof tn) return t;
    var e = [];
    if (t) for (var n in t) e.push(n, t[n]);
    return new tn(e);
};
var qd = tn;
function hy(t, e, n) {
    for (let r = 0; ; r++) {
        if (r == t.childCount || r == e.childCount) return t.childCount == e.childCount ? null : n;
        let i = t.child(r),
            o = e.child(r);
        if (i == o) {
            n += i.nodeSize;
            continue;
        }
        if (!i.sameMarkup(o)) return n;
        if (i.isText && i.text != o.text) {
            for (let s = 0; i.text[s] == o.text[s]; s++) n++;
            return n;
        }
        if (i.content.size || o.content.size) {
            let s = hy(i.content, o.content, n + 1);
            if (s != null) return s;
        }
        n += i.nodeSize;
    }
}
function my(t, e, n, r) {
    for (let i = t.childCount, o = e.childCount; ; ) {
        if (i == 0 || o == 0) return i == o ? null : { a: n, b: r };
        let s = t.child(--i),
            l = e.child(--o),
            u = s.nodeSize;
        if (s == l) {
            (n -= u), (r -= u);
            continue;
        }
        if (!s.sameMarkup(l)) return { a: n, b: r };
        if (s.isText && s.text != l.text) {
            let d = 0,
                f = Math.min(s.text.length, l.text.length);
            for (; d < f && s.text[s.text.length - d - 1] == l.text[l.text.length - d - 1]; ) d++, n--, r--;
            return { a: n, b: r };
        }
        if (s.content.size || l.content.size) {
            let d = my(s.content, l.content, n - 1, r - 1);
            if (d) return d;
        }
        (n -= u), (r -= u);
    }
}
var K = class t {
    constructor(e, n) {
        if (((this.content = e), (this.size = n || 0), n == null))
            for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
    }
    nodesBetween(e, n, r, i = 0, o) {
        for (let s = 0, l = 0; l < n; s++) {
            let u = this.content[s],
                d = l + u.nodeSize;
            if (d > e && r(u, i + l, o || null, s) !== !1 && u.content.size) {
                let f = l + 1;
                u.nodesBetween(Math.max(0, e - f), Math.min(u.content.size, n - f), r, i + f);
            }
            l = d;
        }
    }
    descendants(e) {
        this.nodesBetween(0, this.size, e);
    }
    textBetween(e, n, r, i) {
        let o = '',
            s = !0;
        return (
            this.nodesBetween(
                e,
                n,
                (l, u) => {
                    let d = l.isText
                        ? l.text.slice(Math.max(e, u) - u, n - u)
                        : l.isLeaf
                          ? i
                              ? typeof i == 'function'
                                  ? i(l)
                                  : i
                              : l.type.spec.leafText
                                ? l.type.spec.leafText(l)
                                : ''
                          : '';
                    l.isBlock && ((l.isLeaf && d) || l.isTextblock) && r && (s ? (s = !1) : (o += r)), (o += d);
                },
                0,
            ),
            o
        );
    }
    append(e) {
        if (!e.size) return this;
        if (!this.size) return e;
        let n = this.lastChild,
            r = e.firstChild,
            i = this.content.slice(),
            o = 0;
        for (
            n.isText && n.sameMarkup(r) && ((i[i.length - 1] = n.withText(n.text + r.text)), (o = 1));
            o < e.content.length;
            o++
        )
            i.push(e.content[o]);
        return new t(i, this.size + e.size);
    }
    cut(e, n = this.size) {
        if (e == 0 && n == this.size) return this;
        let r = [],
            i = 0;
        if (n > e)
            for (let o = 0, s = 0; s < n; o++) {
                let l = this.content[o],
                    u = s + l.nodeSize;
                u > e &&
                    ((s < e || u > n) &&
                        (l.isText
                            ? (l = l.cut(Math.max(0, e - s), Math.min(l.text.length, n - s)))
                            : (l = l.cut(Math.max(0, e - s - 1), Math.min(l.content.size, n - s - 1)))),
                    r.push(l),
                    (i += l.nodeSize)),
                    (s = u);
            }
        return new t(r, i);
    }
    cutByIndex(e, n) {
        return e == n ? t.empty : e == 0 && n == this.content.length ? this : new t(this.content.slice(e, n));
    }
    replaceChild(e, n) {
        let r = this.content[e];
        if (r == n) return this;
        let i = this.content.slice(),
            o = this.size + n.nodeSize - r.nodeSize;
        return (i[e] = n), new t(i, o);
    }
    addToStart(e) {
        return new t([e].concat(this.content), this.size + e.nodeSize);
    }
    addToEnd(e) {
        return new t(this.content.concat(e), this.size + e.nodeSize);
    }
    eq(e) {
        if (this.content.length != e.content.length) return !1;
        for (let n = 0; n < this.content.length; n++) if (!this.content[n].eq(e.content[n])) return !1;
        return !0;
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null;
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
    }
    get childCount() {
        return this.content.length;
    }
    child(e) {
        let n = this.content[e];
        if (!n) throw new RangeError('Index ' + e + ' out of range for ' + this);
        return n;
    }
    maybeChild(e) {
        return this.content[e] || null;
    }
    forEach(e) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let i = this.content[n];
            e(i, r, n), (r += i.nodeSize);
        }
    }
    findDiffStart(e, n = 0) {
        return hy(this, e, n);
    }
    findDiffEnd(e, n = this.size, r = e.size) {
        return my(this, e, n, r);
    }
    findIndex(e, n = -1) {
        if (e == 0) return hl(0, e);
        if (e == this.size) return hl(this.content.length, e);
        if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let r = 0, i = 0; ; r++) {
            let o = this.child(r),
                s = i + o.nodeSize;
            if (s >= e) return s == e || n > 0 ? hl(r + 1, s) : hl(r, i);
            i = s;
        }
    }
    toString() {
        return '<' + this.toStringInner() + '>';
    }
    toStringInner() {
        return this.content.join(', ');
    }
    toJSON() {
        return this.content.length ? this.content.map((e) => e.toJSON()) : null;
    }
    static fromJSON(e, n) {
        if (!n) return t.empty;
        if (!Array.isArray(n)) throw new RangeError('Invalid input for Fragment.fromJSON');
        return new t(n.map(e.nodeFromJSON));
    }
    static fromArray(e) {
        if (!e.length) return t.empty;
        let n,
            r = 0;
        for (let i = 0; i < e.length; i++) {
            let o = e[i];
            (r += o.nodeSize),
                i && o.isText && e[i - 1].sameMarkup(o)
                    ? (n || (n = e.slice(0, i)), (n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)))
                    : n && n.push(o);
        }
        return new t(n || e, r);
    }
    static from(e) {
        if (!e) return t.empty;
        if (e instanceof t) return e;
        if (Array.isArray(e)) return this.fromArray(e);
        if (e.attrs) return new t([e], e.nodeSize);
        throw new RangeError(
            'Can not convert ' +
                e +
                ' to a Fragment' +
                (e.nodesBetween ? ' (looks like multiple versions of prosemirror-model were loaded)' : ''),
        );
    }
};
K.empty = new K([], 0);
var Yd = { index: 0, offset: 0 };
function hl(t, e) {
    return (Yd.index = t), (Yd.offset = e), Yd;
}
function ml(t, e) {
    if (t === e) return !0;
    if (!(t && typeof t == 'object') || !(e && typeof e == 'object')) return !1;
    let n = Array.isArray(t);
    if (Array.isArray(e) != n) return !1;
    if (n) {
        if (t.length != e.length) return !1;
        for (let r = 0; r < t.length; r++) if (!ml(t[r], e[r])) return !1;
    } else {
        for (let r in t) if (!(r in e) || !ml(t[r], e[r])) return !1;
        for (let r in e) if (!(r in t)) return !1;
    }
    return !0;
}
var Je = class t {
    constructor(e, n) {
        (this.type = e), (this.attrs = n);
    }
    addToSet(e) {
        let n,
            r = !1;
        for (let i = 0; i < e.length; i++) {
            let o = e[i];
            if (this.eq(o)) return e;
            if (this.type.excludes(o.type)) n || (n = e.slice(0, i));
            else {
                if (o.type.excludes(this.type)) return e;
                !r && o.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), (r = !0)),
                    n && n.push(o);
            }
        }
        return n || (n = e.slice()), r || n.push(this), n;
    }
    removeFromSet(e) {
        for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
        return e;
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
        return !1;
    }
    eq(e) {
        return this == e || (this.type == e.type && ml(this.attrs, e.attrs));
    }
    toJSON() {
        let e = { type: this.type.name };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break;
        }
        return e;
    }
    static fromJSON(e, n) {
        if (!n) throw new RangeError('Invalid input for Mark.fromJSON');
        let r = e.marks[n.type];
        if (!r) throw new RangeError(`There is no mark type ${n.type} in this schema`);
        return r.create(n.attrs);
    }
    static sameSet(e, n) {
        if (e == n) return !0;
        if (e.length != n.length) return !1;
        for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
        return !0;
    }
    static setFrom(e) {
        if (!e || (Array.isArray(e) && e.length == 0)) return t.none;
        if (e instanceof t) return [e];
        let n = e.slice();
        return n.sort((r, i) => r.type.rank - i.type.rank), n;
    }
};
Je.none = [];
var Hi = class extends Error {},
    X = class t {
        constructor(e, n, r) {
            (this.content = e), (this.openStart = n), (this.openEnd = r);
        }
        get size() {
            return this.content.size - this.openStart - this.openEnd;
        }
        insertAt(e, n) {
            let r = by(this.content, e + this.openStart, n);
            return r && new t(r, this.openStart, this.openEnd);
        }
        removeBetween(e, n) {
            return new t(gy(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
        }
        eq(e) {
            return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
        }
        toString() {
            return this.content + '(' + this.openStart + ',' + this.openEnd + ')';
        }
        toJSON() {
            if (!this.content.size) return null;
            let e = { content: this.content.toJSON() };
            return (
                this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e
            );
        }
        static fromJSON(e, n) {
            if (!n) return t.empty;
            let r = n.openStart || 0,
                i = n.openEnd || 0;
            if (typeof r != 'number' || typeof i != 'number') throw new RangeError('Invalid input for Slice.fromJSON');
            return new t(K.fromJSON(e, n.content), r, i);
        }
        static maxOpen(e, n = !0) {
            let r = 0,
                i = 0;
            for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild) r++;
            for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild) i++;
            return new t(e, r, i);
        }
    };
X.empty = new X(K.empty, 0, 0);
function gy(t, e, n) {
    let { index: r, offset: i } = t.findIndex(e),
        o = t.maybeChild(r),
        { index: s, offset: l } = t.findIndex(n);
    if (i == e || o.isText) {
        if (l != n && !t.child(s).isText) throw new RangeError('Removing non-flat range');
        return t.cut(0, e).append(t.cut(n));
    }
    if (r != s) throw new RangeError('Removing non-flat range');
    return t.replaceChild(r, o.copy(gy(o.content, e - i - 1, n - i - 1)));
}
function by(t, e, n, r) {
    let { index: i, offset: o } = t.findIndex(e),
        s = t.maybeChild(i);
    if (o == e || s.isText) return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
    let l = by(s.content, e - o - 1, n);
    return l && t.replaceChild(i, s.copy(l));
}
function jN(t, e, n) {
    if (n.openStart > t.depth) throw new Hi('Inserted content deeper than insertion position');
    if (t.depth - n.openStart != e.depth - n.openEnd) throw new Hi('Inconsistent open depths');
    return yy(t, e, n, 0);
}
function yy(t, e, n, r) {
    let i = t.index(r),
        o = t.node(r);
    if (i == e.index(r) && r < t.depth - n.openStart) {
        let s = yy(t, e, n, r + 1);
        return o.copy(o.content.replaceChild(i, s));
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
            let s = t.parent,
                l = s.content;
            return Fi(s, l.cut(0, t.parentOffset).append(n.content).append(l.cut(e.parentOffset)));
        } else {
            let { start: s, end: l } = QN(n, t);
            return Fi(o, vy(t, s, l, e, r));
        }
    else return Fi(o, gl(t, e, r));
}
function Ey(t, e) {
    if (!e.type.compatibleContent(t.type)) throw new Hi('Cannot join ' + e.type.name + ' onto ' + t.type.name);
}
function jd(t, e, n) {
    let r = t.node(n);
    return Ey(r, e.node(n)), r;
}
function Bi(t, e) {
    let n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n]) ? (e[n] = t.withText(e[n].text + t.text)) : e.push(t);
}
function Os(t, e, n, r) {
    let i = (e || t).node(n),
        o = 0,
        s = e ? e.index(n) : i.childCount;
    t && ((o = t.index(n)), t.depth > n ? o++ : t.textOffset && (Bi(t.nodeAfter, r), o++));
    for (let l = o; l < s; l++) Bi(i.child(l), r);
    e && e.depth == n && e.textOffset && Bi(e.nodeBefore, r);
}
function Fi(t, e) {
    return t.type.checkContent(e), t.copy(e);
}
function vy(t, e, n, r, i) {
    let o = t.depth > i && jd(t, e, i + 1),
        s = r.depth > i && jd(n, r, i + 1),
        l = [];
    return (
        Os(null, t, i, l),
        o && s && e.index(i) == n.index(i)
            ? (Ey(o, s), Bi(Fi(o, vy(t, e, n, r, i + 1)), l))
            : (o && Bi(Fi(o, gl(t, e, i + 1)), l), Os(e, n, i, l), s && Bi(Fi(s, gl(n, r, i + 1)), l)),
        Os(r, null, i, l),
        new K(l)
    );
}
function gl(t, e, n) {
    let r = [];
    if ((Os(null, t, n, r), t.depth > n)) {
        let i = jd(t, e, n + 1);
        Bi(Fi(i, gl(t, e, n + 1)), r);
    }
    return Os(e, null, n, r), new K(r);
}
function QN(t, e) {
    let n = e.depth - t.openStart,
        i = e.node(n).copy(t.content);
    for (let o = n - 1; o >= 0; o--) i = e.node(o).copy(K.from(i));
    return { start: i.resolveNoCache(t.openStart + n), end: i.resolveNoCache(i.content.size - t.openEnd - n) };
}
var bl = class t {
        constructor(e, n, r) {
            (this.pos = e), (this.path = n), (this.parentOffset = r), (this.depth = n.length / 3 - 1);
        }
        resolveDepth(e) {
            return e == null ? this.depth : e < 0 ? this.depth + e : e;
        }
        get parent() {
            return this.node(this.depth);
        }
        get doc() {
            return this.node(0);
        }
        node(e) {
            return this.path[this.resolveDepth(e) * 3];
        }
        index(e) {
            return this.path[this.resolveDepth(e) * 3 + 1];
        }
        indexAfter(e) {
            return (e = this.resolveDepth(e)), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
        }
        start(e) {
            return (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
        }
        end(e) {
            return (e = this.resolveDepth(e)), this.start(e) + this.node(e).content.size;
        }
        before(e) {
            if (((e = this.resolveDepth(e)), !e))
                throw new RangeError('There is no position before the top-level node');
            return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
        }
        after(e) {
            if (((e = this.resolveDepth(e)), !e)) throw new RangeError('There is no position after the top-level node');
            return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
        }
        get textOffset() {
            return this.pos - this.path[this.path.length - 1];
        }
        get nodeAfter() {
            let e = this.parent,
                n = this.index(this.depth);
            if (n == e.childCount) return null;
            let r = this.pos - this.path[this.path.length - 1],
                i = e.child(n);
            return r ? e.child(n).cut(r) : i;
        }
        get nodeBefore() {
            let e = this.index(this.depth),
                n = this.pos - this.path[this.path.length - 1];
            return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
        }
        posAtIndex(e, n) {
            n = this.resolveDepth(n);
            let r = this.path[n * 3],
                i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
            for (let o = 0; o < e; o++) i += r.child(o).nodeSize;
            return i;
        }
        marks() {
            let e = this.parent,
                n = this.index();
            if (e.content.size == 0) return Je.none;
            if (this.textOffset) return e.child(n).marks;
            let r = e.maybeChild(n - 1),
                i = e.maybeChild(n);
            if (!r) {
                let l = r;
                (r = i), (i = l);
            }
            let o = r.marks;
            for (var s = 0; s < o.length; s++)
                o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
            return o;
        }
        marksAcross(e) {
            let n = this.parent.maybeChild(this.index());
            if (!n || !n.isInline) return null;
            let r = n.marks,
                i = e.parent.maybeChild(e.index());
            for (var o = 0; o < r.length; o++)
                r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
            return r;
        }
        sharedDepth(e) {
            for (let n = this.depth; n > 0; n--) if (this.start(n) <= e && this.end(n) >= e) return n;
            return 0;
        }
        blockRange(e = this, n) {
            if (e.pos < this.pos) return e.blockRange(this);
            for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
                if (e.pos <= this.end(r) && (!n || n(this.node(r)))) return new zi(this, e, r);
            return null;
        }
        sameParent(e) {
            return this.pos - this.parentOffset == e.pos - e.parentOffset;
        }
        max(e) {
            return e.pos > this.pos ? e : this;
        }
        min(e) {
            return e.pos < this.pos ? e : this;
        }
        toString() {
            let e = '';
            for (let n = 1; n <= this.depth; n++)
                e += (e ? '/' : '') + this.node(n).type.name + '_' + this.index(n - 1);
            return e + ':' + this.parentOffset;
        }
        static resolve(e, n) {
            if (!(n >= 0 && n <= e.content.size)) throw new RangeError('Position ' + n + ' out of range');
            let r = [],
                i = 0,
                o = n;
            for (let s = e; ; ) {
                let { index: l, offset: u } = s.content.findIndex(o),
                    d = o - u;
                if ((r.push(s, l, i + u), !d || ((s = s.child(l)), s.isText))) break;
                (o = d - 1), (i += u + 1);
            }
            return new t(n, r, o);
        }
        static resolveCached(e, n) {
            for (let i = 0; i < Jd.length; i++) {
                let o = Jd[i];
                if (o.pos == n && o.doc == e) return o;
            }
            let r = (Jd[Xd] = t.resolve(e, n));
            return (Xd = (Xd + 1) % eO), r;
        }
    },
    Jd = [],
    Xd = 0,
    eO = 12,
    zi = class {
        constructor(e, n, r) {
            (this.$from = e), (this.$to = n), (this.depth = r);
        }
        get start() {
            return this.$from.before(this.depth + 1);
        }
        get end() {
            return this.$to.after(this.depth + 1);
        }
        get parent() {
            return this.$from.node(this.depth);
        }
        get startIndex() {
            return this.$from.index(this.depth);
        }
        get endIndex() {
            return this.$to.indexAfter(this.depth);
        }
    },
    tO = Object.create(null),
    er = class t {
        constructor(e, n, r, i = Je.none) {
            (this.type = e), (this.attrs = n), (this.marks = i), (this.content = r || K.empty);
        }
        get nodeSize() {
            return this.isLeaf ? 1 : 2 + this.content.size;
        }
        get childCount() {
            return this.content.childCount;
        }
        child(e) {
            return this.content.child(e);
        }
        maybeChild(e) {
            return this.content.maybeChild(e);
        }
        forEach(e) {
            this.content.forEach(e);
        }
        nodesBetween(e, n, r, i = 0) {
            this.content.nodesBetween(e, n, r, i, this);
        }
        descendants(e) {
            this.nodesBetween(0, this.content.size, e);
        }
        get textContent() {
            return this.isLeaf && this.type.spec.leafText
                ? this.type.spec.leafText(this)
                : this.textBetween(0, this.content.size, '');
        }
        textBetween(e, n, r, i) {
            return this.content.textBetween(e, n, r, i);
        }
        get firstChild() {
            return this.content.firstChild;
        }
        get lastChild() {
            return this.content.lastChild;
        }
        eq(e) {
            return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
        }
        sameMarkup(e) {
            return this.hasMarkup(e.type, e.attrs, e.marks);
        }
        hasMarkup(e, n, r) {
            return this.type == e && ml(this.attrs, n || e.defaultAttrs || tO) && Je.sameSet(this.marks, r || Je.none);
        }
        copy(e = null) {
            return e == this.content ? this : new t(this.type, this.attrs, e, this.marks);
        }
        mark(e) {
            return e == this.marks ? this : new t(this.type, this.attrs, this.content, e);
        }
        cut(e, n = this.content.size) {
            return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
        }
        slice(e, n = this.content.size, r = !1) {
            if (e == n) return X.empty;
            let i = this.resolve(e),
                o = this.resolve(n),
                s = r ? 0 : i.sharedDepth(n),
                l = i.start(s),
                d = i.node(s).content.cut(i.pos - l, o.pos - l);
            return new X(d, i.depth - s, o.depth - s);
        }
        replace(e, n, r) {
            return jN(this.resolve(e), this.resolve(n), r);
        }
        nodeAt(e) {
            for (let n = this; ; ) {
                let { index: r, offset: i } = n.content.findIndex(e);
                if (((n = n.maybeChild(r)), !n)) return null;
                if (i == e || n.isText) return n;
                e -= i + 1;
            }
        }
        childAfter(e) {
            let { index: n, offset: r } = this.content.findIndex(e);
            return { node: this.content.maybeChild(n), index: n, offset: r };
        }
        childBefore(e) {
            if (e == 0) return { node: null, index: 0, offset: 0 };
            let { index: n, offset: r } = this.content.findIndex(e);
            if (r < e) return { node: this.content.child(n), index: n, offset: r };
            let i = this.content.child(n - 1);
            return { node: i, index: n - 1, offset: r - i.nodeSize };
        }
        resolve(e) {
            return bl.resolveCached(this, e);
        }
        resolveNoCache(e) {
            return bl.resolve(this, e);
        }
        rangeHasMark(e, n, r) {
            let i = !1;
            return n > e && this.nodesBetween(e, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
        }
        get isBlock() {
            return this.type.isBlock;
        }
        get isTextblock() {
            return this.type.isTextblock;
        }
        get inlineContent() {
            return this.type.inlineContent;
        }
        get isInline() {
            return this.type.isInline;
        }
        get isText() {
            return this.type.isText;
        }
        get isLeaf() {
            return this.type.isLeaf;
        }
        get isAtom() {
            return this.type.isAtom;
        }
        toString() {
            if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
            let e = this.type.name;
            return this.content.size && (e += '(' + this.content.toStringInner() + ')'), wy(this.marks, e);
        }
        contentMatchAt(e) {
            let n = this.type.contentMatch.matchFragment(this.content, 0, e);
            if (!n) throw new Error('Called contentMatchAt on a node with invalid content');
            return n;
        }
        canReplace(e, n, r = K.empty, i = 0, o = r.childCount) {
            let s = this.contentMatchAt(e).matchFragment(r, i, o),
                l = s && s.matchFragment(this.content, n);
            if (!l || !l.validEnd) return !1;
            for (let u = i; u < o; u++) if (!this.type.allowsMarks(r.child(u).marks)) return !1;
            return !0;
        }
        canReplaceWith(e, n, r, i) {
            if (i && !this.type.allowsMarks(i)) return !1;
            let o = this.contentMatchAt(e).matchType(r),
                s = o && o.matchFragment(this.content, n);
            return s ? s.validEnd : !1;
        }
        canAppend(e) {
            return e.content.size
                ? this.canReplace(this.childCount, this.childCount, e.content)
                : this.type.compatibleContent(e.type);
        }
        check() {
            this.type.checkContent(this.content);
            let e = Je.none;
            for (let n = 0; n < this.marks.length; n++) e = this.marks[n].addToSet(e);
            if (!Je.sameSet(e, this.marks))
                throw new RangeError(
                    `Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`,
                );
            this.content.forEach((n) => n.check());
        }
        toJSON() {
            let e = { type: this.type.name };
            for (let n in this.attrs) {
                e.attrs = this.attrs;
                break;
            }
            return (
                this.content.size && (e.content = this.content.toJSON()),
                this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
                e
            );
        }
        static fromJSON(e, n) {
            if (!n) throw new RangeError('Invalid input for Node.fromJSON');
            let r = null;
            if (n.marks) {
                if (!Array.isArray(n.marks)) throw new RangeError('Invalid mark data for Node.fromJSON');
                r = n.marks.map(e.markFromJSON);
            }
            if (n.type == 'text') {
                if (typeof n.text != 'string') throw new RangeError('Invalid text node in JSON');
                return e.text(n.text, r);
            }
            let i = K.fromJSON(e, n.content);
            return e.nodeType(n.type).create(n.attrs, i, r);
        }
    };
er.prototype.text = void 0;
var Qd = class t extends er {
    constructor(e, n, r, i) {
        if ((super(e, n, null, i), !r)) throw new RangeError('Empty text nodes are not allowed');
        this.text = r;
    }
    toString() {
        return this.type.spec.toDebugString
            ? this.type.spec.toDebugString(this)
            : wy(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
        return this.text;
    }
    textBetween(e, n) {
        return this.text.slice(e, n);
    }
    get nodeSize() {
        return this.text.length;
    }
    mark(e) {
        return e == this.marks ? this : new t(this.type, this.attrs, this.text, e);
    }
    withText(e) {
        return e == this.text ? this : new t(this.type, this.attrs, e, this.marks);
    }
    cut(e = 0, n = this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
    }
    eq(e) {
        return this.sameMarkup(e) && this.text == e.text;
    }
    toJSON() {
        let e = super.toJSON();
        return (e.text = this.text), e;
    }
};
function wy(t, e) {
    for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + '(' + e + ')';
    return e;
}
var $i = class t {
    constructor(e) {
        (this.validEnd = e), (this.next = []), (this.wrapCache = []);
    }
    static parse(e, n) {
        let r = new ef(e, n);
        if (r.next == null) return t.empty;
        let i = xy(r);
        r.next && r.err('Unexpected trailing text');
        let o = lO(aO(i));
        return cO(o, r), o;
    }
    matchType(e) {
        for (let n = 0; n < this.next.length; n++) if (this.next[n].type == e) return this.next[n].next;
        return null;
    }
    matchFragment(e, n = 0, r = e.childCount) {
        let i = this;
        for (let o = n; i && o < r; o++) i = i.matchType(e.child(o).type);
        return i;
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
    }
    get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
            let { type: n } = this.next[e];
            if (!(n.isText || n.hasRequiredAttrs())) return n;
        }
        return null;
    }
    compatible(e) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < e.next.length; r++) if (this.next[n].type == e.next[r].type) return !0;
        return !1;
    }
    fillBefore(e, n = !1, r = 0) {
        let i = [this];
        function o(s, l) {
            let u = s.matchFragment(e, r);
            if (u && (!n || u.validEnd)) return K.from(l.map((d) => d.createAndFill()));
            for (let d = 0; d < s.next.length; d++) {
                let { type: f, next: h } = s.next[d];
                if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
                    i.push(h);
                    let m = o(h, l.concat(f));
                    if (m) return m;
                }
            }
            return null;
        }
        return o(this, []);
    }
    findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2) if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n), n;
    }
    computeWrapping(e) {
        let n = Object.create(null),
            r = [{ match: this, type: null, via: null }];
        for (; r.length; ) {
            let i = r.shift(),
                o = i.match;
            if (o.matchType(e)) {
                let s = [];
                for (let l = i; l.type; l = l.via) s.push(l.type);
                return s.reverse();
            }
            for (let s = 0; s < o.next.length; s++) {
                let { type: l, next: u } = o.next[s];
                !l.isLeaf &&
                    !l.hasRequiredAttrs() &&
                    !(l.name in n) &&
                    (!i.type || u.validEnd) &&
                    (r.push({ match: l.contentMatch, type: l, via: i }), (n[l.name] = !0));
            }
        }
        return null;
    }
    get edgeCount() {
        return this.next.length;
    }
    edge(e) {
        if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e];
    }
    toString() {
        let e = [];
        function n(r) {
            e.push(r);
            for (let i = 0; i < r.next.length; i++) e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
        }
        return (
            n(this),
            e.map((r, i) => {
                let o = i + (r.validEnd ? '*' : ' ') + ' ';
                for (let s = 0; s < r.next.length; s++)
                    o += (s ? ', ' : '') + r.next[s].type.name + '->' + e.indexOf(r.next[s].next);
                return o;
            }).join(`
`)
        );
    }
};
$i.empty = new $i(!0);
var ef = class {
    constructor(e, n) {
        (this.string = e),
            (this.nodeTypes = n),
            (this.inline = null),
            (this.pos = 0),
            (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
            this.tokens[this.tokens.length - 1] == '' && this.tokens.pop(),
            this.tokens[0] == '' && this.tokens.shift();
    }
    get next() {
        return this.tokens[this.pos];
    }
    eat(e) {
        return this.next == e && (this.pos++ || !0);
    }
    err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')");
    }
};
function xy(t) {
    let e = [];
    do e.push(nO(t));
    while (t.eat('|'));
    return e.length == 1 ? e[0] : { type: 'choice', exprs: e };
}
function nO(t) {
    let e = [];
    do e.push(rO(t));
    while (t.next && t.next != ')' && t.next != '|');
    return e.length == 1 ? e[0] : { type: 'seq', exprs: e };
}
function rO(t) {
    let e = sO(t);
    for (;;)
        if (t.eat('+')) e = { type: 'plus', expr: e };
        else if (t.eat('*')) e = { type: 'star', expr: e };
        else if (t.eat('?')) e = { type: 'opt', expr: e };
        else if (t.eat('{')) e = iO(t, e);
        else break;
    return e;
}
function ly(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    let e = Number(t.next);
    return t.pos++, e;
}
function iO(t, e) {
    let n = ly(t),
        r = n;
    return (
        t.eat(',') && (t.next != '}' ? (r = ly(t)) : (r = -1)),
        t.eat('}') || t.err('Unclosed braced range'),
        { type: 'range', min: n, max: r, expr: e }
    );
}
function oO(t, e) {
    let n = t.nodeTypes,
        r = n[e];
    if (r) return [r];
    let i = [];
    for (let o in n) {
        let s = n[o];
        s.groups.indexOf(e) > -1 && i.push(s);
    }
    return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function sO(t) {
    if (t.eat('(')) {
        let e = xy(t);
        return t.eat(')') || t.err('Missing closing paren'), e;
    } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
    else {
        let e = oO(t, t.next).map(
            (n) => (
                t.inline == null
                    ? (t.inline = n.isInline)
                    : t.inline != n.isInline && t.err('Mixing inline and block content'),
                { type: 'name', value: n }
            ),
        );
        return t.pos++, e.length == 1 ? e[0] : { type: 'choice', exprs: e };
    }
}
function aO(t) {
    let e = [[]];
    return i(o(t, 0), n()), e;
    function n() {
        return e.push([]) - 1;
    }
    function r(s, l, u) {
        let d = { term: u, to: l };
        return e[s].push(d), d;
    }
    function i(s, l) {
        s.forEach((u) => (u.to = l));
    }
    function o(s, l) {
        if (s.type == 'choice') return s.exprs.reduce((u, d) => u.concat(o(d, l)), []);
        if (s.type == 'seq')
            for (let u = 0; ; u++) {
                let d = o(s.exprs[u], l);
                if (u == s.exprs.length - 1) return d;
                i(d, (l = n()));
            }
        else if (s.type == 'star') {
            let u = n();
            return r(l, u), i(o(s.expr, u), u), [r(u)];
        } else if (s.type == 'plus') {
            let u = n();
            return i(o(s.expr, l), u), i(o(s.expr, u), u), [r(u)];
        } else {
            if (s.type == 'opt') return [r(l)].concat(o(s.expr, l));
            if (s.type == 'range') {
                let u = l;
                for (let d = 0; d < s.min; d++) {
                    let f = n();
                    i(o(s.expr, u), f), (u = f);
                }
                if (s.max == -1) i(o(s.expr, u), u);
                else
                    for (let d = s.min; d < s.max; d++) {
                        let f = n();
                        r(u, f), i(o(s.expr, u), f), (u = f);
                    }
                return [r(u)];
            } else {
                if (s.type == 'name') return [r(l, void 0, s.value)];
                throw new Error('Unknown expr type');
            }
        }
    }
}
function _y(t, e) {
    return e - t;
}
function cy(t, e) {
    let n = [];
    return r(e), n.sort(_y);
    function r(i) {
        let o = t[i];
        if (o.length == 1 && !o[0].term) return r(o[0].to);
        n.push(i);
        for (let s = 0; s < o.length; s++) {
            let { term: l, to: u } = o[s];
            !l && n.indexOf(u) == -1 && r(u);
        }
    }
}
function lO(t) {
    let e = Object.create(null);
    return n(cy(t, 0));
    function n(r) {
        let i = [];
        r.forEach((s) => {
            t[s].forEach(({ term: l, to: u }) => {
                if (!l) return;
                let d;
                for (let f = 0; f < i.length; f++) i[f][0] == l && (d = i[f][1]);
                cy(t, u).forEach((f) => {
                    d || i.push([l, (d = [])]), d.indexOf(f) == -1 && d.push(f);
                });
            });
        });
        let o = (e[r.join(',')] = new $i(r.indexOf(t.length - 1) > -1));
        for (let s = 0; s < i.length; s++) {
            let l = i[s][1].sort(_y);
            o.next.push({ type: i[s][0], next: e[l.join(',')] || n(l) });
        }
        return o;
    }
}
function cO(t, e) {
    for (let n = 0, r = [t]; n < r.length; n++) {
        let i = r[n],
            o = !i.validEnd,
            s = [];
        for (let l = 0; l < i.next.length; l++) {
            let { type: u, next: d } = i.next[l];
            s.push(u.name), o && !(u.isText || u.hasRequiredAttrs()) && (o = !1), r.indexOf(d) == -1 && r.push(d);
        }
        o &&
            e.err(
                'Only non-generatable nodes (' +
                    s.join(', ') +
                    ') in a required position (see https://prosemirror.net/docs/guide/#generatable)',
            );
    }
}
function Sy(t) {
    let e = Object.create(null);
    for (let n in t) {
        let r = t[n];
        if (!r.hasDefault) return null;
        e[n] = r.default;
    }
    return e;
}
function Ty(t, e) {
    let n = Object.create(null);
    for (let r in t) {
        let i = e && e[r];
        if (i === void 0) {
            let o = t[r];
            if (o.hasDefault) i = o.default;
            else throw new RangeError('No value supplied for attribute ' + r);
        }
        n[r] = i;
    }
    return n;
}
function My(t) {
    let e = Object.create(null);
    if (t) for (let n in t) e[n] = new tf(t[n]);
    return e;
}
var yl = class t {
        constructor(e, n, r) {
            (this.name = e),
                (this.schema = n),
                (this.spec = r),
                (this.markSet = null),
                (this.groups = r.group ? r.group.split(' ') : []),
                (this.attrs = My(r.attrs)),
                (this.defaultAttrs = Sy(this.attrs)),
                (this.contentMatch = null),
                (this.inlineContent = null),
                (this.isBlock = !(r.inline || e == 'text')),
                (this.isText = e == 'text');
        }
        get isInline() {
            return !this.isBlock;
        }
        get isTextblock() {
            return this.isBlock && this.inlineContent;
        }
        get isLeaf() {
            return this.contentMatch == $i.empty;
        }
        get isAtom() {
            return this.isLeaf || !!this.spec.atom;
        }
        get whitespace() {
            return this.spec.whitespace || (this.spec.code ? 'pre' : 'normal');
        }
        hasRequiredAttrs() {
            for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
            return !1;
        }
        compatibleContent(e) {
            return this == e || this.contentMatch.compatible(e.contentMatch);
        }
        computeAttrs(e) {
            return !e && this.defaultAttrs ? this.defaultAttrs : Ty(this.attrs, e);
        }
        create(e = null, n, r) {
            if (this.isText) throw new Error("NodeType.create can't construct text nodes");
            return new er(this, this.computeAttrs(e), K.from(n), Je.setFrom(r));
        }
        createChecked(e = null, n, r) {
            return (n = K.from(n)), this.checkContent(n), new er(this, this.computeAttrs(e), n, Je.setFrom(r));
        }
        createAndFill(e = null, n, r) {
            if (((e = this.computeAttrs(e)), (n = K.from(n)), n.size)) {
                let s = this.contentMatch.fillBefore(n);
                if (!s) return null;
                n = s.append(n);
            }
            let i = this.contentMatch.matchFragment(n),
                o = i && i.fillBefore(K.empty, !0);
            return o ? new er(this, e, n.append(o), Je.setFrom(r)) : null;
        }
        validContent(e) {
            let n = this.contentMatch.matchFragment(e);
            if (!n || !n.validEnd) return !1;
            for (let r = 0; r < e.childCount; r++) if (!this.allowsMarks(e.child(r).marks)) return !1;
            return !0;
        }
        checkContent(e) {
            if (!this.validContent(e))
                throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
        }
        allowsMarkType(e) {
            return this.markSet == null || this.markSet.indexOf(e) > -1;
        }
        allowsMarks(e) {
            if (this.markSet == null) return !0;
            for (let n = 0; n < e.length; n++) if (!this.allowsMarkType(e[n].type)) return !1;
            return !0;
        }
        allowedMarks(e) {
            if (this.markSet == null) return e;
            let n;
            for (let r = 0; r < e.length; r++)
                this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
            return n ? (n.length ? n : Je.none) : e;
        }
        static compile(e, n) {
            let r = Object.create(null);
            e.forEach((o, s) => (r[o] = new t(o, n, s)));
            let i = n.spec.topNode || 'doc';
            if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')");
            if (!r.text) throw new RangeError("Every schema needs a 'text' type");
            for (let o in r.text.attrs) throw new RangeError('The text node type should not have attributes');
            return r;
        }
    },
    tf = class {
        constructor(e) {
            (this.hasDefault = Object.prototype.hasOwnProperty.call(e, 'default')), (this.default = e.default);
        }
        get isRequired() {
            return !this.hasDefault;
        }
    },
    Is = class t {
        constructor(e, n, r, i) {
            (this.name = e),
                (this.rank = n),
                (this.schema = r),
                (this.spec = i),
                (this.attrs = My(i.attrs)),
                (this.excluded = null);
            let o = Sy(this.attrs);
            this.instance = o ? new Je(this, o) : null;
        }
        create(e = null) {
            return !e && this.instance ? this.instance : new Je(this, Ty(this.attrs, e));
        }
        static compile(e, n) {
            let r = Object.create(null),
                i = 0;
            return e.forEach((o, s) => (r[o] = new t(o, i++, n, s))), r;
        }
        removeFromSet(e) {
            for (var n = 0; n < e.length; n++) e[n].type == this && ((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
            return e;
        }
        isInSet(e) {
            for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
        }
        excludes(e) {
            return this.excluded.indexOf(e) > -1;
        }
    },
    El = class {
        constructor(e) {
            (this.linebreakReplacement = null), (this.cached = Object.create(null));
            let n = (this.spec = {});
            for (let i in e) n[i] = e[i];
            (n.nodes = qd.from(e.nodes)),
                (n.marks = qd.from(e.marks || {})),
                (this.nodes = yl.compile(this.spec.nodes, this)),
                (this.marks = Is.compile(this.spec.marks, this));
            let r = Object.create(null);
            for (let i in this.nodes) {
                if (i in this.marks) throw new RangeError(i + ' can not be both a node and a mark');
                let o = this.nodes[i],
                    s = o.spec.content || '',
                    l = o.spec.marks;
                if (
                    ((o.contentMatch = r[s] || (r[s] = $i.parse(s, this.nodes))),
                    (o.inlineContent = o.contentMatch.inlineContent),
                    o.spec.linebreakReplacement)
                ) {
                    if (this.linebreakReplacement) throw new RangeError('Multiple linebreak nodes defined');
                    if (!o.isInline || !o.isLeaf)
                        throw new RangeError('Linebreak replacement nodes must be inline leaf nodes');
                    this.linebreakReplacement = o;
                }
                o.markSet = l == '_' ? null : l ? uy(this, l.split(' ')) : l == '' || !o.inlineContent ? [] : null;
            }
            for (let i in this.marks) {
                let o = this.marks[i],
                    s = o.spec.excludes;
                o.excluded = s == null ? [o] : s == '' ? [] : uy(this, s.split(' '));
            }
            (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
                (this.markFromJSON = this.markFromJSON.bind(this)),
                (this.topNodeType = this.nodes[this.spec.topNode || 'doc']),
                (this.cached.wrappings = Object.create(null));
        }
        node(e, n = null, r, i) {
            if (typeof e == 'string') e = this.nodeType(e);
            else if (e instanceof yl) {
                if (e.schema != this) throw new RangeError('Node type from different schema used (' + e.name + ')');
            } else throw new RangeError('Invalid node type: ' + e);
            return e.createChecked(n, r, i);
        }
        text(e, n) {
            let r = this.nodes.text;
            return new Qd(r, r.defaultAttrs, e, Je.setFrom(n));
        }
        mark(e, n) {
            return typeof e == 'string' && (e = this.marks[e]), e.create(n);
        }
        nodeFromJSON(e) {
            return er.fromJSON(this, e);
        }
        markFromJSON(e) {
            return Je.fromJSON(this, e);
        }
        nodeType(e) {
            let n = this.nodes[e];
            if (!n) throw new RangeError('Unknown node type: ' + e);
            return n;
        }
    };
function uy(t, e) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let i = e[r],
            o = t.marks[i],
            s = o;
        if (o) n.push(o);
        else
            for (let l in t.marks) {
                let u = t.marks[l];
                (i == '_' || (u.spec.group && u.spec.group.split(' ').indexOf(i) > -1)) && n.push((s = u));
            }
        if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
    }
    return n;
}
function uO(t) {
    return t.tag != null;
}
function dO(t) {
    return t.style != null;
}
var Ui = class t {
        constructor(e, n) {
            (this.schema = e),
                (this.rules = n),
                (this.tags = []),
                (this.styles = []),
                n.forEach((r) => {
                    uO(r) ? this.tags.push(r) : dO(r) && this.styles.push(r);
                }),
                (this.normalizeLists = !this.tags.some((r) => {
                    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return !1;
                    let i = e.nodes[r.node];
                    return i.contentMatch.matchType(i);
                }));
        }
        parse(e, n = {}) {
            let r = new xl(this, n, !1);
            return r.addAll(e, n.from, n.to), r.finish();
        }
        parseSlice(e, n = {}) {
            let r = new xl(this, n, !0);
            return r.addAll(e, n.from, n.to), X.maxOpen(r.finish());
        }
        matchTag(e, n, r) {
            for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
                let o = this.tags[i];
                if (
                    hO(e, o.tag) &&
                    (o.namespace === void 0 || e.namespaceURI == o.namespace) &&
                    (!o.context || n.matchesContext(o.context))
                ) {
                    if (o.getAttrs) {
                        let s = o.getAttrs(e);
                        if (s === !1) continue;
                        o.attrs = s || void 0;
                    }
                    return o;
                }
            }
        }
        matchStyle(e, n, r, i) {
            for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
                let s = this.styles[o],
                    l = s.style;
                if (
                    !(
                        l.indexOf(e) != 0 ||
                        (s.context && !r.matchesContext(s.context)) ||
                        (l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != n))
                    )
                ) {
                    if (s.getAttrs) {
                        let u = s.getAttrs(n);
                        if (u === !1) continue;
                        s.attrs = u || void 0;
                    }
                    return s;
                }
            }
        }
        static schemaRules(e) {
            let n = [];
            function r(i) {
                let o = i.priority == null ? 50 : i.priority,
                    s = 0;
                for (; s < n.length; s++) {
                    let l = n[s];
                    if ((l.priority == null ? 50 : l.priority) < o) break;
                }
                n.splice(s, 0, i);
            }
            for (let i in e.marks) {
                let o = e.marks[i].spec.parseDOM;
                o &&
                    o.forEach((s) => {
                        r((s = fy(s))), s.mark || s.ignore || s.clearMark || (s.mark = i);
                    });
            }
            for (let i in e.nodes) {
                let o = e.nodes[i].spec.parseDOM;
                o &&
                    o.forEach((s) => {
                        r((s = fy(s))), s.node || s.ignore || s.mark || (s.node = i);
                    });
            }
            return n;
        }
        static fromSchema(e) {
            return e.cached.domParser || (e.cached.domParser = new t(e, t.schemaRules(e)));
        }
    },
    Ay = {
        address: !0,
        article: !0,
        aside: !0,
        blockquote: !0,
        canvas: !0,
        dd: !0,
        div: !0,
        dl: !0,
        fieldset: !0,
        figcaption: !0,
        figure: !0,
        footer: !0,
        form: !0,
        h1: !0,
        h2: !0,
        h3: !0,
        h4: !0,
        h5: !0,
        h6: !0,
        header: !0,
        hgroup: !0,
        hr: !0,
        li: !0,
        noscript: !0,
        ol: !0,
        output: !0,
        p: !0,
        pre: !0,
        section: !0,
        table: !0,
        tfoot: !0,
        ul: !0,
    },
    fO = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
    Cy = { ol: !0, ul: !0 },
    vl = 1,
    wl = 2,
    Rs = 4;
function dy(t, e, n) {
    return e != null ? (e ? vl : 0) | (e === 'full' ? wl : 0) : t && t.whitespace == 'pre' ? vl | wl : n & ~Rs;
}
var Io = class {
        constructor(e, n, r, i, o, s, l) {
            (this.type = e),
                (this.attrs = n),
                (this.marks = r),
                (this.pendingMarks = i),
                (this.solid = o),
                (this.options = l),
                (this.content = []),
                (this.activeMarks = Je.none),
                (this.stashMarks = []),
                (this.match = s || (l & Rs ? null : e.contentMatch));
        }
        findWrapping(e) {
            if (!this.match) {
                if (!this.type) return [];
                let n = this.type.contentMatch.fillBefore(K.from(e));
                if (n) this.match = this.type.contentMatch.matchFragment(n);
                else {
                    let r = this.type.contentMatch,
                        i;
                    return (i = r.findWrapping(e.type)) ? ((this.match = r), i) : null;
                }
            }
            return this.match.findWrapping(e.type);
        }
        finish(e) {
            if (!(this.options & vl)) {
                let r = this.content[this.content.length - 1],
                    i;
                if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                    let o = r;
                    r.text.length == i[0].length
                        ? this.content.pop()
                        : (this.content[this.content.length - 1] = o.withText(
                              o.text.slice(0, o.text.length - i[0].length),
                          ));
                }
            }
            let n = K.from(this.content);
            return (
                !e && this.match && (n = n.append(this.match.fillBefore(K.empty, !0))),
                this.type ? this.type.create(this.attrs, n, this.marks) : n
            );
        }
        popFromStashMark(e) {
            for (let n = this.stashMarks.length - 1; n >= 0; n--)
                if (e.eq(this.stashMarks[n])) return this.stashMarks.splice(n, 1)[0];
        }
        applyPending(e) {
            for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
                let i = r[n];
                (this.type ? this.type.allowsMarkType(i.type) : gO(i.type, e)) &&
                    !i.isInSet(this.activeMarks) &&
                    ((this.activeMarks = i.addToSet(this.activeMarks)),
                    (this.pendingMarks = i.removeFromSet(this.pendingMarks)));
            }
        }
        inlineContext(e) {
            return this.type
                ? this.type.inlineContent
                : this.content.length
                  ? this.content[0].isInline
                  : e.parentNode && !Ay.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
        }
    },
    xl = class {
        constructor(e, n, r) {
            (this.parser = e), (this.options = n), (this.isOpen = r), (this.open = 0);
            let i = n.topNode,
                o,
                s = dy(null, n.preserveWhitespace, 0) | (r ? Rs : 0);
            i
                ? (o = new Io(i.type, i.attrs, Je.none, Je.none, !0, n.topMatch || i.type.contentMatch, s))
                : r
                  ? (o = new Io(null, null, Je.none, Je.none, !0, null, s))
                  : (o = new Io(e.schema.topNodeType, null, Je.none, Je.none, !0, null, s)),
                (this.nodes = [o]),
                (this.find = n.findPositions),
                (this.needsBlock = !1);
        }
        get top() {
            return this.nodes[this.open];
        }
        addDOM(e) {
            e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e);
        }
        withStyleRules(e, n) {
            let r = e.getAttribute('style');
            if (!r) return n();
            let i = this.readStyles(mO(r));
            if (!i) return;
            let [o, s] = i,
                l = this.top;
            for (let u = 0; u < s.length; u++) this.removePendingMark(s[u], l);
            for (let u = 0; u < o.length; u++) this.addPendingMark(o[u]);
            n();
            for (let u = 0; u < o.length; u++) this.removePendingMark(o[u], l);
            for (let u = 0; u < s.length; u++) this.addPendingMark(s[u]);
        }
        addTextNode(e) {
            let n = e.nodeValue,
                r = this.top;
            if (r.options & wl || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
                if (r.options & vl)
                    r.options & wl
                        ? (n = n.replace(
                              /\r\n?/g,
                              `
`,
                          ))
                        : (n = n.replace(/\r?\n|\r/g, ' '));
                else if (
                    ((n = n.replace(/[ \t\r\n\u000c]+/g, ' ')),
                    /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1)
                ) {
                    let i = r.content[r.content.length - 1],
                        o = e.previousSibling;
                    (!i || (o && o.nodeName == 'BR') || (i.isText && /[ \t\r\n\u000c]$/.test(i.text))) &&
                        (n = n.slice(1));
                }
                n && this.insertNode(this.parser.schema.text(n)), this.findInText(e);
            } else this.findInside(e);
        }
        addElement(e, n) {
            let r = e.nodeName.toLowerCase(),
                i;
            Cy.hasOwnProperty(r) && this.parser.normalizeLists && pO(e);
            let o =
                (this.options.ruleFromNode && this.options.ruleFromNode(e)) || (i = this.parser.matchTag(e, this, n));
            if (o ? o.ignore : fO.hasOwnProperty(r)) this.findInside(e), this.ignoreFallback(e);
            else if (!o || o.skip || o.closeParent) {
                o && o.closeParent ? (this.open = Math.max(0, this.open - 1)) : o && o.skip.nodeType && (e = o.skip);
                let s,
                    l = this.top,
                    u = this.needsBlock;
                if (Ay.hasOwnProperty(r))
                    l.content.length && l.content[0].isInline && this.open && (this.open--, (l = this.top)),
                        (s = !0),
                        l.type || (this.needsBlock = !0);
                else if (!e.firstChild) {
                    this.leafFallback(e);
                    return;
                }
                o && o.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)),
                    s && this.sync(l),
                    (this.needsBlock = u);
            } else
                this.withStyleRules(e, () => {
                    this.addElementByRule(e, o, o.consuming === !1 ? i : void 0);
                });
        }
        leafFallback(e) {
            e.nodeName == 'BR' &&
                this.top.type &&
                this.top.type.inlineContent &&
                this.addTextNode(
                    e.ownerDocument.createTextNode(`
`),
                );
        }
        ignoreFallback(e) {
            e.nodeName == 'BR' &&
                (!this.top.type || !this.top.type.inlineContent) &&
                this.findPlace(this.parser.schema.text('-'));
        }
        readStyles(e) {
            let n = Je.none,
                r = Je.none;
            for (let i = 0; i < e.length; i += 2)
                for (let o = void 0; ; ) {
                    let s = this.parser.matchStyle(e[i], e[i + 1], this, o);
                    if (!s) break;
                    if (s.ignore) return null;
                    if (
                        (s.clearMark
                            ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((l) => {
                                  s.clearMark(l) && (r = l.addToSet(r));
                              })
                            : (n = this.parser.schema.marks[s.mark].create(s.attrs).addToSet(n)),
                        s.consuming === !1)
                    )
                        o = s;
                    else break;
                }
            return [n, r];
        }
        addElementByRule(e, n, r) {
            let i, o, s;
            n.node
                ? ((o = this.parser.schema.nodes[n.node]),
                  o.isLeaf
                      ? this.insertNode(o.create(n.attrs)) || this.leafFallback(e)
                      : (i = this.enter(o, n.attrs || null, n.preserveWhitespace)))
                : ((s = this.parser.schema.marks[n.mark].create(n.attrs)), this.addPendingMark(s));
            let l = this.top;
            if (o && o.isLeaf) this.findInside(e);
            else if (r) this.addElement(e, r);
            else if (n.getContent)
                this.findInside(e), n.getContent(e, this.parser.schema).forEach((u) => this.insertNode(u));
            else {
                let u = e;
                typeof n.contentElement == 'string'
                    ? (u = e.querySelector(n.contentElement))
                    : typeof n.contentElement == 'function'
                      ? (u = n.contentElement(e))
                      : n.contentElement && (u = n.contentElement),
                    this.findAround(e, u, !0),
                    this.addAll(u);
            }
            i && this.sync(l) && this.open--, s && this.removePendingMark(s, l);
        }
        addAll(e, n, r) {
            let i = n || 0;
            for (
                let o = n ? e.childNodes[n] : e.firstChild, s = r == null ? null : e.childNodes[r];
                o != s;
                o = o.nextSibling, ++i
            )
                this.findAtPoint(e, i), this.addDOM(o);
            this.findAtPoint(e, i);
        }
        findPlace(e) {
            let n, r;
            for (let i = this.open; i >= 0; i--) {
                let o = this.nodes[i],
                    s = o.findWrapping(e);
                if ((s && (!n || n.length > s.length) && ((n = s), (r = o), !s.length)) || o.solid) break;
            }
            if (!n) return !1;
            this.sync(r);
            for (let i = 0; i < n.length; i++) this.enterInner(n[i], null, !1);
            return !0;
        }
        insertNode(e) {
            if (e.isInline && this.needsBlock && !this.top.type) {
                let n = this.textblockFromContext();
                n && this.enterInner(n);
            }
            if (this.findPlace(e)) {
                this.closeExtra();
                let n = this.top;
                n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type));
                let r = n.activeMarks;
                for (let i = 0; i < e.marks.length; i++)
                    (!n.type || n.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
                return n.content.push(e.mark(r)), !0;
            }
            return !1;
        }
        enter(e, n, r) {
            let i = this.findPlace(e.create(n));
            return i && this.enterInner(e, n, !0, r), i;
        }
        enterInner(e, n = null, r = !1, i) {
            this.closeExtra();
            let o = this.top;
            o.applyPending(e), (o.match = o.match && o.match.matchType(e));
            let s = dy(e, i, o.options);
            o.options & Rs && o.content.length == 0 && (s |= Rs),
                this.nodes.push(new Io(e, n, o.activeMarks, o.pendingMarks, r, null, s)),
                this.open++;
        }
        closeExtra(e = !1) {
            let n = this.nodes.length - 1;
            if (n > this.open) {
                for (; n > this.open; n--) this.nodes[n - 1].content.push(this.nodes[n].finish(e));
                this.nodes.length = this.open + 1;
            }
        }
        finish() {
            return (
                (this.open = 0), this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen)
            );
        }
        sync(e) {
            for (let n = this.open; n >= 0; n--) if (this.nodes[n] == e) return (this.open = n), !0;
            return !1;
        }
        get currentPos() {
            this.closeExtra();
            let e = 0;
            for (let n = this.open; n >= 0; n--) {
                let r = this.nodes[n].content;
                for (let i = r.length - 1; i >= 0; i--) e += r[i].nodeSize;
                n && e++;
            }
            return e;
        }
        findAtPoint(e, n) {
            if (this.find)
                for (let r = 0; r < this.find.length; r++)
                    this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
        }
        findInside(e) {
            if (this.find)
                for (let n = 0; n < this.find.length; n++)
                    this.find[n].pos == null &&
                        e.nodeType == 1 &&
                        e.contains(this.find[n].node) &&
                        (this.find[n].pos = this.currentPos);
        }
        findAround(e, n, r) {
            if (e != n && this.find)
                for (let i = 0; i < this.find.length; i++)
                    this.find[i].pos == null &&
                        e.nodeType == 1 &&
                        e.contains(this.find[i].node) &&
                        n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) &&
                        (this.find[i].pos = this.currentPos);
        }
        findInText(e) {
            if (this.find)
                for (let n = 0; n < this.find.length; n++)
                    this.find[n].node == e &&
                        (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
        }
        matchesContext(e) {
            if (e.indexOf('|') > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this);
            let n = e.split('/'),
                r = this.options.context,
                i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
                o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1),
                s = (l, u) => {
                    for (; l >= 0; l--) {
                        let d = n[l];
                        if (d == '') {
                            if (l == n.length - 1 || l == 0) continue;
                            for (; u >= o; u--) if (s(l - 1, u)) return !0;
                            return !1;
                        } else {
                            let f =
                                u > 0 || (u == 0 && i) ? this.nodes[u].type : r && u >= o ? r.node(u - o).type : null;
                            if (!f || (f.name != d && f.groups.indexOf(d) == -1)) return !1;
                            u--;
                        }
                    }
                    return !0;
                };
            return s(n.length - 1, this.open);
        }
        textblockFromContext() {
            let e = this.options.context;
            if (e)
                for (let n = e.depth; n >= 0; n--) {
                    let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
                    if (r && r.isTextblock && r.defaultAttrs) return r;
                }
            for (let n in this.parser.schema.nodes) {
                let r = this.parser.schema.nodes[n];
                if (r.isTextblock && r.defaultAttrs) return r;
            }
        }
        addPendingMark(e) {
            let n = bO(e, this.top.pendingMarks);
            n && this.top.stashMarks.push(n), (this.top.pendingMarks = e.addToSet(this.top.pendingMarks));
        }
        removePendingMark(e, n) {
            for (let r = this.open; r >= 0; r--) {
                let i = this.nodes[r];
                if (i.pendingMarks.lastIndexOf(e) > -1) i.pendingMarks = e.removeFromSet(i.pendingMarks);
                else {
                    i.activeMarks = e.removeFromSet(i.activeMarks);
                    let s = i.popFromStashMark(e);
                    s && i.type && i.type.allowsMarkType(s.type) && (i.activeMarks = s.addToSet(i.activeMarks));
                }
                if (i == n) break;
            }
        }
    };
function pO(t) {
    for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && Cy.hasOwnProperty(r) && n ? (n.appendChild(e), (e = n)) : r == 'li' ? (n = e) : r && (n = null);
    }
}
function hO(t, e) {
    return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function mO(t) {
    let e = /\s*([\w-]+)\s*:\s*([^;]+)/g,
        n,
        r = [];
    for (; (n = e.exec(t)); ) r.push(n[1], n[2].trim());
    return r;
}
function fy(t) {
    let e = {};
    for (let n in t) e[n] = t[n];
    return e;
}
function gO(t, e) {
    let n = e.schema.nodes;
    for (let r in n) {
        let i = n[r];
        if (!i.allowsMarkType(t)) continue;
        let o = [],
            s = (l) => {
                o.push(l);
                for (let u = 0; u < l.edgeCount; u++) {
                    let { type: d, next: f } = l.edge(u);
                    if (d == e || (o.indexOf(f) < 0 && s(f))) return !0;
                }
            };
        if (s(i.contentMatch)) return !0;
    }
}
function bO(t, e) {
    for (let n = 0; n < e.length; n++) if (t.eq(e[n])) return e[n];
}
var Rr = class t {
    constructor(e, n) {
        (this.nodes = e), (this.marks = n);
    }
    serializeFragment(e, n = {}, r) {
        r || (r = Zd(n).createDocumentFragment());
        let i = r,
            o = [];
        return (
            e.forEach((s) => {
                if (o.length || s.marks.length) {
                    let l = 0,
                        u = 0;
                    for (; l < o.length && u < s.marks.length; ) {
                        let d = s.marks[u];
                        if (!this.marks[d.type.name]) {
                            u++;
                            continue;
                        }
                        if (!d.eq(o[l][0]) || d.type.spec.spanning === !1) break;
                        l++, u++;
                    }
                    for (; l < o.length; ) i = o.pop()[1];
                    for (; u < s.marks.length; ) {
                        let d = s.marks[u++],
                            f = this.serializeMark(d, s.isInline, n);
                        f && (o.push([d, i]), i.appendChild(f.dom), (i = f.contentDOM || f.dom));
                    }
                }
                i.appendChild(this.serializeNodeInner(s, n));
            }),
            r
        );
    }
    serializeNodeInner(e, n) {
        let { dom: r, contentDOM: i } = t.renderSpec(Zd(n), this.nodes[e.type.name](e));
        if (i) {
            if (e.isLeaf) throw new RangeError('Content hole not allowed in a leaf node spec');
            this.serializeFragment(e.content, n, i);
        }
        return r;
    }
    serializeNode(e, n = {}) {
        let r = this.serializeNodeInner(e, n);
        for (let i = e.marks.length - 1; i >= 0; i--) {
            let o = this.serializeMark(e.marks[i], e.isInline, n);
            o && ((o.contentDOM || o.dom).appendChild(r), (r = o.dom));
        }
        return r;
    }
    serializeMark(e, n, r = {}) {
        let i = this.marks[e.type.name];
        return i && t.renderSpec(Zd(r), i(e, n));
    }
    static renderSpec(e, n, r = null) {
        if (typeof n == 'string') return { dom: e.createTextNode(n) };
        if (n.nodeType != null) return { dom: n };
        if (n.dom && n.dom.nodeType != null) return n;
        let i = n[0],
            o = i.indexOf(' ');
        o > 0 && ((r = i.slice(0, o)), (i = i.slice(o + 1)));
        let s,
            l = r ? e.createElementNS(r, i) : e.createElement(i),
            u = n[1],
            d = 1;
        if (u && typeof u == 'object' && u.nodeType == null && !Array.isArray(u)) {
            d = 2;
            for (let f in u)
                if (u[f] != null) {
                    let h = f.indexOf(' ');
                    h > 0 ? l.setAttributeNS(f.slice(0, h), f.slice(h + 1), u[f]) : l.setAttribute(f, u[f]);
                }
        }
        for (let f = d; f < n.length; f++) {
            let h = n[f];
            if (h === 0) {
                if (f < n.length - 1 || f > d)
                    throw new RangeError('Content hole must be the only child of its parent node');
                return { dom: l, contentDOM: l };
            } else {
                let { dom: m, contentDOM: b } = t.renderSpec(e, h, r);
                if ((l.appendChild(m), b)) {
                    if (s) throw new RangeError('Multiple content holes');
                    s = b;
                }
            }
        }
        return { dom: l, contentDOM: s };
    }
    static fromSchema(e) {
        return (
            e.cached.domSerializer || (e.cached.domSerializer = new t(this.nodesFromSchema(e), this.marksFromSchema(e)))
        );
    }
    static nodesFromSchema(e) {
        let n = py(e.nodes);
        return n.text || (n.text = (r) => r.text), n;
    }
    static marksFromSchema(e) {
        return py(e.marks);
    }
};
function py(t) {
    let e = {};
    for (let n in t) {
        let r = t[n].spec.toDOM;
        r && (e[n] = r);
    }
    return e;
}
function Zd(t) {
    return t.document || window.document;
}
var Oy = 65535,
    Ry = Math.pow(2, 16);
function yO(t, e) {
    return t + e * Ry;
}
function ky(t) {
    return t & Oy;
}
function EO(t) {
    return (t - (t & Oy)) / Ry;
}
var Iy = 1,
    Ly = 2,
    _l = 4,
    Dy = 8,
    Ps = class {
        constructor(e, n, r) {
            (this.pos = e), (this.delInfo = n), (this.recover = r);
        }
        get deleted() {
            return (this.delInfo & Dy) > 0;
        }
        get deletedBefore() {
            return (this.delInfo & (Iy | _l)) > 0;
        }
        get deletedAfter() {
            return (this.delInfo & (Ly | _l)) > 0;
        }
        get deletedAcross() {
            return (this.delInfo & _l) > 0;
        }
    },
    Ir = class t {
        constructor(e, n = !1) {
            if (((this.ranges = e), (this.inverted = n), !e.length && t.empty)) return t.empty;
        }
        recover(e) {
            let n = 0,
                r = ky(e);
            if (!this.inverted) for (let i = 0; i < r; i++) n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
            return this.ranges[r * 3] + n + EO(e);
        }
        mapResult(e, n = 1) {
            return this._map(e, n, !1);
        }
        map(e, n = 1) {
            return this._map(e, n, !0);
        }
        _map(e, n, r) {
            let i = 0,
                o = this.inverted ? 2 : 1,
                s = this.inverted ? 1 : 2;
            for (let l = 0; l < this.ranges.length; l += 3) {
                let u = this.ranges[l] - (this.inverted ? i : 0);
                if (u > e) break;
                let d = this.ranges[l + o],
                    f = this.ranges[l + s],
                    h = u + d;
                if (e <= h) {
                    let m = d ? (e == u ? -1 : e == h ? 1 : n) : n,
                        b = u + i + (m < 0 ? 0 : f);
                    if (r) return b;
                    let y = e == (n < 0 ? u : h) ? null : yO(l / 3, e - u),
                        v = e == u ? Ly : e == h ? Iy : _l;
                    return (n < 0 ? e != u : e != h) && (v |= Dy), new Ps(b, v, y);
                }
                i += f - d;
            }
            return r ? e + i : new Ps(e + i, 0, null);
        }
        touches(e, n) {
            let r = 0,
                i = ky(n),
                o = this.inverted ? 2 : 1,
                s = this.inverted ? 1 : 2;
            for (let l = 0; l < this.ranges.length; l += 3) {
                let u = this.ranges[l] - (this.inverted ? r : 0);
                if (u > e) break;
                let d = this.ranges[l + o],
                    f = u + d;
                if (e <= f && l == i * 3) return !0;
                r += this.ranges[l + s] - d;
            }
            return !1;
        }
        forEach(e) {
            let n = this.inverted ? 2 : 1,
                r = this.inverted ? 1 : 2;
            for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
                let s = this.ranges[i],
                    l = s - (this.inverted ? o : 0),
                    u = s + (this.inverted ? 0 : o),
                    d = this.ranges[i + n],
                    f = this.ranges[i + r];
                e(l, l + d, u, u + f), (o += f - d);
            }
        }
        invert() {
            return new t(this.ranges, !this.inverted);
        }
        toString() {
            return (this.inverted ? '-' : '') + JSON.stringify(this.ranges);
        }
        static offset(e) {
            return e == 0 ? t.empty : new t(e < 0 ? [0, -e, 0] : [0, 0, e]);
        }
    };
Ir.empty = new Ir([]);
var Bs = class t {
        constructor(e = [], n, r = 0, i = e.length) {
            (this.maps = e), (this.mirror = n), (this.from = r), (this.to = i);
        }
        slice(e = 0, n = this.maps.length) {
            return new t(this.maps, this.mirror, e, n);
        }
        copy() {
            return new t(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
        }
        appendMap(e, n) {
            (this.to = this.maps.push(e)), n != null && this.setMirror(this.maps.length - 1, n);
        }
        appendMapping(e) {
            for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
                let i = e.getMirror(n);
                this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
            }
        }
        getMirror(e) {
            if (this.mirror) {
                for (let n = 0; n < this.mirror.length; n++)
                    if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)];
            }
        }
        setMirror(e, n) {
            this.mirror || (this.mirror = []), this.mirror.push(e, n);
        }
        appendMappingInverted(e) {
            for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
                let i = e.getMirror(n);
                this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
            }
        }
        invert() {
            let e = new t();
            return e.appendMappingInverted(this), e;
        }
        map(e, n = 1) {
            if (this.mirror) return this._map(e, n, !0);
            for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
            return e;
        }
        mapResult(e, n = 1) {
            return this._map(e, n, !1);
        }
        _map(e, n, r) {
            let i = 0;
            for (let o = this.from; o < this.to; o++) {
                let s = this.maps[o],
                    l = s.mapResult(e, n);
                if (l.recover != null) {
                    let u = this.getMirror(o);
                    if (u != null && u > o && u < this.to) {
                        (o = u), (e = this.maps[u].recover(l.recover));
                        continue;
                    }
                }
                (i |= l.delInfo), (e = l.pos);
            }
            return r ? e : new Ps(e, i, null);
        }
    },
    nf = Object.create(null),
    zt = class {
        getMap() {
            return Ir.empty;
        }
        merge(e) {
            return null;
        }
        static fromJSON(e, n) {
            if (!n || !n.stepType) throw new RangeError('Invalid input for Step.fromJSON');
            let r = nf[n.stepType];
            if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
            return r.fromJSON(e, n);
        }
        static jsonID(e, n) {
            if (e in nf) throw new RangeError('Duplicate use of step JSON ID ' + e);
            return (nf[e] = n), (n.prototype.jsonID = e), n;
        }
    },
    qt = class t {
        constructor(e, n) {
            (this.doc = e), (this.failed = n);
        }
        static ok(e) {
            return new t(e, null);
        }
        static fail(e) {
            return new t(null, e);
        }
        static fromReplace(e, n, r, i) {
            try {
                return t.ok(e.replace(n, r, i));
            } catch (o) {
                if (o instanceof Hi) return t.fail(o.message);
                throw o;
            }
        }
    };
function lf(t, e, n) {
    let r = [];
    for (let i = 0; i < t.childCount; i++) {
        let o = t.child(i);
        o.content.size && (o = o.copy(lf(o.content, e, o))), o.isInline && (o = e(o, n, i)), r.push(o);
    }
    return K.fromArray(r);
}
var Fs = class t extends zt {
    constructor(e, n, r) {
        super(), (this.from = e), (this.to = n), (this.mark = r);
    }
    apply(e) {
        let n = e.slice(this.from, this.to),
            r = e.resolve(this.from),
            i = r.node(r.sharedDepth(this.to)),
            o = new X(
                lf(
                    n.content,
                    (s, l) =>
                        !s.isAtom || !l.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)),
                    i,
                ),
                n.openStart,
                n.openEnd,
            );
        return qt.fromReplace(e, this.from, this.to, o);
    }
    invert() {
        return new Wi(this.from, this.to, this.mark);
    }
    map(e) {
        let n = e.mapResult(this.from, 1),
            r = e.mapResult(this.to, -1);
        return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new t(n.pos, r.pos, this.mark);
    }
    merge(e) {
        return e instanceof t && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from
            ? new t(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
            : null;
    }
    toJSON() {
        return { stepType: 'addMark', mark: this.mark.toJSON(), from: this.from, to: this.to };
    }
    static fromJSON(e, n) {
        if (typeof n.from != 'number' || typeof n.to != 'number')
            throw new RangeError('Invalid input for AddMarkStep.fromJSON');
        return new t(n.from, n.to, e.markFromJSON(n.mark));
    }
};
zt.jsonID('addMark', Fs);
var Wi = class t extends zt {
    constructor(e, n, r) {
        super(), (this.from = e), (this.to = n), (this.mark = r);
    }
    apply(e) {
        let n = e.slice(this.from, this.to),
            r = new X(
                lf(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e),
                n.openStart,
                n.openEnd,
            );
        return qt.fromReplace(e, this.from, this.to, r);
    }
    invert() {
        return new Fs(this.from, this.to, this.mark);
    }
    map(e) {
        let n = e.mapResult(this.from, 1),
            r = e.mapResult(this.to, -1);
        return (n.deleted && r.deleted) || n.pos >= r.pos ? null : new t(n.pos, r.pos, this.mark);
    }
    merge(e) {
        return e instanceof t && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from
            ? new t(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
            : null;
    }
    toJSON() {
        return { stepType: 'removeMark', mark: this.mark.toJSON(), from: this.from, to: this.to };
    }
    static fromJSON(e, n) {
        if (typeof n.from != 'number' || typeof n.to != 'number')
            throw new RangeError('Invalid input for RemoveMarkStep.fromJSON');
        return new t(n.from, n.to, e.markFromJSON(n.mark));
    }
};
zt.jsonID('removeMark', Wi);
var Hs = class t extends zt {
    constructor(e, n) {
        super(), (this.pos = e), (this.mark = n);
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n) return qt.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return qt.fromReplace(e, this.pos, this.pos + 1, new X(K.from(r), 0, n.isLeaf ? 0 : 1));
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let i = 0; i < n.marks.length; i++) if (!n.marks[i].isInSet(r)) return new t(this.pos, n.marks[i]);
                return new t(this.pos, this.mark);
            }
        }
        return new zs(this.pos, this.mark);
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new t(n.pos, this.mark);
    }
    toJSON() {
        return { stepType: 'addNodeMark', pos: this.pos, mark: this.mark.toJSON() };
    }
    static fromJSON(e, n) {
        if (typeof n.pos != 'number') throw new RangeError('Invalid input for AddNodeMarkStep.fromJSON');
        return new t(n.pos, e.markFromJSON(n.mark));
    }
};
zt.jsonID('addNodeMark', Hs);
var zs = class t extends zt {
    constructor(e, n) {
        super(), (this.pos = e), (this.mark = n);
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n) return qt.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return qt.fromReplace(e, this.pos, this.pos + 1, new X(K.from(r), 0, n.isLeaf ? 0 : 1));
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new Hs(this.pos, this.mark);
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new t(n.pos, this.mark);
    }
    toJSON() {
        return { stepType: 'removeNodeMark', pos: this.pos, mark: this.mark.toJSON() };
    }
    static fromJSON(e, n) {
        if (typeof n.pos != 'number') throw new RangeError('Invalid input for RemoveNodeMarkStep.fromJSON');
        return new t(n.pos, e.markFromJSON(n.mark));
    }
};
zt.jsonID('removeNodeMark', zs);
var nn = class t extends zt {
    constructor(e, n, r, i = !1) {
        super(), (this.from = e), (this.to = n), (this.slice = r), (this.structure = i);
    }
    apply(e) {
        return this.structure && sf(e, this.from, this.to)
            ? qt.fail('Structure replace would overwrite content')
            : qt.fromReplace(e, this.from, this.to, this.slice);
    }
    getMap() {
        return new Ir([this.from, this.to - this.from, this.slice.size]);
    }
    invert(e) {
        return new t(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
    }
    map(e) {
        let n = e.mapResult(this.from, 1),
            r = e.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new t(n.pos, Math.max(n.pos, r.pos), this.slice);
    }
    merge(e) {
        if (!(e instanceof t) || e.structure || this.structure) return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
            let n =
                this.slice.size + e.slice.size == 0
                    ? X.empty
                    : new X(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
            return new t(this.from, this.to + (e.to - e.from), n, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
            let n =
                this.slice.size + e.slice.size == 0
                    ? X.empty
                    : new X(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
            return new t(e.from, this.to, n, this.structure);
        } else return null;
    }
    toJSON() {
        let e = { stepType: 'replace', from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
    }
    static fromJSON(e, n) {
        if (typeof n.from != 'number' || typeof n.to != 'number')
            throw new RangeError('Invalid input for ReplaceStep.fromJSON');
        return new t(n.from, n.to, X.fromJSON(e, n.slice), !!n.structure);
    }
};
zt.jsonID('replace', nn);
var Tt = class t extends zt {
    constructor(e, n, r, i, o, s, l = !1) {
        super(),
            (this.from = e),
            (this.to = n),
            (this.gapFrom = r),
            (this.gapTo = i),
            (this.slice = o),
            (this.insert = s),
            (this.structure = l);
    }
    apply(e) {
        if (this.structure && (sf(e, this.from, this.gapFrom) || sf(e, this.gapTo, this.to)))
            return qt.fail('Structure gap-replace would overwrite content');
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd) return qt.fail('Gap is not a flat range');
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? qt.fromReplace(e, this.from, this.to, r) : qt.fail('Content does not fit in gap');
    }
    getMap() {
        return new Ir([
            this.from,
            this.gapFrom - this.from,
            this.insert,
            this.gapTo,
            this.to - this.gapTo,
            this.slice.size - this.insert,
        ]);
    }
    invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new t(
            this.from,
            this.from + this.slice.size + n,
            this.from + this.insert,
            this.from + this.insert + n,
            e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
            this.gapFrom - this.from,
            this.structure,
        );
    }
    map(e) {
        let n = e.mapResult(this.from, 1),
            r = e.mapResult(this.to, -1),
            i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1),
            o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
        return (n.deletedAcross && r.deletedAcross) || i < n.pos || o > r.pos
            ? null
            : new t(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
    }
    toJSON() {
        let e = {
            stepType: 'replaceAround',
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert,
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
    }
    static fromJSON(e, n) {
        if (
            typeof n.from != 'number' ||
            typeof n.to != 'number' ||
            typeof n.gapFrom != 'number' ||
            typeof n.gapTo != 'number' ||
            typeof n.insert != 'number'
        )
            throw new RangeError('Invalid input for ReplaceAroundStep.fromJSON');
        return new t(n.from, n.to, n.gapFrom, n.gapTo, X.fromJSON(e, n.slice), n.insert, !!n.structure);
    }
};
zt.jsonID('replaceAround', Tt);
function sf(t, e, n) {
    let r = t.resolve(e),
        i = n - e,
        o = r.depth;
    for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; ) o--, i--;
    if (i > 0) {
        let s = r.node(o).maybeChild(r.indexAfter(o));
        for (; i > 0; ) {
            if (!s || s.isLeaf) return !0;
            (s = s.firstChild), i--;
        }
    }
    return !1;
}
function vO(t, e, n, r) {
    let i = [],
        o = [],
        s,
        l;
    t.doc.nodesBetween(e, n, (u, d, f) => {
        if (!u.isInline) return;
        let h = u.marks;
        if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
            let m = Math.max(d, e),
                b = Math.min(d + u.nodeSize, n),
                y = r.addToSet(h);
            for (let v = 0; v < h.length; v++)
                h[v].isInSet(y) || (s && s.to == m && s.mark.eq(h[v]) ? (s.to = b) : i.push((s = new Wi(m, b, h[v]))));
            l && l.to == m ? (l.to = b) : o.push((l = new Fs(m, b, r)));
        }
    }),
        i.forEach((u) => t.step(u)),
        o.forEach((u) => t.step(u));
}
function wO(t, e, n, r) {
    let i = [],
        o = 0;
    t.doc.nodesBetween(e, n, (s, l) => {
        if (!s.isInline) return;
        o++;
        let u = null;
        if (r instanceof Is) {
            let d = s.marks,
                f;
            for (; (f = r.isInSet(d)); ) (u || (u = [])).push(f), (d = f.removeFromSet(d));
        } else r ? r.isInSet(s.marks) && (u = [r]) : (u = s.marks);
        if (u && u.length) {
            let d = Math.min(l + s.nodeSize, n);
            for (let f = 0; f < u.length; f++) {
                let h = u[f],
                    m;
                for (let b = 0; b < i.length; b++) {
                    let y = i[b];
                    y.step == o - 1 && h.eq(i[b].style) && (m = y);
                }
                m ? ((m.to = d), (m.step = o)) : i.push({ style: h, from: Math.max(l, e), to: d, step: o });
            }
        }
    }),
        i.forEach((s) => t.step(new Wi(s.from, s.to, s.style)));
}
function Py(t, e, n, r = n.contentMatch, i = !0) {
    let o = t.doc.nodeAt(e),
        s = [],
        l = e + 1;
    for (let u = 0; u < o.childCount; u++) {
        let d = o.child(u),
            f = l + d.nodeSize,
            h = r.matchType(d.type);
        if (!h) s.push(new nn(l, f, X.empty));
        else {
            r = h;
            for (let m = 0; m < d.marks.length; m++)
                n.allowsMarkType(d.marks[m].type) || t.step(new Wi(l, f, d.marks[m]));
            if (i && d.isText && n.whitespace != 'pre') {
                let m,
                    b = /\r?\n|\r/g,
                    y;
                for (; (m = b.exec(d.text)); )
                    y || (y = new X(K.from(n.schema.text(' ', n.allowedMarks(d.marks))), 0, 0)),
                        s.push(new nn(l + m.index, l + m.index + m[0].length, y));
            }
        }
        l = f;
    }
    if (!r.validEnd) {
        let u = r.fillBefore(K.empty, !0);
        t.replace(l, l, new X(u, 0, 0));
    }
    for (let u = s.length - 1; u >= 0; u--) t.step(s[u]);
}
function xO(t, e, n) {
    return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Lr(t) {
    let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
    for (let r = t.depth; ; --r) {
        let i = t.$from.node(r),
            o = t.$from.index(r),
            s = t.$to.indexAfter(r);
        if (r < t.depth && i.canReplace(o, s, n)) return r;
        if (r == 0 || i.type.spec.isolating || !xO(i, o, s)) break;
    }
    return null;
}
function _O(t, e, n) {
    let { $from: r, $to: i, depth: o } = e,
        s = r.before(o + 1),
        l = i.after(o + 1),
        u = s,
        d = l,
        f = K.empty,
        h = 0;
    for (let y = o, v = !1; y > n; y--) v || r.index(y) > 0 ? ((v = !0), (f = K.from(r.node(y).copy(f))), h++) : u--;
    let m = K.empty,
        b = 0;
    for (let y = o, v = !1; y > n; y--)
        v || i.after(y + 1) < i.end(y) ? ((v = !0), (m = K.from(i.node(y).copy(m))), b++) : d++;
    t.step(new Tt(u, d, s, l, new X(f.append(m), h, b), f.size - h, !0));
}
function Do(t, e, n = null, r = t) {
    let i = SO(t, e),
        o = i && TO(r, e);
    return o ? i.map(Ny).concat({ type: e, attrs: n }).concat(o.map(Ny)) : null;
}
function Ny(t) {
    return { type: t, attrs: null };
}
function SO(t, e) {
    let { parent: n, startIndex: r, endIndex: i } = t,
        o = n.contentMatchAt(r).findWrapping(e);
    if (!o) return null;
    let s = o.length ? o[0] : e;
    return n.canReplaceWith(r, i, s) ? o : null;
}
function TO(t, e) {
    let { parent: n, startIndex: r, endIndex: i } = t,
        o = n.child(r),
        s = e.contentMatch.findWrapping(o.type);
    if (!s) return null;
    let u = (s.length ? s[s.length - 1] : e).contentMatch;
    for (let d = r; u && d < i; d++) u = u.matchType(n.child(d).type);
    return !u || !u.validEnd ? null : s;
}
function MO(t, e, n) {
    let r = K.empty;
    for (let s = n.length - 1; s >= 0; s--) {
        if (r.size) {
            let l = n[s].type.contentMatch.matchFragment(r);
            if (!l || !l.validEnd)
                throw new RangeError(
                    'Wrapper type given to Transform.wrap does not form valid content of its parent wrapper',
                );
        }
        r = K.from(n[s].type.create(n[s].attrs, r));
    }
    let i = e.start,
        o = e.end;
    t.step(new Tt(i, o, i, o, new X(r, 0, 0), n.length, !0));
}
function AO(t, e, n, r, i) {
    if (!r.isTextblock) throw new RangeError('Type given to setBlockType should be a textblock');
    let o = t.steps.length;
    t.doc.nodesBetween(e, n, (s, l) => {
        if (s.isTextblock && !s.hasMarkup(r, i) && NO(t.doc, t.mapping.slice(o).map(l), r)) {
            let u = null;
            if (r.schema.linebreakReplacement) {
                let m = r.whitespace == 'pre',
                    b = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                m && !b ? (u = !1) : !m && b && (u = !0);
            }
            u === !1 && kO(t, s, l, o), Py(t, t.mapping.slice(o).map(l, 1), r, void 0, u === null);
            let d = t.mapping.slice(o),
                f = d.map(l, 1),
                h = d.map(l + s.nodeSize, 1);
            return (
                t.step(new Tt(f, h, f + 1, h - 1, new X(K.from(r.create(i, null, s.marks)), 0, 0), 1, !0)),
                u === !0 && CO(t, s, l, o),
                !1
            );
        }
    });
}
function CO(t, e, n, r) {
    e.forEach((i, o) => {
        if (i.isText) {
            let s,
                l = /\r?\n|\r/g;
            for (; (s = l.exec(i.text)); ) {
                let u = t.mapping.slice(r).map(n + 1 + o + s.index);
                t.replaceWith(u, u + 1, e.type.schema.linebreakReplacement.create());
            }
        }
    });
}
function kO(t, e, n, r) {
    e.forEach((i, o) => {
        if (i.type == i.type.schema.linebreakReplacement) {
            let s = t.mapping.slice(r).map(n + 1 + o);
            t.replaceWith(
                s,
                s + 1,
                e.type.schema.text(`
`),
            );
        }
    });
}
function NO(t, e, n) {
    let r = t.resolve(e),
        i = r.index();
    return r.parent.canReplaceWith(i, i + 1, n);
}
function OO(t, e, n, r, i) {
    let o = t.doc.nodeAt(e);
    if (!o) throw new RangeError('No node at given position');
    n || (n = o.type);
    let s = n.create(r, null, i || o.marks);
    if (o.isLeaf) return t.replaceWith(e, e + o.nodeSize, s);
    if (!n.validContent(o.content)) throw new RangeError('Invalid content for node type ' + n.name);
    t.step(new Tt(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new X(K.from(s), 0, 0), 1, !0));
}
function Hn(t, e, n = 1, r) {
    let i = t.resolve(e),
        o = i.depth - n,
        s = (r && r[r.length - 1]) || i.parent;
    if (
        o < 0 ||
        i.parent.type.spec.isolating ||
        !i.parent.canReplace(i.index(), i.parent.childCount) ||
        !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))
    )
        return !1;
    for (let d = i.depth - 1, f = n - 2; d > o; d--, f--) {
        let h = i.node(d),
            m = i.index(d);
        if (h.type.spec.isolating) return !1;
        let b = h.content.cutByIndex(m, h.childCount),
            y = r && r[f + 1];
        y && (b = b.replaceChild(0, y.type.create(y.attrs)));
        let v = (r && r[f]) || h;
        if (!h.canReplace(m + 1, h.childCount) || !v.type.validContent(b)) return !1;
    }
    let l = i.indexAfter(o),
        u = r && r[0];
    return i.node(o).canReplaceWith(l, l, u ? u.type : i.node(o + 1).type);
}
function RO(t, e, n = 1, r) {
    let i = t.doc.resolve(e),
        o = K.empty,
        s = K.empty;
    for (let l = i.depth, u = i.depth - n, d = n - 1; l > u; l--, d--) {
        o = K.from(i.node(l).copy(o));
        let f = r && r[d];
        s = K.from(f ? f.type.create(f.attrs, s) : i.node(l).copy(s));
    }
    t.step(new nn(e, e, new X(o.append(s), n, n), !0));
}
function tr(t, e) {
    let n = t.resolve(e),
        r = n.index();
    return By(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function By(t, e) {
    return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function Po(t, e, n = -1) {
    let r = t.resolve(e);
    for (let i = r.depth; ; i--) {
        let o,
            s,
            l = r.index(i);
        if (
            (i == r.depth
                ? ((o = r.nodeBefore), (s = r.nodeAfter))
                : n > 0
                  ? ((o = r.node(i + 1)), l++, (s = r.node(i).maybeChild(l)))
                  : ((o = r.node(i).maybeChild(l - 1)), (s = r.node(i + 1))),
            o && !o.isTextblock && By(o, s) && r.node(i).canReplace(l, l + 1))
        )
            return e;
        if (i == 0) break;
        e = n < 0 ? r.before(i) : r.after(i);
    }
}
function IO(t, e, n) {
    let r = new nn(e - n, e + n, X.empty, !0);
    t.step(r);
}
function LO(t, e, n) {
    let r = t.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
    if (r.parentOffset == 0)
        for (let i = r.depth - 1; i >= 0; i--) {
            let o = r.index(i);
            if (r.node(i).canReplaceWith(o, o, n)) return r.before(i + 1);
            if (o > 0) return null;
        }
    if (r.parentOffset == r.parent.content.size)
        for (let i = r.depth - 1; i >= 0; i--) {
            let o = r.indexAfter(i);
            if (r.node(i).canReplaceWith(o, o, n)) return r.after(i + 1);
            if (o < r.node(i).childCount) return null;
        }
    return null;
}
function Ml(t, e, n) {
    let r = t.resolve(e);
    if (!n.content.size) return e;
    let i = n.content;
    for (let o = 0; o < n.openStart; o++) i = i.firstChild.content;
    for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
        for (let s = r.depth; s >= 0; s--) {
            let l = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1,
                u = r.index(s) + (l > 0 ? 1 : 0),
                d = r.node(s),
                f = !1;
            if (o == 1) f = d.canReplace(u, u, i);
            else {
                let h = d.contentMatchAt(u).findWrapping(i.firstChild.type);
                f = h && d.canReplaceWith(u, u, h[0]);
            }
            if (f) return l == 0 ? r.pos : l < 0 ? r.before(s + 1) : r.after(s + 1);
        }
    return null;
}
function $s(t, e, n = e, r = X.empty) {
    if (e == n && !r.size) return null;
    let i = t.resolve(e),
        o = t.resolve(n);
    return Fy(i, o, r) ? new nn(e, n, r) : new af(i, o, r).fit();
}
function Fy(t, e, n) {
    return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
var af = class {
    constructor(e, n, r) {
        (this.$from = e), (this.$to = n), (this.unplaced = r), (this.frontier = []), (this.placed = K.empty);
        for (let i = 0; i <= e.depth; i++) {
            let o = e.node(i);
            this.frontier.push({ type: o.type, match: o.contentMatchAt(e.indexAfter(i)) });
        }
        for (let i = e.depth; i > 0; i--) this.placed = K.from(e.node(i).copy(this.placed));
    }
    get depth() {
        return this.frontier.length - 1;
    }
    fit() {
        for (; this.unplaced.size; ) {
            let d = this.findFittable();
            d ? this.placeNodes(d) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(),
            n = this.placed.size - this.depth - this.$from.depth,
            r = this.$from,
            i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!i) return null;
        let o = this.placed,
            s = r.depth,
            l = i.depth;
        for (; s && l && o.childCount == 1; ) (o = o.firstChild.content), s--, l--;
        let u = new X(o, s, l);
        return e > -1
            ? new Tt(r.pos, e, this.$to.pos, this.$to.end(), u, n)
            : u.size || r.pos != this.$to.pos
              ? new nn(r.pos, i.pos, u)
              : null;
    }
    findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
            let o = n.firstChild;
            if ((n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r)) {
                e = r;
                break;
            }
            n = o.content;
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
                let i,
                    o = null;
                r ? ((o = rf(this.unplaced.content, r - 1).firstChild), (i = o.content)) : (i = this.unplaced.content);
                let s = i.firstChild;
                for (let l = this.depth; l >= 0; l--) {
                    let { type: u, match: d } = this.frontier[l],
                        f,
                        h = null;
                    if (
                        n == 1 &&
                        (s
                            ? d.matchType(s.type) || (h = d.fillBefore(K.from(s), !1))
                            : o && u.compatibleContent(o.type))
                    )
                        return { sliceDepth: r, frontierDepth: l, parent: o, inject: h };
                    if (n == 2 && s && (f = d.findWrapping(s.type)))
                        return { sliceDepth: r, frontierDepth: l, parent: o, wrap: f };
                    if (o && d.matchType(o.type)) break;
                }
            }
    }
    openMore() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced,
            i = rf(e, n);
        return !i.childCount || i.firstChild.isLeaf
            ? !1
            : ((this.unplaced = new X(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0))), !0);
    }
    dropNode() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced,
            i = rf(e, n);
        if (i.childCount <= 1 && n > 0) {
            let o = e.size - n <= n + i.size;
            this.unplaced = new X(Ls(e, n - 1, 1), n - 1, o ? n - 1 : r);
        } else this.unplaced = new X(Ls(e, n, 1), n, r);
    }
    placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: o }) {
        for (; this.depth > n; ) this.closeFrontierNode();
        if (o) for (let v = 0; v < o.length; v++) this.openFrontierNode(o[v]);
        let s = this.unplaced,
            l = r ? r.content : s.content,
            u = s.openStart - e,
            d = 0,
            f = [],
            { match: h, type: m } = this.frontier[n];
        if (i) {
            for (let v = 0; v < i.childCount; v++) f.push(i.child(v));
            h = h.matchFragment(i);
        }
        let b = l.size + e - (s.content.size - s.openEnd);
        for (; d < l.childCount; ) {
            let v = l.child(d),
                x = h.matchType(v.type);
            if (!x) break;
            d++,
                (d > 1 || u == 0 || v.content.size) &&
                    ((h = x), f.push(Hy(v.mark(m.allowedMarks(v.marks)), d == 1 ? u : 0, d == l.childCount ? b : -1)));
        }
        let y = d == l.childCount;
        y || (b = -1),
            (this.placed = Ds(this.placed, n, K.from(f))),
            (this.frontier[n].match = h),
            y &&
                b < 0 &&
                r &&
                r.type == this.frontier[this.depth].type &&
                this.frontier.length > 1 &&
                this.closeFrontierNode();
        for (let v = 0, x = l; v < b; v++) {
            let T = x.lastChild;
            this.frontier.push({ type: T.type, match: T.contentMatchAt(T.childCount) }), (x = T.content);
        }
        this.unplaced = y
            ? e == 0
                ? X.empty
                : new X(Ls(s.content, e - 1, 1), e - 1, b < 0 ? s.openEnd : e - 1)
            : new X(Ls(s.content, e, d), s.openStart, s.openEnd);
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock) return -1;
        let e = this.frontier[this.depth],
            n;
        if (
            !e.type.isTextblock ||
            !of(this.$to, this.$to.depth, e.type, e.match, !1) ||
            (this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
        )
            return -1;
        let { depth: r } = this.$to,
            i = this.$to.after(r);
        for (; r > 1 && i == this.$to.end(--r); ) ++i;
        return i;
    }
    findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
            let { match: r, type: i } = this.frontier[n],
                o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
                s = of(e, n, i, r, o);
            if (s) {
                for (let l = n - 1; l >= 0; l--) {
                    let { match: u, type: d } = this.frontier[l],
                        f = of(e, l, d, u, !0);
                    if (!f || f.childCount) continue e;
                }
                return { depth: n, fit: s, move: o ? e.doc.resolve(e.after(n + 1)) : e };
            }
        }
    }
    close(e) {
        let n = this.findCloseLevel(e);
        if (!n) return null;
        for (; this.depth > n.depth; ) this.closeFrontierNode();
        n.fit.childCount && (this.placed = Ds(this.placed, n.depth, n.fit)), (e = n.move);
        for (let r = n.depth + 1; r <= e.depth; r++) {
            let i = e.node(r),
                o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
            this.openFrontierNode(i.type, i.attrs, o);
        }
        return e;
    }
    openFrontierNode(e, n = null, r) {
        let i = this.frontier[this.depth];
        (i.match = i.match.matchType(e)),
            (this.placed = Ds(this.placed, this.depth, K.from(e.create(n, r)))),
            this.frontier.push({ type: e, match: e.contentMatch });
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(K.empty, !0);
        n.childCount && (this.placed = Ds(this.placed, this.frontier.length, n));
    }
};
function Ls(t, e, n) {
    return e == 0
        ? t.cutByIndex(n, t.childCount)
        : t.replaceChild(0, t.firstChild.copy(Ls(t.firstChild.content, e - 1, n)));
}
function Ds(t, e, n) {
    return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ds(t.lastChild.content, e - 1, n)));
}
function rf(t, e) {
    for (let n = 0; n < e; n++) t = t.firstChild.content;
    return t;
}
function Hy(t, e, n) {
    if (e <= 0) return t;
    let r = t.content;
    return (
        e > 1 && (r = r.replaceChild(0, Hy(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))),
        e > 0 &&
            ((r = t.type.contentMatch.fillBefore(r).append(r)),
            n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(K.empty, !0)))),
        t.copy(r)
    );
}
function of(t, e, n, r, i) {
    let o = t.node(e),
        s = i ? t.indexAfter(e) : t.index(e);
    if (s == o.childCount && !n.compatibleContent(o.type)) return null;
    let l = r.fillBefore(o.content, !0, s);
    return l && !DO(n, o.content, s) ? l : null;
}
function DO(t, e, n) {
    for (let r = n; r < e.childCount; r++) if (!t.allowsMarks(e.child(r).marks)) return !0;
    return !1;
}
function PO(t) {
    return t.spec.defining || t.spec.definingForContent;
}
function BO(t, e, n, r) {
    if (!r.size) return t.deleteRange(e, n);
    let i = t.doc.resolve(e),
        o = t.doc.resolve(n);
    if (Fy(i, o, r)) return t.step(new nn(e, n, r));
    let s = $y(i, t.doc.resolve(n));
    s[s.length - 1] == 0 && s.pop();
    let l = -(i.depth + 1);
    s.unshift(l);
    for (let m = i.depth, b = i.pos - 1; m > 0; m--, b--) {
        let y = i.node(m).type.spec;
        if (y.defining || y.definingAsContext || y.isolating) break;
        s.indexOf(m) > -1 ? (l = m) : i.before(m) == b && s.splice(1, 0, -m);
    }
    let u = s.indexOf(l),
        d = [],
        f = r.openStart;
    for (let m = r.content, b = 0; ; b++) {
        let y = m.firstChild;
        if ((d.push(y), b == r.openStart)) break;
        m = y.content;
    }
    for (let m = f - 1; m >= 0; m--) {
        let b = d[m],
            y = PO(b.type);
        if (y && !b.sameMarkup(i.node(Math.abs(l) - 1))) f = m;
        else if (y || !b.type.isTextblock) break;
    }
    for (let m = r.openStart; m >= 0; m--) {
        let b = (m + f + 1) % (r.openStart + 1),
            y = d[b];
        if (y)
            for (let v = 0; v < s.length; v++) {
                let x = s[(v + u) % s.length],
                    T = !0;
                x < 0 && ((T = !1), (x = -x));
                let D = i.node(x - 1),
                    I = i.index(x - 1);
                if (D.canReplaceWith(I, I, y.type, y.marks))
                    return t.replace(
                        i.before(x),
                        T ? o.after(x) : n,
                        new X(zy(r.content, 0, r.openStart, b), b, r.openEnd),
                    );
            }
    }
    let h = t.steps.length;
    for (let m = s.length - 1; m >= 0 && (t.replace(e, n, r), !(t.steps.length > h)); m--) {
        let b = s[m];
        b < 0 || ((e = i.before(b)), (n = o.after(b)));
    }
}
function zy(t, e, n, r, i) {
    if (e < n) {
        let o = t.firstChild;
        t = t.replaceChild(0, o.copy(zy(o.content, e + 1, n, r, o)));
    }
    if (e > r) {
        let o = i.contentMatchAt(0),
            s = o.fillBefore(t).append(t);
        t = s.append(o.matchFragment(s).fillBefore(K.empty, !0));
    }
    return t;
}
function FO(t, e, n, r) {
    if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
        let i = LO(t.doc, e, r.type);
        i != null && (e = n = i);
    }
    t.replaceRange(e, n, new X(K.from(r), 0, 0));
}
function HO(t, e, n) {
    let r = t.doc.resolve(e),
        i = t.doc.resolve(n),
        o = $y(r, i);
    for (let s = 0; s < o.length; s++) {
        let l = o[s],
            u = s == o.length - 1;
        if ((u && l == 0) || r.node(l).type.contentMatch.validEnd) return t.delete(r.start(l), i.end(l));
        if (l > 0 && (u || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
            return t.delete(r.before(l), i.after(l));
    }
    for (let s = 1; s <= r.depth && s <= i.depth; s++)
        if (e - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s)
            return t.delete(r.before(s), n);
    t.delete(e, n);
}
function $y(t, e) {
    let n = [],
        r = Math.min(t.depth, e.depth);
    for (let i = r; i >= 0; i--) {
        let o = t.start(i);
        if (
            o < t.pos - (t.depth - i) ||
            e.end(i) > e.pos + (e.depth - i) ||
            t.node(i).type.spec.isolating ||
            e.node(i).type.spec.isolating
        )
            break;
        (o == e.start(i) ||
            (i == t.depth &&
                i == e.depth &&
                t.parent.inlineContent &&
                e.parent.inlineContent &&
                i &&
                e.start(i - 1) == o - 1)) &&
            n.push(i);
    }
    return n;
}
var Sl = class t extends zt {
    constructor(e, n, r) {
        super(), (this.pos = e), (this.attr = n), (this.value = r);
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n) return qt.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let o in n.attrs) r[o] = n.attrs[o];
        r[this.attr] = this.value;
        let i = n.type.create(r, null, n.marks);
        return qt.fromReplace(e, this.pos, this.pos + 1, new X(K.from(i), 0, n.isLeaf ? 0 : 1));
    }
    getMap() {
        return Ir.empty;
    }
    invert(e) {
        return new t(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new t(n.pos, this.attr, this.value);
    }
    toJSON() {
        return { stepType: 'attr', pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(e, n) {
        if (typeof n.pos != 'number' || typeof n.attr != 'string')
            throw new RangeError('Invalid input for AttrStep.fromJSON');
        return new t(n.pos, n.attr, n.value);
    }
};
zt.jsonID('attr', Sl);
var Tl = class t extends zt {
    constructor(e, n) {
        super(), (this.attr = e), (this.value = n);
    }
    apply(e) {
        let n = Object.create(null);
        for (let i in e.attrs) n[i] = e.attrs[i];
        n[this.attr] = this.value;
        let r = e.type.create(n, e.content, e.marks);
        return qt.ok(r);
    }
    getMap() {
        return Ir.empty;
    }
    invert(e) {
        return new t(this.attr, e.attrs[this.attr]);
    }
    map(e) {
        return this;
    }
    toJSON() {
        return { stepType: 'docAttr', attr: this.attr, value: this.value };
    }
    static fromJSON(e, n) {
        if (typeof n.attr != 'string') throw new RangeError('Invalid input for DocAttrStep.fromJSON');
        return new t(n.attr, n.value);
    }
};
zt.jsonID('docAttr', Tl);
var Lo = class extends Error {};
Lo = function t(e) {
    let n = Error.call(this, e);
    return (n.__proto__ = t.prototype), n;
};
Lo.prototype = Object.create(Error.prototype);
Lo.prototype.constructor = Lo;
Lo.prototype.name = 'TransformError';
var si = class {
    constructor(e) {
        (this.doc = e), (this.steps = []), (this.docs = []), (this.mapping = new Bs());
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc;
    }
    step(e) {
        let n = this.maybeStep(e);
        if (n.failed) throw new Lo(n.failed);
        return this;
    }
    maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc), n;
    }
    get docChanged() {
        return this.steps.length > 0;
    }
    addStep(e, n) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), (this.doc = n);
    }
    replace(e, n = e, r = X.empty) {
        let i = $s(this.doc, e, n, r);
        return i && this.step(i), this;
    }
    replaceWith(e, n, r) {
        return this.replace(e, n, new X(K.from(r), 0, 0));
    }
    delete(e, n) {
        return this.replace(e, n, X.empty);
    }
    insert(e, n) {
        return this.replaceWith(e, e, n);
    }
    replaceRange(e, n, r) {
        return BO(this, e, n, r), this;
    }
    replaceRangeWith(e, n, r) {
        return FO(this, e, n, r), this;
    }
    deleteRange(e, n) {
        return HO(this, e, n), this;
    }
    lift(e, n) {
        return _O(this, e, n), this;
    }
    join(e, n = 1) {
        return IO(this, e, n), this;
    }
    wrap(e, n) {
        return MO(this, e, n), this;
    }
    setBlockType(e, n = e, r, i = null) {
        return AO(this, e, n, r, i), this;
    }
    setNodeMarkup(e, n, r = null, i) {
        return OO(this, e, n, r, i), this;
    }
    setNodeAttribute(e, n, r) {
        return this.step(new Sl(e, n, r)), this;
    }
    setDocAttribute(e, n) {
        return this.step(new Tl(e, n)), this;
    }
    addNodeMark(e, n) {
        return this.step(new Hs(e, n)), this;
    }
    removeNodeMark(e, n) {
        if (!(n instanceof Je)) {
            let r = this.doc.nodeAt(e);
            if (!r) throw new RangeError('No node at position ' + e);
            if (((n = n.isInSet(r.marks)), !n)) return this;
        }
        return this.step(new zs(e, n)), this;
    }
    split(e, n = 1, r) {
        return RO(this, e, n, r), this;
    }
    addMark(e, n, r) {
        return vO(this, e, n, r), this;
    }
    removeMark(e, n, r) {
        return wO(this, e, n, r), this;
    }
    clearIncompatible(e, n, r) {
        return Py(this, e, n, r), this;
    }
};
var cf = Object.create(null),
    fe = class {
        constructor(e, n, r) {
            (this.$anchor = e), (this.$head = n), (this.ranges = r || [new Ws(e.min(n), e.max(n))]);
        }
        get anchor() {
            return this.$anchor.pos;
        }
        get head() {
            return this.$head.pos;
        }
        get from() {
            return this.$from.pos;
        }
        get to() {
            return this.$to.pos;
        }
        get $from() {
            return this.ranges[0].$from;
        }
        get $to() {
            return this.ranges[0].$to;
        }
        get empty() {
            let e = this.ranges;
            for (let n = 0; n < e.length; n++) if (e[n].$from.pos != e[n].$to.pos) return !1;
            return !0;
        }
        content() {
            return this.$from.doc.slice(this.from, this.to, !0);
        }
        replace(e, n = X.empty) {
            let r = n.content.lastChild,
                i = null;
            for (let l = 0; l < n.openEnd; l++) (i = r), (r = r.lastChild);
            let o = e.steps.length,
                s = this.ranges;
            for (let l = 0; l < s.length; l++) {
                let { $from: u, $to: d } = s[l],
                    f = e.mapping.slice(o);
                e.replaceRange(f.map(u.pos), f.map(d.pos), l ? X.empty : n),
                    l == 0 && Ky(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
            }
        }
        replaceWith(e, n) {
            let r = e.steps.length,
                i = this.ranges;
            for (let o = 0; o < i.length; o++) {
                let { $from: s, $to: l } = i[o],
                    u = e.mapping.slice(r),
                    d = u.map(s.pos),
                    f = u.map(l.pos);
                o ? e.deleteRange(d, f) : (e.replaceRangeWith(d, f, n), Ky(e, r, n.isInline ? -1 : 1));
            }
        }
        static findFrom(e, n, r = !1) {
            let i = e.parent.inlineContent ? new ce(e) : Bo(e.node(0), e.parent, e.pos, e.index(), n, r);
            if (i) return i;
            for (let o = e.depth - 1; o >= 0; o--) {
                let s =
                    n < 0
                        ? Bo(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, r)
                        : Bo(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, r);
                if (s) return s;
            }
            return null;
        }
        static near(e, n = 1) {
            return this.findFrom(e, n) || this.findFrom(e, -n) || new Nn(e.node(0));
        }
        static atStart(e) {
            return Bo(e, e, 0, 0, 1) || new Nn(e);
        }
        static atEnd(e) {
            return Bo(e, e, e.content.size, e.childCount, -1) || new Nn(e);
        }
        static fromJSON(e, n) {
            if (!n || !n.type) throw new RangeError('Invalid input for Selection.fromJSON');
            let r = cf[n.type];
            if (!r) throw new RangeError(`No selection type ${n.type} defined`);
            return r.fromJSON(e, n);
        }
        static jsonID(e, n) {
            if (e in cf) throw new RangeError('Duplicate use of selection JSON ID ' + e);
            return (cf[e] = n), (n.prototype.jsonID = e), n;
        }
        getBookmark() {
            return ce.between(this.$anchor, this.$head).getBookmark();
        }
    };
fe.prototype.visible = !0;
var Ws = class {
        constructor(e, n) {
            (this.$from = e), (this.$to = n);
        }
    },
    Uy = !1;
function Wy(t) {
    !Uy &&
        !t.parent.inlineContent &&
        ((Uy = !0),
        console.warn(
            'TextSelection endpoint not pointing into a node with inline content (' + t.parent.type.name + ')',
        ));
}
var ce = class t extends fe {
    constructor(e, n = e) {
        Wy(e), Wy(n), super(e, n);
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        if (!r.parent.inlineContent) return fe.near(r);
        let i = e.resolve(n.map(this.anchor));
        return new t(i.parent.inlineContent ? i : r, r);
    }
    replace(e, n = X.empty) {
        if ((super.replace(e, n), n == X.empty)) {
            let r = this.$from.marksAcross(this.$to);
            r && e.ensureMarks(r);
        }
    }
    eq(e) {
        return e instanceof t && e.anchor == this.anchor && e.head == this.head;
    }
    getBookmark() {
        return new Cl(this.anchor, this.head);
    }
    toJSON() {
        return { type: 'text', anchor: this.anchor, head: this.head };
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != 'number' || typeof n.head != 'number')
            throw new RangeError('Invalid input for TextSelection.fromJSON');
        return new t(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r = n) {
        let i = e.resolve(n);
        return new this(i, r == n ? i : e.resolve(r));
    }
    static between(e, n, r) {
        let i = e.pos - n.pos;
        if (((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent)) {
            let o = fe.findFrom(n, r, !0) || fe.findFrom(n, -r, !0);
            if (o) n = o.$head;
            else return fe.near(n, r);
        }
        return (
            e.parent.inlineContent ||
                (i == 0
                    ? (e = n)
                    : ((e = (fe.findFrom(e, -r, !0) || fe.findFrom(e, r, !0)).$anchor),
                      e.pos < n.pos != i < 0 && (e = n))),
            new t(e, n)
        );
    }
};
fe.jsonID('text', ce);
var Cl = class t {
        constructor(e, n) {
            (this.anchor = e), (this.head = n);
        }
        map(e) {
            return new t(e.map(this.anchor), e.map(this.head));
        }
        resolve(e) {
            return ce.between(e.resolve(this.anchor), e.resolve(this.head));
        }
    },
    pe = class t extends fe {
        constructor(e) {
            let n = e.nodeAfter,
                r = e.node(0).resolve(e.pos + n.nodeSize);
            super(e, r), (this.node = n);
        }
        map(e, n) {
            let { deleted: r, pos: i } = n.mapResult(this.anchor),
                o = e.resolve(i);
            return r ? fe.near(o) : new t(o);
        }
        content() {
            return new X(K.from(this.node), 0, 0);
        }
        eq(e) {
            return e instanceof t && e.anchor == this.anchor;
        }
        toJSON() {
            return { type: 'node', anchor: this.anchor };
        }
        getBookmark() {
            return new df(this.anchor);
        }
        static fromJSON(e, n) {
            if (typeof n.anchor != 'number') throw new RangeError('Invalid input for NodeSelection.fromJSON');
            return new t(e.resolve(n.anchor));
        }
        static create(e, n) {
            return new t(e.resolve(n));
        }
        static isSelectable(e) {
            return !e.isText && e.type.spec.selectable !== !1;
        }
    };
pe.prototype.visible = !1;
fe.jsonID('node', pe);
var df = class t {
        constructor(e) {
            this.anchor = e;
        }
        map(e) {
            let { deleted: n, pos: r } = e.mapResult(this.anchor);
            return n ? new Cl(r, r) : new t(r);
        }
        resolve(e) {
            let n = e.resolve(this.anchor),
                r = n.nodeAfter;
            return r && pe.isSelectable(r) ? new pe(n) : fe.near(n);
        }
    },
    Nn = class t extends fe {
        constructor(e) {
            super(e.resolve(0), e.resolve(e.content.size));
        }
        replace(e, n = X.empty) {
            if (n == X.empty) {
                e.delete(0, e.doc.content.size);
                let r = fe.atStart(e.doc);
                r.eq(e.selection) || e.setSelection(r);
            } else super.replace(e, n);
        }
        toJSON() {
            return { type: 'all' };
        }
        static fromJSON(e) {
            return new t(e);
        }
        map(e) {
            return new t(e);
        }
        eq(e) {
            return e instanceof t;
        }
        getBookmark() {
            return zO;
        }
    };
fe.jsonID('all', Nn);
var zO = {
    map() {
        return this;
    },
    resolve(t) {
        return new Nn(t);
    },
};
function Bo(t, e, n, r, i, o = !1) {
    if (e.inlineContent) return ce.create(t, n);
    for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < e.childCount : s >= 0; s += i) {
        let l = e.child(s);
        if (l.isAtom) {
            if (!o && pe.isSelectable(l)) return pe.create(t, n - (i < 0 ? l.nodeSize : 0));
        } else {
            let u = Bo(t, l, n + i, i < 0 ? l.childCount : 0, i, o);
            if (u) return u;
        }
        n += l.nodeSize * i;
    }
    return null;
}
function Ky(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e) return;
    let i = t.steps[r];
    if (!(i instanceof nn || i instanceof Tt)) return;
    let o = t.mapping.maps[r],
        s;
    o.forEach((l, u, d, f) => {
        s == null && (s = f);
    }),
        t.setSelection(fe.near(t.doc.resolve(s), n));
}
var Vy = 1,
    Al = 2,
    Gy = 4,
    ff = class extends si {
        constructor(e) {
            super(e.doc),
                (this.curSelectionFor = 0),
                (this.updated = 0),
                (this.meta = Object.create(null)),
                (this.time = Date.now()),
                (this.curSelection = e.selection),
                (this.storedMarks = e.storedMarks);
        }
        get selection() {
            return (
                this.curSelectionFor < this.steps.length &&
                    ((this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))),
                    (this.curSelectionFor = this.steps.length)),
                this.curSelection
            );
        }
        setSelection(e) {
            if (e.$from.doc != this.doc)
                throw new RangeError('Selection passed to setSelection must point at the current document');
            return (
                (this.curSelection = e),
                (this.curSelectionFor = this.steps.length),
                (this.updated = (this.updated | Vy) & ~Al),
                (this.storedMarks = null),
                this
            );
        }
        get selectionSet() {
            return (this.updated & Vy) > 0;
        }
        setStoredMarks(e) {
            return (this.storedMarks = e), (this.updated |= Al), this;
        }
        ensureMarks(e) {
            return Je.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
        }
        addStoredMark(e) {
            return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
        }
        removeStoredMark(e) {
            return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        }
        get storedMarksSet() {
            return (this.updated & Al) > 0;
        }
        addStep(e, n) {
            super.addStep(e, n), (this.updated = this.updated & ~Al), (this.storedMarks = null);
        }
        setTime(e) {
            return (this.time = e), this;
        }
        replaceSelection(e) {
            return this.selection.replace(this, e), this;
        }
        replaceSelectionWith(e, n = !0) {
            let r = this.selection;
            return (
                n &&
                    (e = e.mark(
                        this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Je.none),
                    )),
                r.replaceWith(this, e),
                this
            );
        }
        deleteSelection() {
            return this.selection.replace(this), this;
        }
        insertText(e, n, r) {
            let i = this.doc.type.schema;
            if (n == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
            {
                if ((r == null && (r = n), (r = r ?? n), !e)) return this.deleteRange(n, r);
                let o = this.storedMarks;
                if (!o) {
                    let s = this.doc.resolve(n);
                    o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
                }
                return (
                    this.replaceRangeWith(n, r, i.text(e, o)),
                    this.selection.empty || this.setSelection(fe.near(this.selection.$to)),
                    this
                );
            }
        }
        setMeta(e, n) {
            return (this.meta[typeof e == 'string' ? e : e.key] = n), this;
        }
        getMeta(e) {
            return this.meta[typeof e == 'string' ? e : e.key];
        }
        get isGeneric() {
            for (let e in this.meta) return !1;
            return !0;
        }
        scrollIntoView() {
            return (this.updated |= Gy), this;
        }
        get scrolledIntoView() {
            return (this.updated & Gy) > 0;
        }
    };
function qy(t, e) {
    return !e || !t ? t : t.bind(e);
}
var Ki = class {
        constructor(e, n, r) {
            (this.name = e), (this.init = qy(n.init, r)), (this.apply = qy(n.apply, r));
        }
    },
    $O = [
        new Ki('doc', {
            init(t) {
                return t.doc || t.schema.topNodeType.createAndFill();
            },
            apply(t) {
                return t.doc;
            },
        }),
        new Ki('selection', {
            init(t, e) {
                return t.selection || fe.atStart(e.doc);
            },
            apply(t) {
                return t.selection;
            },
        }),
        new Ki('storedMarks', {
            init(t) {
                return t.storedMarks || null;
            },
            apply(t, e, n, r) {
                return r.selection.$cursor ? t.storedMarks : null;
            },
        }),
        new Ki('scrollToSelection', {
            init() {
                return 0;
            },
            apply(t, e) {
                return t.scrolledIntoView ? e + 1 : e;
            },
        }),
    ],
    Us = class {
        constructor(e, n) {
            (this.schema = e),
                (this.plugins = []),
                (this.pluginsByKey = Object.create(null)),
                (this.fields = $O.slice()),
                n &&
                    n.forEach((r) => {
                        if (this.pluginsByKey[r.key])
                            throw new RangeError('Adding different instances of a keyed plugin (' + r.key + ')');
                        this.plugins.push(r),
                            (this.pluginsByKey[r.key] = r),
                            r.spec.state && this.fields.push(new Ki(r.key, r.spec.state, r));
                    });
        }
    },
    kl = class t {
        constructor(e) {
            this.config = e;
        }
        get schema() {
            return this.config.schema;
        }
        get plugins() {
            return this.config.plugins;
        }
        apply(e) {
            return this.applyTransaction(e).state;
        }
        filterTransaction(e, n = -1) {
            for (let r = 0; r < this.config.plugins.length; r++)
                if (r != n) {
                    let i = this.config.plugins[r];
                    if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1;
                }
            return !0;
        }
        applyTransaction(e) {
            if (!this.filterTransaction(e)) return { state: this, transactions: [] };
            let n = [e],
                r = this.applyInner(e),
                i = null;
            for (;;) {
                let o = !1;
                for (let s = 0; s < this.config.plugins.length; s++) {
                    let l = this.config.plugins[s];
                    if (l.spec.appendTransaction) {
                        let u = i ? i[s].n : 0,
                            d = i ? i[s].state : this,
                            f = u < n.length && l.spec.appendTransaction.call(l, u ? n.slice(u) : n, d, r);
                        if (f && r.filterTransaction(f, s)) {
                            if ((f.setMeta('appendedTransaction', e), !i)) {
                                i = [];
                                for (let h = 0; h < this.config.plugins.length; h++)
                                    i.push(h < s ? { state: r, n: n.length } : { state: this, n: 0 });
                            }
                            n.push(f), (r = r.applyInner(f)), (o = !0);
                        }
                        i && (i[s] = { state: r, n: n.length });
                    }
                }
                if (!o) return { state: r, transactions: n };
            }
        }
        applyInner(e) {
            if (!e.before.eq(this.doc)) throw new RangeError('Applying a mismatched transaction');
            let n = new t(this.config),
                r = this.config.fields;
            for (let i = 0; i < r.length; i++) {
                let o = r[i];
                n[o.name] = o.apply(e, this[o.name], this, n);
            }
            return n;
        }
        get tr() {
            return new ff(this);
        }
        static create(e) {
            let n = new Us(e.doc ? e.doc.type.schema : e.schema, e.plugins),
                r = new t(n);
            for (let i = 0; i < n.fields.length; i++) r[n.fields[i].name] = n.fields[i].init(e, r);
            return r;
        }
        reconfigure(e) {
            let n = new Us(this.schema, e.plugins),
                r = n.fields,
                i = new t(n);
            for (let o = 0; o < r.length; o++) {
                let s = r[o].name;
                i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(e, i);
            }
            return i;
        }
        toJSON(e) {
            let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
            if (
                (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
                e && typeof e == 'object')
            )
                for (let r in e) {
                    if (r == 'doc' || r == 'selection')
                        throw new RangeError('The JSON fields `doc` and `selection` are reserved');
                    let i = e[r],
                        o = i.spec.state;
                    o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
                }
            return n;
        }
        static fromJSON(e, n, r) {
            if (!n) throw new RangeError('Invalid input for EditorState.fromJSON');
            if (!e.schema) throw new RangeError("Required config field 'schema' missing");
            let i = new Us(e.schema, e.plugins),
                o = new t(i);
            return (
                i.fields.forEach((s) => {
                    if (s.name == 'doc') o.doc = er.fromJSON(e.schema, n.doc);
                    else if (s.name == 'selection') o.selection = fe.fromJSON(o.doc, n.selection);
                    else if (s.name == 'storedMarks')
                        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
                    else {
                        if (r)
                            for (let l in r) {
                                let u = r[l],
                                    d = u.spec.state;
                                if (u.key == s.name && d && d.fromJSON && Object.prototype.hasOwnProperty.call(n, l)) {
                                    o[s.name] = d.fromJSON.call(u, e, n[l], o);
                                    return;
                                }
                            }
                        o[s.name] = s.init(e, o);
                    }
                }),
                o
            );
        }
    };
function Yy(t, e, n) {
    for (let r in t) {
        let i = t[r];
        i instanceof Function ? (i = i.bind(e)) : r == 'handleDOMEvents' && (i = Yy(i, e, {})), (n[r] = i);
    }
    return n;
}
var Oe = class {
        constructor(e) {
            (this.spec = e),
                (this.props = {}),
                e.props && Yy(e.props, this, this.props),
                (this.key = e.key ? e.key.key : Jy('plugin'));
        }
        getState(e) {
            return e[this.key];
        }
    },
    uf = Object.create(null);
function Jy(t) {
    return t in uf ? t + '$' + ++uf[t] : ((uf[t] = 0), t + '$');
}
var ze = class {
    constructor(e = 'key') {
        this.key = Jy(e);
    }
    get(e) {
        return e.config.pluginsByKey[this.key];
    }
    getState(e) {
        return e[this.key];
    }
};
var Yt = function (t) {
        for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
    },
    qs = function (t) {
        let e = t.assignedSlot || t.parentNode;
        return e && e.nodeType == 11 ? e.host : e;
    },
    bf = null,
    Pr = function (t, e, n) {
        let r = bf || (bf = document.createRange());
        return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
    },
    UO = function () {
        bf = null;
    },
    Zi = function (t, e, n, r) {
        return n && (Xy(t, e, n, r, -1) || Xy(t, e, n, r, 1));
    },
    WO = /^(img|br|input|textarea|hr)$/i;
function Xy(t, e, n, r, i) {
    for (;;) {
        if (t == n && e == r) return !0;
        if (e == (i < 0 ? 0 : fr(t))) {
            let o = t.parentNode;
            if (!o || o.nodeType != 1 || Zs(t) || WO.test(t.nodeName) || t.contentEditable == 'false') return !1;
            (e = Yt(t) + (i < 0 ? 0 : 1)), (t = o);
        } else if (t.nodeType == 1) {
            if (((t = t.childNodes[e + (i < 0 ? -1 : 0)]), t.contentEditable == 'false')) return !1;
            e = i < 0 ? fr(t) : 0;
        } else return !1;
    }
}
function fr(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function KO(t, e) {
    for (;;) {
        if (t.nodeType == 3 && e) return t;
        if (t.nodeType == 1 && e > 0) {
            if (t.contentEditable == 'false') return null;
            (t = t.childNodes[e - 1]), (e = fr(t));
        } else if (t.parentNode && !Zs(t)) (e = Yt(t)), (t = t.parentNode);
        else return null;
    }
}
function VO(t, e) {
    for (;;) {
        if (t.nodeType == 3 && e < t.nodeValue.length) return t;
        if (t.nodeType == 1 && e < t.childNodes.length) {
            if (t.contentEditable == 'false') return null;
            (t = t.childNodes[e]), (e = 0);
        } else if (t.parentNode && !Zs(t)) (e = Yt(t) + 1), (t = t.parentNode);
        else return null;
    }
}
function GO(t, e, n) {
    for (let r = e == 0, i = e == fr(t); r || i; ) {
        if (t == n) return !0;
        let o = Yt(t);
        if (((t = t.parentNode), !t)) return !1;
        (r = r && o == 0), (i = i && o == fr(t));
    }
}
function Zs(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
var zl = function (t) {
    return t.focusNode && Zi(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Vi(t, e) {
    let n = document.createEvent('Event');
    return n.initEvent('keydown', !0, !0), (n.keyCode = t), (n.key = n.code = e), n;
}
function qO(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
    return e;
}
function YO(t, e, n) {
    if (t.caretPositionFromPoint)
        try {
            let r = t.caretPositionFromPoint(e, n);
            if (r) return { node: r.offsetNode, offset: r.offset };
        } catch {}
    if (t.caretRangeFromPoint) {
        let r = t.caretRangeFromPoint(e, n);
        if (r) return { node: r.startContainer, offset: r.startOffset };
    }
}
var pr = typeof navigator < 'u' ? navigator : null,
    Zy = typeof document < 'u' ? document : null,
    fi = (pr && pr.userAgent) || '',
    yf = /Edge\/(\d+)/.exec(fi),
    k0 = /MSIE \d/.exec(fi),
    Ef = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(fi),
    vn = !!(k0 || Ef || yf),
    ui = k0 ? document.documentMode : Ef ? +Ef[1] : yf ? +yf[1] : 0,
    rr = !vn && /gecko\/(\d+)/i.test(fi);
rr && +(/Firefox\/(\d+)/.exec(fi) || [0, 0])[1];
var vf = !vn && /Chrome\/(\d+)/.exec(fi),
    dn = !!vf,
    JO = vf ? +vf[1] : 0,
    fn = !vn && !!pr && /Apple Computer/.test(pr.vendor),
    Uo = fn && (/Mobile\/\w+/.test(fi) || (!!pr && pr.maxTouchPoints > 2)),
    zn = Uo || (pr ? /Mac/.test(pr.platform) : !1),
    XO = pr ? /Win/.test(pr.platform) : !1,
    nr = /Android \d/.test(fi),
    js = !!Zy && 'webkitFontSmoothing' in Zy.documentElement.style,
    ZO = js ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function jO(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e
        ? { left: 0, right: e.width, top: 0, bottom: e.height }
        : { left: 0, right: t.documentElement.clientWidth, top: 0, bottom: t.documentElement.clientHeight };
}
function Dr(t, e) {
    return typeof t == 'number' ? t : t[e];
}
function QO(t) {
    let e = t.getBoundingClientRect(),
        n = e.width / t.offsetWidth || 1,
        r = e.height / t.offsetHeight || 1;
    return { left: e.left, right: e.left + t.clientWidth * n, top: e.top, bottom: e.top + t.clientHeight * r };
}
function jy(t, e, n) {
    let r = t.someProp('scrollThreshold') || 0,
        i = t.someProp('scrollMargin') || 5,
        o = t.dom.ownerDocument;
    for (let s = n || t.dom; s; s = qs(s)) {
        if (s.nodeType != 1) continue;
        let l = s,
            u = l == o.body,
            d = u ? jO(o) : QO(l),
            f = 0,
            h = 0;
        if (
            (e.top < d.top + Dr(r, 'top')
                ? (h = -(d.top - e.top + Dr(i, 'top')))
                : e.bottom > d.bottom - Dr(r, 'bottom') &&
                  (h =
                      e.bottom - e.top > d.bottom - d.top
                          ? e.top + Dr(i, 'top') - d.top
                          : e.bottom - d.bottom + Dr(i, 'bottom')),
            e.left < d.left + Dr(r, 'left')
                ? (f = -(d.left - e.left + Dr(i, 'left')))
                : e.right > d.right - Dr(r, 'right') && (f = e.right - d.right + Dr(i, 'right')),
            f || h)
        )
            if (u) o.defaultView.scrollBy(f, h);
            else {
                let m = l.scrollLeft,
                    b = l.scrollTop;
                h && (l.scrollTop += h), f && (l.scrollLeft += f);
                let y = l.scrollLeft - m,
                    v = l.scrollTop - b;
                e = { left: e.left - y, top: e.top - v, right: e.right - y, bottom: e.bottom - v };
            }
        if (u || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
    }
}
function eR(t) {
    let e = t.dom.getBoundingClientRect(),
        n = Math.max(0, e.top),
        r,
        i;
    for (let o = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
        let l = t.root.elementFromPoint(o, s);
        if (!l || l == t.dom || !t.dom.contains(l)) continue;
        let u = l.getBoundingClientRect();
        if (u.top >= n - 20) {
            (r = l), (i = u.top);
            break;
        }
    }
    return { refDOM: r, refTop: i, stack: N0(t.dom) };
}
function N0(t) {
    let e = [],
        n = t.ownerDocument;
    for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = qs(r));
    return e;
}
function tR({ refDOM: t, refTop: e, stack: n }) {
    let r = t ? t.getBoundingClientRect().top : 0;
    O0(n, r == 0 ? 0 : r - e);
}
function O0(t, e) {
    for (let n = 0; n < t.length; n++) {
        let { dom: r, top: i, left: o } = t[n];
        r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != o && (r.scrollLeft = o);
    }
}
var Fo = null;
function nR(t) {
    if (t.setActive) return t.setActive();
    if (Fo) return t.focus(Fo);
    let e = N0(t);
    t.focus(
        Fo == null
            ? {
                  get preventScroll() {
                      return (Fo = { preventScroll: !0 }), !0;
                  },
              }
            : void 0,
    ),
        Fo || ((Fo = !1), O0(e, 0));
}
function R0(t, e) {
    let n,
        r = 2e8,
        i,
        o = 0,
        s = e.top,
        l = e.top,
        u,
        d;
    for (let f = t.firstChild, h = 0; f; f = f.nextSibling, h++) {
        let m;
        if (f.nodeType == 1) m = f.getClientRects();
        else if (f.nodeType == 3) m = Pr(f).getClientRects();
        else continue;
        for (let b = 0; b < m.length; b++) {
            let y = m[b];
            if (y.top <= s && y.bottom >= l) {
                (s = Math.max(y.bottom, s)), (l = Math.min(y.top, l));
                let v = y.left > e.left ? y.left - e.left : y.right < e.left ? e.left - y.right : 0;
                if (v < r) {
                    (n = f),
                        (r = v),
                        (i = v && n.nodeType == 3 ? { left: y.right < e.left ? y.right : y.left, top: e.top } : e),
                        f.nodeType == 1 && v && (o = h + (e.left >= (y.left + y.right) / 2 ? 1 : 0));
                    continue;
                }
            } else
                y.top > e.top &&
                    !u &&
                    y.left <= e.left &&
                    y.right >= e.left &&
                    ((u = f), (d = { left: Math.max(y.left, Math.min(y.right, e.left)), top: y.top }));
            !n && ((e.left >= y.right && e.top >= y.top) || (e.left >= y.left && e.top >= y.bottom)) && (o = h + 1);
        }
    }
    return (
        !n && u && ((n = u), (i = d), (r = 0)),
        n && n.nodeType == 3 ? rR(n, i) : !n || (r && n.nodeType == 1) ? { node: t, offset: o } : R0(n, i)
    );
}
function rR(t, e) {
    let n = t.nodeValue.length,
        r = document.createRange();
    for (let i = 0; i < n; i++) {
        r.setEnd(t, i + 1), r.setStart(t, i);
        let o = ai(r, 1);
        if (o.top != o.bottom && Pf(e, o)) return { node: t, offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
    }
    return { node: t, offset: 0 };
}
function Pf(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function iR(t, e) {
    let n = t.parentNode;
    return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function oR(t, e, n) {
    let { node: r, offset: i } = R0(e, n),
        o = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let s = r.getBoundingClientRect();
        o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
    }
    return t.docView.posFromDOM(r, i, o);
}
function sR(t, e, n, r) {
    let i = -1;
    for (let o = e, s = !1; o != t.dom; ) {
        let l = t.docView.nearestDesc(o, !0);
        if (!l) return null;
        if (l.dom.nodeType == 1 && ((l.node.isBlock && l.parent && !s) || !l.contentDOM)) {
            let u = l.dom.getBoundingClientRect();
            if (
                (l.node.isBlock &&
                    l.parent &&
                    !s &&
                    ((s = !0),
                    u.left > r.left || u.top > r.top
                        ? (i = l.posBefore)
                        : (u.right < r.left || u.bottom < r.top) && (i = l.posAfter)),
                !l.contentDOM && i < 0 && !l.node.isText)
            )
                return (l.node.isBlock ? r.top < (u.top + u.bottom) / 2 : r.left < (u.left + u.right) / 2)
                    ? l.posBefore
                    : l.posAfter;
        }
        o = l.dom.parentNode;
    }
    return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function I0(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
        for (
            let i = Math.max(0, Math.min(r - 1, Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2)), o = i;
            ;

        ) {
            let s = t.childNodes[o];
            if (s.nodeType == 1) {
                let l = s.getClientRects();
                for (let u = 0; u < l.length; u++) {
                    let d = l[u];
                    if (Pf(e, d)) return I0(s, e, d);
                }
            }
            if ((o = (o + 1) % r) == i) break;
        }
    return t;
}
function aR(t, e) {
    let n = t.dom.ownerDocument,
        r,
        i = 0,
        o = YO(n, e.left, e.top);
    o && ({ node: r, offset: i } = o);
    let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top),
        l;
    if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
        let d = t.dom.getBoundingClientRect();
        if (!Pf(e, d) || ((s = I0(t.dom, e, d)), !s)) return null;
    }
    if (fn) for (let d = s; r && d; d = qs(d)) d.draggable && (r = void 0);
    if (((s = iR(s, e)), r)) {
        if (rr && r.nodeType == 1 && ((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)) {
            let f = r.childNodes[i],
                h;
            f.nodeName == 'IMG' && (h = f.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
        }
        let d;
        js &&
            i &&
            r.nodeType == 1 &&
            (d = r.childNodes[i - 1]).nodeType == 1 &&
            d.contentEditable == 'false' &&
            d.getBoundingClientRect().top >= e.top &&
            i--,
            r == t.dom &&
            i == r.childNodes.length - 1 &&
            r.lastChild.nodeType == 1 &&
            e.top > r.lastChild.getBoundingClientRect().bottom
                ? (l = t.state.doc.content.size)
                : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != 'BR') && (l = sR(t, r, i, e));
    }
    l == null && (l = oR(t, s, e));
    let u = t.docView.nearestDesc(s, !0);
    return { pos: l, inside: u ? u.posAtStart - u.border : -1 };
}
function Qy(t) {
    return t.top < t.bottom || t.left < t.right;
}
function ai(t, e) {
    let n = t.getClientRects();
    if (n.length) {
        let r = n[e < 0 ? 0 : n.length - 1];
        if (Qy(r)) return r;
    }
    return Array.prototype.find.call(n, Qy) || t.getBoundingClientRect();
}
var lR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function L0(t, e, n) {
    let { node: r, offset: i, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
        s = js || rr;
    if (r.nodeType == 3)
        if (s && (lR.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
            let u = ai(Pr(r, i, i), n);
            if (rr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
                let d = ai(Pr(r, i - 1, i - 1), -1);
                if (d.top == u.top) {
                    let f = ai(Pr(r, i, i + 1), -1);
                    if (f.top != u.top) return Ks(f, f.left < d.left);
                }
            }
            return u;
        } else {
            let u = i,
                d = i,
                f = n < 0 ? 1 : -1;
            return (
                n < 0 && !i ? (d++, (f = -1)) : n >= 0 && i == r.nodeValue.length ? (u--, (f = 1)) : n < 0 ? u-- : d++,
                Ks(ai(Pr(r, u, d), f), f < 0)
            );
        }
    if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
        if (o == null && i && (n < 0 || i == fr(r))) {
            let u = r.childNodes[i - 1];
            if (u.nodeType == 1) return pf(u.getBoundingClientRect(), !1);
        }
        if (o == null && i < fr(r)) {
            let u = r.childNodes[i];
            if (u.nodeType == 1) return pf(u.getBoundingClientRect(), !0);
        }
        return pf(r.getBoundingClientRect(), n >= 0);
    }
    if (o == null && i && (n < 0 || i == fr(r))) {
        let u = r.childNodes[i - 1],
            d =
                u.nodeType == 3
                    ? Pr(u, fr(u) - (s ? 0 : 1))
                    : u.nodeType == 1 && (u.nodeName != 'BR' || !u.nextSibling)
                      ? u
                      : null;
        if (d) return Ks(ai(d, 1), !1);
    }
    if (o == null && i < fr(r)) {
        let u = r.childNodes[i];
        for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords; ) u = u.nextSibling;
        let d = u ? (u.nodeType == 3 ? Pr(u, 0, s ? 0 : 1) : u.nodeType == 1 ? u : null) : null;
        if (d) return Ks(ai(d, -1), !0);
    }
    return Ks(ai(r.nodeType == 3 ? Pr(r) : r, -n), n >= 0);
}
function Ks(t, e) {
    if (t.width == 0) return t;
    let n = e ? t.left : t.right;
    return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function pf(t, e) {
    if (t.height == 0) return t;
    let n = e ? t.top : t.bottom;
    return { top: n, bottom: n, left: t.left, right: t.right };
}
function D0(t, e, n) {
    let r = t.state,
        i = t.root.activeElement;
    r != e && t.updateState(e), i != t.dom && t.focus();
    try {
        return n();
    } finally {
        r != e && t.updateState(r), i != t.dom && i && i.focus();
    }
}
function cR(t, e, n) {
    let r = e.selection,
        i = n == 'up' ? r.$from : r.$to;
    return D0(t, e, () => {
        let { node: o } = t.docView.domFromPos(i.pos, n == 'up' ? -1 : 1);
        for (;;) {
            let l = t.docView.nearestDesc(o, !0);
            if (!l) break;
            if (l.node.isBlock) {
                o = l.contentDOM || l.dom;
                break;
            }
            o = l.dom.parentNode;
        }
        let s = L0(t, i.pos, 1);
        for (let l = o.firstChild; l; l = l.nextSibling) {
            let u;
            if (l.nodeType == 1) u = l.getClientRects();
            else if (l.nodeType == 3) u = Pr(l, 0, l.nodeValue.length).getClientRects();
            else continue;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                if (
                    f.bottom > f.top + 1 &&
                    (n == 'up' ? s.top - f.top > (f.bottom - s.top) * 2 : f.bottom - s.bottom > (s.bottom - f.top) * 2)
                )
                    return !1;
            }
        }
        return !0;
    });
}
var uR = /[\u0590-\u08ac]/;
function dR(t, e, n) {
    let { $head: r } = e.selection;
    if (!r.parent.isTextblock) return !1;
    let i = r.parentOffset,
        o = !i,
        s = i == r.parent.content.size,
        l = t.domSelection();
    return !uR.test(r.parent.textContent) || !l.modify
        ? n == 'left' || n == 'backward'
            ? o
            : s
        : D0(t, e, () => {
              let { focusNode: u, focusOffset: d, anchorNode: f, anchorOffset: h } = t.domSelectionRange(),
                  m = l.caretBidiLevel;
              l.modify('move', n, 'character');
              let b = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
                  { focusNode: y, focusOffset: v } = t.domSelectionRange(),
                  x = (y && !b.contains(y.nodeType == 1 ? y : y.parentNode)) || (u == y && d == v);
              try {
                  l.collapse(f, h), u && (u != f || d != h) && l.extend && l.extend(u, d);
              } catch {}
              return m != null && (l.caretBidiLevel = m), x;
          });
}
var e0 = null,
    t0 = null,
    n0 = !1;
function fR(t, e, n) {
    return e0 == e && t0 == n ? n0 : ((e0 = e), (t0 = n), (n0 = n == 'up' || n == 'down' ? cR(t, e, n) : dR(t, e, n)));
}
var $n = 0,
    r0 = 1,
    Gi = 2,
    hr = 3,
    ji = class {
        constructor(e, n, r, i) {
            (this.parent = e),
                (this.children = n),
                (this.dom = r),
                (this.contentDOM = i),
                (this.dirty = $n),
                (r.pmViewDesc = this);
        }
        matchesWidget(e) {
            return !1;
        }
        matchesMark(e) {
            return !1;
        }
        matchesNode(e, n, r) {
            return !1;
        }
        matchesHack(e) {
            return !1;
        }
        parseRule() {
            return null;
        }
        stopEvent(e) {
            return !1;
        }
        get size() {
            let e = 0;
            for (let n = 0; n < this.children.length; n++) e += this.children[n].size;
            return e;
        }
        get border() {
            return 0;
        }
        destroy() {
            (this.parent = void 0), this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
            for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
        }
        posBeforeChild(e) {
            for (let n = 0, r = this.posAtStart; ; n++) {
                let i = this.children[n];
                if (i == e) return r;
                r += i.size;
            }
        }
        get posBefore() {
            return this.parent.posBeforeChild(this);
        }
        get posAtStart() {
            return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
        }
        get posAfter() {
            return this.posBefore + this.size;
        }
        get posAtEnd() {
            return this.posAtStart + this.size - 2 * this.border;
        }
        localPosFromDOM(e, n, r) {
            if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
                if (r < 0) {
                    let o, s;
                    if (e == this.contentDOM) o = e.childNodes[n - 1];
                    else {
                        for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
                        o = e.previousSibling;
                    }
                    for (; o && !((s = o.pmViewDesc) && s.parent == this); ) o = o.previousSibling;
                    return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
                } else {
                    let o, s;
                    if (e == this.contentDOM) o = e.childNodes[n];
                    else {
                        for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
                        o = e.nextSibling;
                    }
                    for (; o && !((s = o.pmViewDesc) && s.parent == this); ) o = o.nextSibling;
                    return o ? this.posBeforeChild(s) : this.posAtEnd;
                }
            let i;
            if (e == this.dom && this.contentDOM) i = n > Yt(this.contentDOM);
            else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
                i = e.compareDocumentPosition(this.contentDOM) & 2;
            else if (this.dom.firstChild) {
                if (n == 0)
                    for (let o = e; ; o = o.parentNode) {
                        if (o == this.dom) {
                            i = !1;
                            break;
                        }
                        if (o.previousSibling) break;
                    }
                if (i == null && n == e.childNodes.length)
                    for (let o = e; ; o = o.parentNode) {
                        if (o == this.dom) {
                            i = !0;
                            break;
                        }
                        if (o.nextSibling) break;
                    }
            }
            return (i ?? r > 0) ? this.posAtEnd : this.posAtStart;
        }
        nearestDesc(e, n = !1) {
            for (let r = !0, i = e; i; i = i.parentNode) {
                let o = this.getDesc(i),
                    s;
                if (o && (!n || o.node))
                    if (
                        r &&
                        (s = o.nodeDOM) &&
                        !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e)
                    )
                        r = !1;
                    else return o;
            }
        }
        getDesc(e) {
            let n = e.pmViewDesc;
            for (let r = n; r; r = r.parent) if (r == this) return n;
        }
        posFromDOM(e, n, r) {
            for (let i = e; i; i = i.parentNode) {
                let o = this.getDesc(i);
                if (o) return o.localPosFromDOM(e, n, r);
            }
            return -1;
        }
        descAt(e) {
            for (let n = 0, r = 0; n < this.children.length; n++) {
                let i = this.children[n],
                    o = r + i.size;
                if (r == e && o != r) {
                    for (; !i.border && i.children.length; ) i = i.children[0];
                    return i;
                }
                if (e < o) return i.descAt(e - r - i.border);
                r = o;
            }
        }
        domFromPos(e, n) {
            if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
            let r = 0,
                i = 0;
            for (let o = 0; r < this.children.length; r++) {
                let s = this.children[r],
                    l = o + s.size;
                if (l > e || s instanceof Rl) {
                    i = e - o;
                    break;
                }
                o = l;
            }
            if (i) return this.children[r].domFromPos(i - this.children[r].border, n);
            for (let o; r && !(o = this.children[r - 1]).size && o instanceof Nl && o.side >= 0; r--);
            if (n <= 0) {
                let o,
                    s = !0;
                for (
                    ;
                    (o = r ? this.children[r - 1] : null), !(!o || o.dom.parentNode == this.contentDOM);
                    r--, s = !1
                );
                return o && n && s && !o.border && !o.domAtom
                    ? o.domFromPos(o.size, n)
                    : { node: this.contentDOM, offset: o ? Yt(o.dom) + 1 : 0 };
            } else {
                let o,
                    s = !0;
                for (
                    ;
                    (o = r < this.children.length ? this.children[r] : null),
                        !(!o || o.dom.parentNode == this.contentDOM);
                    r++, s = !1
                );
                return o && s && !o.border && !o.domAtom
                    ? o.domFromPos(0, n)
                    : { node: this.contentDOM, offset: o ? Yt(o.dom) : this.contentDOM.childNodes.length };
            }
        }
        parseRange(e, n, r = 0) {
            if (this.children.length == 0)
                return {
                    node: this.contentDOM,
                    from: e,
                    to: n,
                    fromOffset: 0,
                    toOffset: this.contentDOM.childNodes.length,
                };
            let i = -1,
                o = -1;
            for (let s = r, l = 0; ; l++) {
                let u = this.children[l],
                    d = s + u.size;
                if (i == -1 && e <= d) {
                    let f = s + u.border;
                    if (e >= f && n <= d - u.border && u.node && u.contentDOM && this.contentDOM.contains(u.contentDOM))
                        return u.parseRange(e, n, f);
                    e = s;
                    for (let h = l; h > 0; h--) {
                        let m = this.children[h - 1];
                        if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
                            i = Yt(m.dom) + 1;
                            break;
                        }
                        e -= m.size;
                    }
                    i == -1 && (i = 0);
                }
                if (i > -1 && (d > n || l == this.children.length - 1)) {
                    n = d;
                    for (let f = l + 1; f < this.children.length; f++) {
                        let h = this.children[f];
                        if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
                            o = Yt(h.dom);
                            break;
                        }
                        n += h.size;
                    }
                    o == -1 && (o = this.contentDOM.childNodes.length);
                    break;
                }
                s = d;
            }
            return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: o };
        }
        emptyChildAt(e) {
            if (this.border || !this.contentDOM || !this.children.length) return !1;
            let n = this.children[e < 0 ? 0 : this.children.length - 1];
            return n.size == 0 || n.emptyChildAt(e);
        }
        domAfterPos(e) {
            let { node: n, offset: r } = this.domFromPos(e, 0);
            if (n.nodeType != 1 || r == n.childNodes.length) throw new RangeError('No node after pos ' + e);
            return n.childNodes[r];
        }
        setSelection(e, n, r, i = !1) {
            let o = Math.min(e, n),
                s = Math.max(e, n);
            for (let m = 0, b = 0; m < this.children.length; m++) {
                let y = this.children[m],
                    v = b + y.size;
                if (o > b && s < v) return y.setSelection(e - b - y.border, n - b - y.border, r, i);
                b = v;
            }
            let l = this.domFromPos(e, e ? -1 : 1),
                u = n == e ? l : this.domFromPos(n, n ? -1 : 1),
                d = r.getSelection(),
                f = !1;
            if ((rr || fn) && e == n) {
                let { node: m, offset: b } = l;
                if (m.nodeType == 3) {
                    if (
                        ((f = !!(
                            b &&
                            m.nodeValue[b - 1] ==
                                `
`
                        )),
                        f && b == m.nodeValue.length)
                    )
                        for (let y = m, v; y; y = y.parentNode) {
                            if ((v = y.nextSibling)) {
                                v.nodeName == 'BR' && (l = u = { node: v.parentNode, offset: Yt(v) + 1 });
                                break;
                            }
                            let x = y.pmViewDesc;
                            if (x && x.node && x.node.isBlock) break;
                        }
                } else {
                    let y = m.childNodes[b - 1];
                    f = y && (y.nodeName == 'BR' || y.contentEditable == 'false');
                }
            }
            if (rr && d.focusNode && d.focusNode != u.node && d.focusNode.nodeType == 1) {
                let m = d.focusNode.childNodes[d.focusOffset];
                m && m.contentEditable == 'false' && (i = !0);
            }
            if (
                !(i || (f && fn)) &&
                Zi(l.node, l.offset, d.anchorNode, d.anchorOffset) &&
                Zi(u.node, u.offset, d.focusNode, d.focusOffset)
            )
                return;
            let h = !1;
            if ((d.extend || e == n) && !f) {
                d.collapse(l.node, l.offset);
                try {
                    e != n && d.extend(u.node, u.offset), (h = !0);
                } catch {}
            }
            if (!h) {
                if (e > n) {
                    let b = l;
                    (l = u), (u = b);
                }
                let m = document.createRange();
                m.setEnd(u.node, u.offset), m.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(m);
            }
        }
        ignoreMutation(e) {
            return !this.contentDOM && e.type != 'selection';
        }
        get contentLost() {
            return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
        }
        markDirty(e, n) {
            for (let r = 0, i = 0; i < this.children.length; i++) {
                let o = this.children[i],
                    s = r + o.size;
                if (r == s ? e <= s && n >= r : e < s && n > r) {
                    let l = r + o.border,
                        u = s - o.border;
                    if (e >= l && n <= u) {
                        (this.dirty = e == r || n == s ? Gi : r0),
                            e == l && n == u && (o.contentLost || o.dom.parentNode != this.contentDOM)
                                ? (o.dirty = hr)
                                : o.markDirty(e - l, n - l);
                        return;
                    } else
                        o.dirty =
                            o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length
                                ? Gi
                                : hr;
                }
                r = s;
            }
            this.dirty = Gi;
        }
        markParentsDirty() {
            let e = 1;
            for (let n = this.parent; n; n = n.parent, e++) {
                let r = e == 1 ? Gi : r0;
                n.dirty < r && (n.dirty = r);
            }
        }
        get domAtom() {
            return !1;
        }
        get ignoreForCoords() {
            return !1;
        }
        isText(e) {
            return !1;
        }
    },
    Nl = class extends ji {
        constructor(e, n, r, i) {
            let o,
                s = n.type.toDOM;
            if (
                (typeof s == 'function' &&
                    (s = s(r, () => {
                        if (!o) return i;
                        if (o.parent) return o.parent.posBeforeChild(o);
                    })),
                !n.type.spec.raw)
            ) {
                if (s.nodeType != 1) {
                    let l = document.createElement('span');
                    l.appendChild(s), (s = l);
                }
                (s.contentEditable = 'false'), s.classList.add('ProseMirror-widget');
            }
            super(e, [], s, null), (this.widget = n), (this.widget = n), (o = this);
        }
        matchesWidget(e) {
            return this.dirty == $n && e.type.eq(this.widget.type);
        }
        parseRule() {
            return { ignore: !0 };
        }
        stopEvent(e) {
            let n = this.widget.spec.stopEvent;
            return n ? n(e) : !1;
        }
        ignoreMutation(e) {
            return e.type != 'selection' || this.widget.spec.ignoreSelection;
        }
        destroy() {
            this.widget.type.destroy(this.dom), super.destroy();
        }
        get domAtom() {
            return !0;
        }
        get side() {
            return this.widget.type.side;
        }
    },
    wf = class extends ji {
        constructor(e, n, r, i) {
            super(e, [], n, null), (this.textDOM = r), (this.text = i);
        }
        get size() {
            return this.text.length;
        }
        localPosFromDOM(e, n) {
            return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
        }
        domFromPos(e) {
            return { node: this.textDOM, offset: e };
        }
        ignoreMutation(e) {
            return e.type === 'characterData' && e.target.nodeValue == e.oldValue;
        }
    },
    Wo = class t extends ji {
        constructor(e, n, r, i) {
            super(e, [], r, i), (this.mark = n);
        }
        static create(e, n, r, i) {
            let o = i.nodeViews[n.type.name],
                s = o && o(n, i, r);
            return (
                (!s || !s.dom) && (s = Rr.renderSpec(document, n.type.spec.toDOM(n, r))),
                new t(e, n, s.dom, s.contentDOM || s.dom)
            );
        }
        parseRule() {
            return this.dirty & hr || this.mark.type.spec.reparseInView
                ? null
                : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
        }
        matchesMark(e) {
            return this.dirty != hr && this.mark.eq(e);
        }
        markDirty(e, n) {
            if ((super.markDirty(e, n), this.dirty != $n)) {
                let r = this.parent;
                for (; !r.node; ) r = r.parent;
                r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = $n);
            }
        }
        slice(e, n, r) {
            let i = t.create(this.parent, this.mark, !0, r),
                o = this.children,
                s = this.size;
            n < s && (o = Mf(o, n, s, r)), e > 0 && (o = Mf(o, 0, e, r));
            for (let l = 0; l < o.length; l++) o[l].parent = i;
            return (i.children = o), i;
        }
    },
    di = class t extends ji {
        constructor(e, n, r, i, o, s, l, u, d) {
            super(e, [], o, s), (this.node = n), (this.outerDeco = r), (this.innerDeco = i), (this.nodeDOM = l);
        }
        static create(e, n, r, i, o, s) {
            let l = o.nodeViews[n.type.name],
                u,
                d =
                    l &&
                    l(
                        n,
                        o,
                        () => {
                            if (!u) return s;
                            if (u.parent) return u.parent.posBeforeChild(u);
                        },
                        r,
                        i,
                    ),
                f = d && d.dom,
                h = d && d.contentDOM;
            if (n.isText) {
                if (!f) f = document.createTextNode(n.text);
                else if (f.nodeType != 3) throw new RangeError('Text must be rendered as a DOM text node');
            } else f || ({ dom: f, contentDOM: h } = Rr.renderSpec(document, n.type.spec.toDOM(n)));
            !h &&
                !n.isText &&
                f.nodeName != 'BR' &&
                (f.hasAttribute('contenteditable') || (f.contentEditable = 'false'),
                n.type.spec.draggable && (f.draggable = !0));
            let m = f;
            return (
                (f = F0(f, r, n)),
                d
                    ? (u = new xf(e, n, r, i, f, h || null, m, d, o, s + 1))
                    : n.isText
                      ? new Ol(e, n, r, i, f, m, o)
                      : new t(e, n, r, i, f, h || null, m, o, s + 1)
            );
        }
        parseRule() {
            if (this.node.type.spec.reparseInView) return null;
            let e = { node: this.node.type.name, attrs: this.node.attrs };
            if ((this.node.type.whitespace == 'pre' && (e.preserveWhitespace = 'full'), !this.contentDOM))
                e.getContent = () => this.node.content;
            else if (!this.contentLost) e.contentElement = this.contentDOM;
            else {
                for (let n = this.children.length - 1; n >= 0; n--) {
                    let r = this.children[n];
                    if (this.dom.contains(r.dom.parentNode)) {
                        e.contentElement = r.dom.parentNode;
                        break;
                    }
                }
                e.contentElement || (e.getContent = () => K.empty);
            }
            return e;
        }
        matchesNode(e, n, r) {
            return this.dirty == $n && e.eq(this.node) && Sf(n, this.outerDeco) && r.eq(this.innerDeco);
        }
        get size() {
            return this.node.nodeSize;
        }
        get border() {
            return this.node.isLeaf ? 0 : 1;
        }
        updateChildren(e, n) {
            let r = this.node.inlineContent,
                i = n,
                o = e.composing ? this.localCompositionInfo(e, n) : null,
                s = o && o.pos > -1 ? o : null,
                l = o && o.pos < 0,
                u = new Tf(this, s && s.node, e);
            gR(
                this.node,
                this.innerDeco,
                (d, f, h) => {
                    d.spec.marks
                        ? u.syncToMarks(d.spec.marks, r, e)
                        : d.type.side >= 0 &&
                          !h &&
                          u.syncToMarks(f == this.node.childCount ? Je.none : this.node.child(f).marks, r, e),
                        u.placeWidget(d, e, i);
                },
                (d, f, h, m) => {
                    u.syncToMarks(d.marks, r, e);
                    let b;
                    u.findNodeMatch(d, f, h, m) ||
                        (l &&
                            e.state.selection.from > i &&
                            e.state.selection.to < i + d.nodeSize &&
                            (b = u.findIndexWithChild(o.node)) > -1 &&
                            u.updateNodeAt(d, f, h, b, e)) ||
                        u.updateNextNode(d, f, h, e, m, i) ||
                        u.addNode(d, f, h, e, i),
                        (i += d.nodeSize);
                },
            ),
                u.syncToMarks([], r, e),
                this.node.isTextblock && u.addTextblockHacks(),
                u.destroyRest(),
                (u.changed || this.dirty == Gi) &&
                    (s && this.protectLocalComposition(e, s),
                    P0(this.contentDOM, this.children, e),
                    Uo && bR(this.dom));
        }
        localCompositionInfo(e, n) {
            let { from: r, to: i } = e.state.selection;
            if (!(e.state.selection instanceof ce) || r < n || i > n + this.node.content.size) return null;
            let o = e.input.compositionNode;
            if (!o || !this.dom.contains(o.parentNode)) return null;
            if (this.node.inlineContent) {
                let s = o.nodeValue,
                    l = yR(this.node.content, s, r - n, i - n);
                return l < 0 ? null : { node: o, pos: l, text: s };
            } else return { node: o, pos: -1, text: '' };
        }
        protectLocalComposition(e, { node: n, pos: r, text: i }) {
            if (this.getDesc(n)) return;
            let o = n;
            for (; o.parentNode != this.contentDOM; o = o.parentNode) {
                for (; o.previousSibling; ) o.parentNode.removeChild(o.previousSibling);
                for (; o.nextSibling; ) o.parentNode.removeChild(o.nextSibling);
                o.pmViewDesc && (o.pmViewDesc = void 0);
            }
            let s = new wf(this, o, n, i);
            e.input.compositionNodes.push(s), (this.children = Mf(this.children, r, r + i.length, e, s));
        }
        update(e, n, r, i) {
            return this.dirty == hr || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
        }
        updateInner(e, n, r, i) {
            this.updateOuterDeco(n),
                (this.node = e),
                (this.innerDeco = r),
                this.contentDOM && this.updateChildren(i, this.posAtStart),
                (this.dirty = $n);
        }
        updateOuterDeco(e) {
            if (Sf(e, this.outerDeco)) return;
            let n = this.nodeDOM.nodeType != 1,
                r = this.dom;
            (this.dom = B0(this.dom, this.nodeDOM, _f(this.outerDeco, this.node, n), _f(e, this.node, n))),
                this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
                (this.outerDeco = e);
        }
        selectNode() {
            this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add('ProseMirror-selectednode'),
                (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
        }
        deselectNode() {
            this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove('ProseMirror-selectednode'),
                (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute('draggable');
        }
        get domAtom() {
            return this.node.isAtom;
        }
    };
function i0(t, e, n, r, i) {
    F0(r, e, t);
    let o = new di(void 0, t, e, n, r, r, r, i, 0);
    return o.contentDOM && o.updateChildren(i, 0), o;
}
var Ol = class t extends di {
        constructor(e, n, r, i, o, s, l) {
            super(e, n, r, i, o, null, s, l, 0);
        }
        parseRule() {
            let e = this.nodeDOM.parentNode;
            for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
            return { skip: e || !0 };
        }
        update(e, n, r, i) {
            return this.dirty == hr || (this.dirty != $n && !this.inParent()) || !e.sameMarkup(this.node)
                ? !1
                : (this.updateOuterDeco(n),
                  (this.dirty != $n || e.text != this.node.text) &&
                      e.text != this.nodeDOM.nodeValue &&
                      ((this.nodeDOM.nodeValue = e.text), i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
                  (this.node = e),
                  (this.dirty = $n),
                  !0);
        }
        inParent() {
            let e = this.parent.contentDOM;
            for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
            return !1;
        }
        domFromPos(e) {
            return { node: this.nodeDOM, offset: e };
        }
        localPosFromDOM(e, n, r) {
            return e == this.nodeDOM
                ? this.posAtStart + Math.min(n, this.node.text.length)
                : super.localPosFromDOM(e, n, r);
        }
        ignoreMutation(e) {
            return e.type != 'characterData' && e.type != 'selection';
        }
        slice(e, n, r) {
            let i = this.node.cut(e, n),
                o = document.createTextNode(i.text);
            return new t(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
        }
        markDirty(e, n) {
            super.markDirty(e, n),
                this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = hr);
        }
        get domAtom() {
            return !1;
        }
        isText(e) {
            return this.node.text == e;
        }
    },
    Rl = class extends ji {
        parseRule() {
            return { ignore: !0 };
        }
        matchesHack(e) {
            return this.dirty == $n && this.dom.nodeName == e;
        }
        get domAtom() {
            return !0;
        }
        get ignoreForCoords() {
            return this.dom.nodeName == 'IMG';
        }
    },
    xf = class extends di {
        constructor(e, n, r, i, o, s, l, u, d, f) {
            super(e, n, r, i, o, s, l, d, f), (this.spec = u);
        }
        update(e, n, r, i) {
            if (this.dirty == hr) return !1;
            if (this.spec.update) {
                let o = this.spec.update(e, n, r);
                return o && this.updateInner(e, n, r, i), o;
            } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
        }
        selectNode() {
            this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
        }
        deselectNode() {
            this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
        }
        setSelection(e, n, r, i) {
            this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i);
        }
        destroy() {
            this.spec.destroy && this.spec.destroy(), super.destroy();
        }
        stopEvent(e) {
            return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
        }
        ignoreMutation(e) {
            return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
        }
    };
function P0(t, e, n) {
    let r = t.firstChild,
        i = !1;
    for (let o = 0; o < e.length; o++) {
        let s = e[o],
            l = s.dom;
        if (l.parentNode == t) {
            for (; l != r; ) (r = o0(r)), (i = !0);
            r = r.nextSibling;
        } else (i = !0), t.insertBefore(l, r);
        if (s instanceof Wo) {
            let u = r ? r.previousSibling : t.lastChild;
            P0(s.contentDOM, s.children, n), (r = u ? u.nextSibling : t.firstChild);
        }
    }
    for (; r; ) (r = o0(r)), (i = !0);
    i && n.trackWrites == t && (n.trackWrites = null);
}
var Vs = function (t) {
    t && (this.nodeName = t);
};
Vs.prototype = Object.create(null);
var qi = [new Vs()];
function _f(t, e, n) {
    if (t.length == 0) return qi;
    let r = n ? qi[0] : new Vs(),
        i = [r];
    for (let o = 0; o < t.length; o++) {
        let s = t[o].type.attrs;
        if (s) {
            s.nodeName && i.push((r = new Vs(s.nodeName)));
            for (let l in s) {
                let u = s[l];
                u != null &&
                    (n && i.length == 1 && i.push((r = new Vs(e.isInline ? 'span' : 'div'))),
                    l == 'class'
                        ? (r.class = (r.class ? r.class + ' ' : '') + u)
                        : l == 'style'
                          ? (r.style = (r.style ? r.style + ';' : '') + u)
                          : l != 'nodeName' && (r[l] = u));
            }
        }
    }
    return i;
}
function B0(t, e, n, r) {
    if (n == qi && r == qi) return e;
    let i = e;
    for (let o = 0; o < r.length; o++) {
        let s = r[o],
            l = n[o];
        if (o) {
            let u;
            (l && l.nodeName == s.nodeName && i != t && (u = i.parentNode) && u.nodeName.toLowerCase() == s.nodeName) ||
                ((u = document.createElement(s.nodeName)), (u.pmIsDeco = !0), u.appendChild(i), (l = qi[0])),
                (i = u);
        }
        pR(i, l || qi[0], s);
    }
    return i;
}
function pR(t, e, n) {
    for (let r in e) r != 'class' && r != 'style' && r != 'nodeName' && !(r in n) && t.removeAttribute(r);
    for (let r in n) r != 'class' && r != 'style' && r != 'nodeName' && n[r] != e[r] && t.setAttribute(r, n[r]);
    if (e.class != n.class) {
        let r = e.class ? e.class.split(' ').filter(Boolean) : [],
            i = n.class ? n.class.split(' ').filter(Boolean) : [];
        for (let o = 0; o < r.length; o++) i.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
        for (let o = 0; o < i.length; o++) r.indexOf(i[o]) == -1 && t.classList.add(i[o]);
        t.classList.length == 0 && t.removeAttribute('class');
    }
    if (e.style != n.style) {
        if (e.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
                i;
            for (; (i = r.exec(e.style)); ) t.style.removeProperty(i[1]);
        }
        n.style && (t.style.cssText += n.style);
    }
}
function F0(t, e, n) {
    return B0(t, t, qi, _f(e, n, t.nodeType != 1));
}
function Sf(t, e) {
    if (t.length != e.length) return !1;
    for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
    return !0;
}
function o0(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
}
var Tf = class {
    constructor(e, n, r) {
        (this.lock = n),
            (this.view = r),
            (this.index = 0),
            (this.stack = []),
            (this.changed = !1),
            (this.top = e),
            (this.preMatch = hR(e.node.content, e));
    }
    destroyBetween(e, n) {
        if (e != n) {
            for (let r = e; r < n; r++) this.top.children[r].destroy();
            this.top.children.splice(e, n - e), (this.changed = !0);
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
    }
    syncToMarks(e, n, r) {
        let i = 0,
            o = this.stack.length >> 1,
            s = Math.min(o, e.length);
        for (
            ;
            i < s &&
            (i == o - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(e[i]) &&
            e[i].type.spec.spanning !== !1;

        )
            i++;
        for (; i < o; )
            this.destroyRest(),
                (this.top.dirty = $n),
                (this.index = this.stack.pop()),
                (this.top = this.stack.pop()),
                o--;
        for (; o < e.length; ) {
            this.stack.push(this.top, this.index + 1);
            let l = -1;
            for (let u = this.index; u < Math.min(this.index + 3, this.top.children.length); u++) {
                let d = this.top.children[u];
                if (d.matchesMark(e[o]) && !this.isLocked(d.dom)) {
                    l = u;
                    break;
                }
            }
            if (l > -1)
                l > this.index && ((this.changed = !0), this.destroyBetween(this.index, l)),
                    (this.top = this.top.children[this.index]);
            else {
                let u = Wo.create(this.top, e[o], n, r);
                this.top.children.splice(this.index, 0, u), (this.top = u), (this.changed = !0);
            }
            (this.index = 0), o++;
        }
    }
    findNodeMatch(e, n, r, i) {
        let o = -1,
            s;
        if (
            i >= this.preMatch.index &&
            (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top &&
            s.matchesNode(e, n, r)
        )
            o = this.top.children.indexOf(s, this.index);
        else
            for (let l = this.index, u = Math.min(this.top.children.length, l + 5); l < u; l++) {
                let d = this.top.children[l];
                if (d.matchesNode(e, n, r) && !this.preMatch.matched.has(d)) {
                    o = l;
                    break;
                }
            }
        return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
    }
    updateNodeAt(e, n, r, i, o) {
        let s = this.top.children[i];
        return (
            s.dirty == hr && s.dom == s.contentDOM && (s.dirty = Gi),
            s.update(e, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1
        );
    }
    findIndexWithChild(e) {
        for (;;) {
            let n = e.parentNode;
            if (!n) return -1;
            if (n == this.top.contentDOM) {
                let r = e.pmViewDesc;
                if (r) {
                    for (let i = this.index; i < this.top.children.length; i++) if (this.top.children[i] == r) return i;
                }
                return -1;
            }
            e = n;
        }
    }
    updateNextNode(e, n, r, i, o, s) {
        for (let l = this.index; l < this.top.children.length; l++) {
            let u = this.top.children[l];
            if (u instanceof di) {
                let d = this.preMatch.matched.get(u);
                if (d != null && d != o) return !1;
                let f = u.dom,
                    h,
                    m =
                        this.isLocked(f) &&
                        !(
                            e.isText &&
                            u.node &&
                            u.node.isText &&
                            u.nodeDOM.nodeValue == e.text &&
                            u.dirty != hr &&
                            Sf(n, u.outerDeco)
                        );
                if (!m && u.update(e, n, r, i))
                    return this.destroyBetween(this.index, l), u.dom != f && (this.changed = !0), this.index++, !0;
                if (!m && (h = this.recreateWrapper(u, e, n, r, i, s)))
                    return (
                        (this.top.children[this.index] = h),
                        h.contentDOM && ((h.dirty = Gi), h.updateChildren(i, s + 1), (h.dirty = $n)),
                        (this.changed = !0),
                        this.index++,
                        !0
                    );
                break;
            }
        }
        return !1;
    }
    recreateWrapper(e, n, r, i, o, s) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content)) return null;
        let l = di.create(this.top, n, r, i, o, s);
        if (l.contentDOM) {
            (l.children = e.children), (e.children = []);
            for (let u of l.children) u.parent = l;
        }
        return e.destroy(), l;
    }
    addNode(e, n, r, i, o) {
        let s = di.create(this.top, e, n, r, i, o);
        s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), (this.changed = !0);
    }
    placeWidget(e, n, r) {
        let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++;
        else {
            let o = new Nl(this.top, e, n, r);
            this.top.children.splice(this.index++, 0, o), (this.changed = !0);
        }
    }
    addTextblockHacks() {
        let e = this.top.children[this.index - 1],
            n = this.top;
        for (; e instanceof Wo; ) (n = e), (e = n.children[n.children.length - 1]);
        (!e ||
            !(e instanceof Ol) ||
            /\n$/.test(e.node.text) ||
            (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
            ((fn || dn) && e && e.dom.contentEditable == 'false' && this.addHackNode('IMG', n),
            this.addHackNode('BR', this.top));
    }
    addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e)) this.index++;
        else {
            let r = document.createElement(e);
            e == 'IMG' && ((r.className = 'ProseMirror-separator'), (r.alt = '')),
                e == 'BR' && (r.className = 'ProseMirror-trailingBreak');
            let i = new Rl(this.top, [], r, null);
            n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), (this.changed = !0);
        }
    }
    isLocked(e) {
        return this.lock && (e == this.lock || (e.nodeType == 1 && e.contains(this.lock.parentNode)));
    }
};
function hR(t, e) {
    let n = e,
        r = n.children.length,
        i = t.childCount,
        o = new Map(),
        s = [];
    e: for (; i > 0; ) {
        let l;
        for (;;)
            if (r) {
                let d = n.children[r - 1];
                if (d instanceof Wo) (n = d), (r = d.children.length);
                else {
                    (l = d), r--;
                    break;
                }
            } else {
                if (n == e) break e;
                (r = n.parent.children.indexOf(n)), (n = n.parent);
            }
        let u = l.node;
        if (u) {
            if (u != t.child(i - 1)) break;
            --i, o.set(l, i), s.push(l);
        }
    }
    return { index: i, matched: o, matches: s.reverse() };
}
function mR(t, e) {
    return t.type.side - e.type.side;
}
function gR(t, e, n, r) {
    let i = e.locals(t),
        o = 0;
    if (i.length == 0) {
        for (let d = 0; d < t.childCount; d++) {
            let f = t.child(d);
            r(f, i, e.forChild(o, f), d), (o += f.nodeSize);
        }
        return;
    }
    let s = 0,
        l = [],
        u = null;
    for (let d = 0; ; ) {
        let f, h;
        for (; s < i.length && i[s].to == o; ) {
            let x = i[s++];
            x.widget && (f ? (h || (h = [f])).push(x) : (f = x));
        }
        if (f)
            if (h) {
                h.sort(mR);
                for (let x = 0; x < h.length; x++) n(h[x], d, !!u);
            } else n(f, d, !!u);
        let m, b;
        if (u) (b = -1), (m = u), (u = null);
        else if (d < t.childCount) (b = d), (m = t.child(d++));
        else break;
        for (let x = 0; x < l.length; x++) l[x].to <= o && l.splice(x--, 1);
        for (; s < i.length && i[s].from <= o && i[s].to > o; ) l.push(i[s++]);
        let y = o + m.nodeSize;
        if (m.isText) {
            let x = y;
            s < i.length && i[s].from < x && (x = i[s].from);
            for (let T = 0; T < l.length; T++) l[T].to < x && (x = l[T].to);
            x < y && ((u = m.cut(x - o)), (m = m.cut(0, x - o)), (y = x), (b = -1));
        } else for (; s < i.length && i[s].to < y; ) s++;
        let v = m.isInline && !m.isLeaf ? l.filter((x) => !x.inline) : l.slice();
        r(m, v, e.forChild(o, m), b), (o = y);
    }
}
function bR(t) {
    if (t.nodeName == 'UL' || t.nodeName == 'OL') {
        let e = t.style.cssText;
        (t.style.cssText = e + '; list-style: square !important'),
            window.getComputedStyle(t).listStyle,
            (t.style.cssText = e);
    }
}
function yR(t, e, n, r) {
    for (let i = 0, o = 0; i < t.childCount && o <= r; ) {
        let s = t.child(i++),
            l = o;
        if (((o += s.nodeSize), !s.isText)) continue;
        let u = s.text;
        for (; i < t.childCount; ) {
            let d = t.child(i++);
            if (((o += d.nodeSize), !d.isText)) break;
            u += d.text;
        }
        if (o >= n) {
            if (o >= r && u.slice(r - e.length - l, r - l) == e) return r - e.length;
            let d = l < r ? u.lastIndexOf(e, r - l - 1) : -1;
            if (d >= 0 && d + e.length + l >= n) return l + d;
            if (n == r && u.length >= r + e.length - l && u.slice(r - l, r - l + e.length) == e) return r;
        }
    }
    return -1;
}
function Mf(t, e, n, r, i) {
    let o = [];
    for (let s = 0, l = 0; s < t.length; s++) {
        let u = t[s],
            d = l,
            f = (l += u.size);
        d >= n || f <= e
            ? o.push(u)
            : (d < e && o.push(u.slice(0, e - d, r)),
              i && (o.push(i), (i = void 0)),
              f > n && o.push(u.slice(n - d, u.size, r)));
    }
    return o;
}
function Bf(t, e = null) {
    let n = t.domSelectionRange(),
        r = t.state.doc;
    if (!n.focusNode) return null;
    let i = t.docView.nearestDesc(n.focusNode),
        o = i && i.size == 0,
        s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (s < 0) return null;
    let l = r.resolve(s),
        u,
        d;
    if (zl(n)) {
        for (u = l; i && !i.node; ) i = i.parent;
        let f = i.node;
        if (i && f.isAtom && pe.isSelectable(f) && i.parent && !(f.isInline && GO(n.focusNode, n.focusOffset, i.dom))) {
            let h = i.posBefore;
            d = new pe(s == h ? l : r.resolve(h));
        }
    } else {
        let f = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (f < 0) return null;
        u = r.resolve(f);
    }
    if (!d) {
        let f = e == 'pointer' || (t.state.selection.head < l.pos && !o) ? 1 : -1;
        d = Ff(t, u, l, f);
    }
    return d;
}
function H0(t) {
    return t.editable ? t.hasFocus() : $0(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Br(t, e = !1) {
    let n = t.state.selection;
    if ((z0(t, n), !!H0(t))) {
        if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && dn) {
            let r = t.domSelectionRange(),
                i = t.domObserver.currentSelection;
            if (r.anchorNode && i.anchorNode && Zi(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
                (t.input.mouseDown.delayedSelectionSync = !0), t.domObserver.setCurSelection();
                return;
            }
        }
        if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) vR(t);
        else {
            let { anchor: r, head: i } = n,
                o,
                s;
            s0 &&
                !(n instanceof ce) &&
                (n.$from.parent.inlineContent || (o = a0(t, n.from)),
                !n.empty && !n.$from.parent.inlineContent && (s = a0(t, n.to))),
                t.docView.setSelection(r, i, t.root, e),
                s0 && (o && l0(o), s && l0(s)),
                n.visible
                    ? t.dom.classList.remove('ProseMirror-hideselection')
                    : (t.dom.classList.add('ProseMirror-hideselection'), 'onselectionchange' in document && ER(t));
        }
        t.domObserver.setCurSelection(), t.domObserver.connectSelection();
    }
}
var s0 = fn || (dn && JO < 63);
function a0(t, e) {
    let { node: n, offset: r } = t.docView.domFromPos(e, 0),
        i = r < n.childNodes.length ? n.childNodes[r] : null,
        o = r ? n.childNodes[r - 1] : null;
    if (fn && i && i.contentEditable == 'false') return hf(i);
    if ((!i || i.contentEditable == 'false') && (!o || o.contentEditable == 'false')) {
        if (i) return hf(i);
        if (o) return hf(o);
    }
}
function hf(t) {
    return (t.contentEditable = 'true'), fn && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)), t;
}
function l0(t) {
    (t.contentEditable = 'false'), t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function ER(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener('selectionchange', t.input.hideSelectionGuard);
    let n = t.domSelectionRange(),
        r = n.anchorNode,
        i = n.anchorOffset;
    e.addEventListener(
        'selectionchange',
        (t.input.hideSelectionGuard = () => {
            (n.anchorNode != r || n.anchorOffset != i) &&
                (e.removeEventListener('selectionchange', t.input.hideSelectionGuard),
                setTimeout(() => {
                    (!H0(t) || t.state.selection.visible) && t.dom.classList.remove('ProseMirror-hideselection');
                }, 20));
        }),
    );
}
function vR(t) {
    let e = t.domSelection(),
        n = document.createRange(),
        r = t.cursorWrapper.dom,
        i = r.nodeName == 'IMG';
    i ? n.setEnd(r.parentNode, Yt(r) + 1) : n.setEnd(r, 0),
        n.collapse(!1),
        e.removeAllRanges(),
        e.addRange(n),
        !i && !t.state.selection.visible && vn && ui <= 11 && ((r.disabled = !0), (r.disabled = !1));
}
function z0(t, e) {
    if (e instanceof pe) {
        let n = t.docView.descAt(e.from);
        n != t.lastSelectedViewDesc && (c0(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
    } else c0(t);
}
function c0(t) {
    t.lastSelectedViewDesc &&
        (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), (t.lastSelectedViewDesc = void 0));
}
function Ff(t, e, n, r) {
    return t.someProp('createSelectionBetween', (i) => i(t, e, n)) || ce.between(e, n, r);
}
function u0(t) {
    return t.editable && !t.hasFocus() ? !1 : $0(t);
}
function $0(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode) return !1;
    try {
        return (
            t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) &&
            (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
        );
    } catch {
        return !1;
    }
}
function wR(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0),
        n = t.domSelectionRange();
    return Zi(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Af(t, e) {
    let { $anchor: n, $head: r } = t.selection,
        i = e > 0 ? n.max(r) : n.min(r),
        o = i.parent.inlineContent ? (i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null) : i;
    return o && fe.findFrom(o, e);
}
function li(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function d0(t, e, n) {
    let r = t.state.selection;
    if (r instanceof ce)
        if (n.indexOf('s') > -1) {
            let { $head: i } = r,
                o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
            if (!o || o.isText || !o.isLeaf) return !1;
            let s = t.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
            return li(t, new ce(r.$anchor, s));
        } else if (r.empty) {
            if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) {
                let i = Af(t.state, e);
                return i && i instanceof pe ? li(t, i) : !1;
            } else if (!(zn && n.indexOf('m') > -1)) {
                let i = r.$head,
                    o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter,
                    s;
                if (!o || o.isText) return !1;
                let l = e < 0 ? i.pos - o.nodeSize : i.pos;
                return o.isAtom || ((s = t.docView.descAt(l)) && !s.contentDOM)
                    ? pe.isSelectable(o)
                        ? li(t, new pe(e < 0 ? t.state.doc.resolve(i.pos - o.nodeSize) : i))
                        : js
                          ? li(t, new ce(t.state.doc.resolve(e < 0 ? l : l + o.nodeSize)))
                          : !1
                    : !1;
            }
        } else return !1;
    else {
        if (r instanceof pe && r.node.isInline) return li(t, new ce(e > 0 ? r.$to : r.$from));
        {
            let i = Af(t.state, e);
            return i ? li(t, i) : !1;
        }
    }
}
function Il(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Gs(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != 'BR');
}
function Ho(t, e) {
    return e < 0 ? xR(t) : _R(t);
}
function xR(t) {
    let e = t.domSelectionRange(),
        n = e.focusNode,
        r = e.focusOffset;
    if (!n) return;
    let i,
        o,
        s = !1;
    for (rr && n.nodeType == 1 && r < Il(n) && Gs(n.childNodes[r], -1) && (s = !0); ; )
        if (r > 0) {
            if (n.nodeType != 1) break;
            {
                let l = n.childNodes[r - 1];
                if (Gs(l, -1)) (i = n), (o = --r);
                else if (l.nodeType == 3) (n = l), (r = n.nodeValue.length);
                else break;
            }
        } else {
            if (U0(n)) break;
            {
                let l = n.previousSibling;
                for (; l && Gs(l, -1); ) (i = n.parentNode), (o = Yt(l)), (l = l.previousSibling);
                if (l) (n = l), (r = Il(n));
                else {
                    if (((n = n.parentNode), n == t.dom)) break;
                    r = 0;
                }
            }
        }
    s ? Cf(t, n, r) : i && Cf(t, i, o);
}
function _R(t) {
    let e = t.domSelectionRange(),
        n = e.focusNode,
        r = e.focusOffset;
    if (!n) return;
    let i = Il(n),
        o,
        s;
    for (;;)
        if (r < i) {
            if (n.nodeType != 1) break;
            let l = n.childNodes[r];
            if (Gs(l, 1)) (o = n), (s = ++r);
            else break;
        } else {
            if (U0(n)) break;
            {
                let l = n.nextSibling;
                for (; l && Gs(l, 1); ) (o = l.parentNode), (s = Yt(l) + 1), (l = l.nextSibling);
                if (l) (n = l), (r = 0), (i = Il(n));
                else {
                    if (((n = n.parentNode), n == t.dom)) break;
                    r = i = 0;
                }
            }
        }
    o && Cf(t, o, s);
}
function U0(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock;
}
function SR(t, e) {
    for (; t && e == t.childNodes.length && !Zs(t); ) (e = Yt(t) + 1), (t = t.parentNode);
    for (; t && e < t.childNodes.length; ) {
        let n = t.childNodes[e];
        if (n.nodeType == 3) return n;
        if (n.nodeType == 1 && n.contentEditable == 'false') break;
        (t = n), (e = 0);
    }
}
function TR(t, e) {
    for (; t && !e && !Zs(t); ) (e = Yt(t)), (t = t.parentNode);
    for (; t && e; ) {
        let n = t.childNodes[e - 1];
        if (n.nodeType == 3) return n;
        if (n.nodeType == 1 && n.contentEditable == 'false') break;
        (t = n), (e = t.childNodes.length);
    }
}
function Cf(t, e, n) {
    if (e.nodeType != 3) {
        let o, s;
        (s = SR(e, n)) ? ((e = s), (n = 0)) : (o = TR(e, n)) && ((e = o), (n = o.nodeValue.length));
    }
    let r = t.domSelection();
    if (zl(r)) {
        let o = document.createRange();
        o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
    } else r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let { state: i } = t;
    setTimeout(() => {
        t.state == i && Br(t);
    }, 50);
}
function f0(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(dn || XO) && n.parent.inlineContent) {
        let i = t.coordsAtPos(e);
        if (e > n.start()) {
            let o = t.coordsAtPos(e - 1),
                s = (o.top + o.bottom) / 2;
            if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1) return o.left < i.left ? 'ltr' : 'rtl';
        }
        if (e < n.end()) {
            let o = t.coordsAtPos(e + 1),
                s = (o.top + o.bottom) / 2;
            if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1) return o.left > i.left ? 'ltr' : 'rtl';
        }
    }
    return getComputedStyle(t.dom).direction == 'rtl' ? 'rtl' : 'ltr';
}
function p0(t, e, n) {
    let r = t.state.selection;
    if ((r instanceof ce && !r.empty) || n.indexOf('s') > -1 || (zn && n.indexOf('m') > -1)) return !1;
    let { $from: i, $to: o } = r;
    if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? 'up' : 'down')) {
        let s = Af(t.state, e);
        if (s && s instanceof pe) return li(t, s);
    }
    if (!i.parent.inlineContent) {
        let s = e < 0 ? i : o,
            l = r instanceof Nn ? fe.near(s, e) : fe.findFrom(s, e);
        return l ? li(t, l) : !1;
    }
    return !1;
}
function h0(t, e) {
    if (!(t.state.selection instanceof ce)) return !0;
    let { $head: n, $anchor: r, empty: i } = t.state.selection;
    if (!n.sameParent(r)) return !0;
    if (!i) return !1;
    if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) return !0;
    let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (o && !o.isText) {
        let s = t.state.tr;
        return e < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), t.dispatch(s), !0;
    }
    return !1;
}
function m0(t, e, n) {
    t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function MR(t) {
    if (!fn || t.state.selection.$head.parentOffset > 0) return !1;
    let { focusNode: e, focusOffset: n } = t.domSelectionRange();
    if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == 'false') {
        let r = e.firstChild;
        m0(t, r, 'true'), setTimeout(() => m0(t, r, 'false'), 20);
    }
    return !1;
}
function AR(t) {
    let e = '';
    return t.ctrlKey && (e += 'c'), t.metaKey && (e += 'm'), t.altKey && (e += 'a'), t.shiftKey && (e += 's'), e;
}
function CR(t, e) {
    let n = e.keyCode,
        r = AR(e);
    if (n == 8 || (zn && n == 72 && r == 'c')) return h0(t, -1) || Ho(t, -1);
    if ((n == 46 && !e.shiftKey) || (zn && n == 68 && r == 'c')) return h0(t, 1) || Ho(t, 1);
    if (n == 13 || n == 27) return !0;
    if (n == 37 || (zn && n == 66 && r == 'c')) {
        let i = n == 37 ? (f0(t, t.state.selection.from) == 'ltr' ? -1 : 1) : -1;
        return d0(t, i, r) || Ho(t, i);
    } else if (n == 39 || (zn && n == 70 && r == 'c')) {
        let i = n == 39 ? (f0(t, t.state.selection.from) == 'ltr' ? 1 : -1) : 1;
        return d0(t, i, r) || Ho(t, i);
    } else {
        if (n == 38 || (zn && n == 80 && r == 'c')) return p0(t, -1, r) || Ho(t, -1);
        if (n == 40 || (zn && n == 78 && r == 'c')) return MR(t) || p0(t, 1, r) || Ho(t, 1);
        if (r == (zn ? 'm' : 'c') && (n == 66 || n == 73 || n == 89 || n == 90)) return !0;
    }
    return !1;
}
function W0(t, e) {
    t.someProp('transformCopied', (b) => {
        e = b(e, t);
    });
    let n = [],
        { content: r, openStart: i, openEnd: o } = e;
    for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        i--, o--;
        let b = r.firstChild;
        n.push(b.type.name, b.attrs != b.type.defaultAttrs ? b.attrs : null), (r = b.content);
    }
    let s = t.someProp('clipboardSerializer') || Rr.fromSchema(t.state.schema),
        l = J0(),
        u = l.createElement('div');
    u.appendChild(s.serializeFragment(r, { document: l }));
    let d = u.firstChild,
        f,
        h = 0;
    for (; d && d.nodeType == 1 && (f = Y0[d.nodeName.toLowerCase()]); ) {
        for (let b = f.length - 1; b >= 0; b--) {
            let y = l.createElement(f[b]);
            for (; u.firstChild; ) y.appendChild(u.firstChild);
            u.appendChild(y), h++;
        }
        d = u.firstChild;
    }
    d && d.nodeType == 1 && d.setAttribute('data-pm-slice', `${i} ${o}${h ? ` -${h}` : ''} ${JSON.stringify(n)}`);
    let m =
        t.someProp('clipboardTextSerializer', (b) => b(e, t)) ||
        e.content.textBetween(
            0,
            e.content.size,
            `

`,
        );
    return { dom: u, text: m, slice: e };
}
function K0(t, e, n, r, i) {
    let o = i.parent.type.spec.code,
        s,
        l;
    if (!n && !e) return null;
    let u = e && (r || o || !n);
    if (u) {
        if (
            (t.someProp('transformPastedText', (m) => {
                e = m(e, o || r, t);
            }),
            o)
        )
            return e
                ? new X(
                      K.from(
                          t.state.schema.text(
                              e.replace(
                                  /\r\n?/g,
                                  `
`,
                              ),
                          ),
                      ),
                      0,
                      0,
                  )
                : X.empty;
        let h = t.someProp('clipboardTextParser', (m) => m(e, i, r, t));
        if (h) l = h;
        else {
            let m = i.marks(),
                { schema: b } = t.state,
                y = Rr.fromSchema(b);
            (s = document.createElement('div')),
                e.split(/(?:\r\n?|\n)+/).forEach((v) => {
                    let x = s.appendChild(document.createElement('p'));
                    v && x.appendChild(y.serializeNode(b.text(v, m)));
                });
        }
    } else
        t.someProp('transformPastedHTML', (h) => {
            n = h(n, t);
        }),
            (s = OR(n)),
            js && RR(s);
    let d = s && s.querySelector('[data-pm-slice]'),
        f = d && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(d.getAttribute('data-pm-slice') || '');
    if (f && f[3])
        for (let h = +f[3]; h > 0; h--) {
            let m = s.firstChild;
            for (; m && m.nodeType != 1; ) m = m.nextSibling;
            if (!m) break;
            s = m;
        }
    if (
        (l ||
            (l = (t.someProp('clipboardParser') || t.someProp('domParser') || Ui.fromSchema(t.state.schema)).parseSlice(
                s,
                {
                    preserveWhitespace: !!(u || f),
                    context: i,
                    ruleFromNode(m) {
                        return m.nodeName == 'BR' && !m.nextSibling && m.parentNode && !kR.test(m.parentNode.nodeName)
                            ? { ignore: !0 }
                            : null;
                    },
                },
            )),
        f)
    )
        l = IR(g0(l, +f[1], +f[2]), f[4]);
    else if (((l = X.maxOpen(NR(l.content, i), !0)), l.openStart || l.openEnd)) {
        let h = 0,
            m = 0;
        for (let b = l.content.firstChild; h < l.openStart && !b.type.spec.isolating; h++, b = b.firstChild);
        for (let b = l.content.lastChild; m < l.openEnd && !b.type.spec.isolating; m++, b = b.lastChild);
        l = g0(l, h, m);
    }
    return (
        t.someProp('transformPasted', (h) => {
            l = h(l, t);
        }),
        l
    );
}
var kR =
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function NR(t, e) {
    if (t.childCount < 2) return t;
    for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.index(n)),
            o,
            s = [];
        if (
            (t.forEach((l) => {
                if (!s) return;
                let u = i.findWrapping(l.type),
                    d;
                if (!u) return (s = null);
                if ((d = s.length && o.length && G0(u, o, l, s[s.length - 1], 0))) s[s.length - 1] = d;
                else {
                    s.length && (s[s.length - 1] = q0(s[s.length - 1], o.length));
                    let f = V0(l, u);
                    s.push(f), (i = i.matchType(f.type)), (o = u);
                }
            }),
            s)
        )
            return K.from(s);
    }
    return t;
}
function V0(t, e, n = 0) {
    for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, K.from(t));
    return t;
}
function G0(t, e, n, r, i) {
    if (i < t.length && i < e.length && t[i] == e[i]) {
        let o = G0(t, e, n, r.lastChild, i + 1);
        if (o) return r.copy(r.content.replaceChild(r.childCount - 1, o));
        if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
            return r.copy(r.content.append(K.from(V0(n, t, i + 1))));
    }
}
function q0(t, e) {
    if (e == 0) return t;
    let n = t.content.replaceChild(t.childCount - 1, q0(t.lastChild, e - 1)),
        r = t.contentMatchAt(t.childCount).fillBefore(K.empty, !0);
    return t.copy(n.append(r));
}
function kf(t, e, n, r, i, o) {
    let s = e < 0 ? t.firstChild : t.lastChild,
        l = s.content;
    return (
        t.childCount > 1 && (o = 0),
        i < r - 1 && (l = kf(l, e, n, r, i + 1, o)),
        i >= n &&
            (l =
                e < 0
                    ? s
                          .contentMatchAt(0)
                          .fillBefore(l, o <= i)
                          .append(l)
                    : l.append(s.contentMatchAt(s.childCount).fillBefore(K.empty, !0))),
        t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(l))
    );
}
function g0(t, e, n) {
    return (
        e < t.openStart && (t = new X(kf(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)),
        n < t.openEnd && (t = new X(kf(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
        t
    );
}
var Y0 = {
        thead: ['table'],
        tbody: ['table'],
        tfoot: ['table'],
        caption: ['table'],
        colgroup: ['table'],
        col: ['table', 'colgroup'],
        tr: ['table', 'tbody'],
        td: ['table', 'tbody', 'tr'],
        th: ['table', 'tbody', 'tr'],
    },
    b0 = null;
function J0() {
    return b0 || (b0 = document.implementation.createHTMLDocument('title'));
}
function OR(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = J0().createElement('div'),
        r = /<([a-z][^>\s]+)/i.exec(t),
        i;
    if (
        ((i = r && Y0[r[1].toLowerCase()]) &&
            (t =
                i.map((o) => '<' + o + '>').join('') +
                t +
                i
                    .map((o) => '</' + o + '>')
                    .reverse()
                    .join('')),
        (n.innerHTML = t),
        i)
    )
        for (let o = 0; o < i.length; o++) n = n.querySelector(i[o]) || n;
    return n;
}
function RR(t) {
    let e = t.querySelectorAll(dn ? 'span:not([class]):not([style])' : 'span.Apple-converted-space');
    for (let n = 0; n < e.length; n++) {
        let r = e[n];
        r.childNodes.length == 1 &&
            r.textContent == '\xA0' &&
            r.parentNode &&
            r.parentNode.replaceChild(t.ownerDocument.createTextNode(' '), r);
    }
}
function IR(t, e) {
    if (!t.size) return t;
    let n = t.content.firstChild.type.schema,
        r;
    try {
        r = JSON.parse(e);
    } catch {
        return t;
    }
    let { content: i, openStart: o, openEnd: s } = t;
    for (let l = r.length - 2; l >= 0; l -= 2) {
        let u = n.nodes[r[l]];
        if (!u || u.hasRequiredAttrs()) break;
        (i = K.from(u.create(r[l + 1], i))), o++, s++;
    }
    return new X(i, o, s);
}
var pn = {},
    hn = {},
    LR = { touchstart: !0, touchmove: !0 },
    Nf = class {
        constructor() {
            (this.shiftKey = !1),
                (this.mouseDown = null),
                (this.lastKeyCode = null),
                (this.lastKeyCodeTime = 0),
                (this.lastClick = { time: 0, x: 0, y: 0, type: '' }),
                (this.lastSelectionOrigin = null),
                (this.lastSelectionTime = 0),
                (this.lastIOSEnter = 0),
                (this.lastIOSEnterFallbackTimeout = -1),
                (this.lastFocus = 0),
                (this.lastTouch = 0),
                (this.lastAndroidDelete = 0),
                (this.composing = !1),
                (this.compositionNode = null),
                (this.composingTimeout = -1),
                (this.compositionNodes = []),
                (this.compositionEndedAt = -2e8),
                (this.compositionID = 1),
                (this.compositionPendingChanges = 0),
                (this.domChangeCount = 0),
                (this.eventHandlers = Object.create(null)),
                (this.hideSelectionGuard = null);
        }
    };
function DR(t) {
    for (let e in pn) {
        let n = pn[e];
        t.dom.addEventListener(
            e,
            (t.input.eventHandlers[e] = (r) => {
                BR(t, r) && !Hf(t, r) && (t.editable || !(r.type in hn)) && n(t, r);
            }),
            LR[e] ? { passive: !0 } : void 0,
        );
    }
    fn && t.dom.addEventListener('input', () => null), Of(t);
}
function ci(t, e) {
    (t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function PR(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers) t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Of(t) {
    t.someProp('handleDOMEvents', (e) => {
        for (let n in e)
            t.input.eventHandlers[n] || t.dom.addEventListener(n, (t.input.eventHandlers[n] = (r) => Hf(t, r)));
    });
}
function Hf(t, e) {
    return t.someProp('handleDOMEvents', (n) => {
        let r = n[e.type];
        return r ? r(t, e) || e.defaultPrevented : !1;
    });
}
function BR(t, e) {
    if (!e.bubbles) return !0;
    if (e.defaultPrevented) return !1;
    for (let n = e.target; n != t.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e))) return !1;
    return !0;
}
function FR(t, e) {
    !Hf(t, e) && pn[e.type] && (t.editable || !(e.type in hn)) && pn[e.type](t, e);
}
hn.keydown = (t, e) => {
    let n = e;
    if (
        ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
        !Z0(t, n) &&
            ((t.input.lastKeyCode = n.keyCode), (t.input.lastKeyCodeTime = Date.now()), !(nr && dn && n.keyCode == 13)))
    )
        if (
            (n.keyCode != 229 && t.domObserver.forceFlush(),
            Uo && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
        ) {
            let r = Date.now();
            (t.input.lastIOSEnter = r),
                (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
                    t.input.lastIOSEnter == r &&
                        (t.someProp('handleKeyDown', (i) => i(t, Vi(13, 'Enter'))), (t.input.lastIOSEnter = 0));
                }, 200));
        } else t.someProp('handleKeyDown', (r) => r(t, n)) || CR(t, n) ? n.preventDefault() : ci(t, 'key');
};
hn.keyup = (t, e) => {
    e.keyCode == 16 && (t.input.shiftKey = !1);
};
hn.keypress = (t, e) => {
    let n = e;
    if (Z0(t, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (zn && n.metaKey)) return;
    if (t.someProp('handleKeyPress', (i) => i(t, n))) {
        n.preventDefault();
        return;
    }
    let r = t.state.selection;
    if (!(r instanceof ce) || !r.$from.sameParent(r.$to)) {
        let i = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(i) &&
            !t.someProp('handleTextInput', (o) => o(t, r.$from.pos, r.$to.pos, i)) &&
            t.dispatch(t.state.tr.insertText(i).scrollIntoView()),
            n.preventDefault();
    }
};
function $l(t) {
    return { left: t.clientX, top: t.clientY };
}
function HR(t, e) {
    let n = e.x - t.clientX,
        r = e.y - t.clientY;
    return n * n + r * r < 100;
}
function zf(t, e, n, r, i) {
    if (r == -1) return !1;
    let o = t.state.doc.resolve(r);
    for (let s = o.depth + 1; s > 0; s--)
        if (
            t.someProp(e, (l) =>
                s > o.depth ? l(t, n, o.nodeAfter, o.before(s), i, !0) : l(t, n, o.node(s), o.before(s), i, !1),
            )
        )
            return !0;
    return !1;
}
function $o(t, e, n) {
    t.focused || t.focus();
    let r = t.state.tr.setSelection(e);
    n == 'pointer' && r.setMeta('pointer', !0), t.dispatch(r);
}
function zR(t, e) {
    if (e == -1) return !1;
    let n = t.state.doc.resolve(e),
        r = n.nodeAfter;
    return r && r.isAtom && pe.isSelectable(r) ? ($o(t, new pe(n), 'pointer'), !0) : !1;
}
function $R(t, e) {
    if (e == -1) return !1;
    let n = t.state.selection,
        r,
        i;
    n instanceof pe && (r = n.node);
    let o = t.state.doc.resolve(e);
    for (let s = o.depth + 1; s > 0; s--) {
        let l = s > o.depth ? o.nodeAfter : o.node(s);
        if (pe.isSelectable(l)) {
            r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos
                ? (i = o.before(n.$from.depth))
                : (i = o.before(s));
            break;
        }
    }
    return i != null ? ($o(t, pe.create(t.state.doc, i), 'pointer'), !0) : !1;
}
function UR(t, e, n, r, i) {
    return zf(t, 'handleClickOn', e, n, r) || t.someProp('handleClick', (o) => o(t, e, r)) || (i ? $R(t, n) : zR(t, n));
}
function WR(t, e, n, r) {
    return zf(t, 'handleDoubleClickOn', e, n, r) || t.someProp('handleDoubleClick', (i) => i(t, e, r));
}
function KR(t, e, n, r) {
    return zf(t, 'handleTripleClickOn', e, n, r) || t.someProp('handleTripleClick', (i) => i(t, e, r)) || VR(t, n, r);
}
function VR(t, e, n) {
    if (n.button != 0) return !1;
    let r = t.state.doc;
    if (e == -1) return r.inlineContent ? ($o(t, ce.create(r, 0, r.content.size), 'pointer'), !0) : !1;
    let i = r.resolve(e);
    for (let o = i.depth + 1; o > 0; o--) {
        let s = o > i.depth ? i.nodeAfter : i.node(o),
            l = i.before(o);
        if (s.inlineContent) $o(t, ce.create(r, l + 1, l + 1 + s.content.size), 'pointer');
        else if (pe.isSelectable(s)) $o(t, pe.create(r, l), 'pointer');
        else continue;
        return !0;
    }
}
function $f(t) {
    return Ll(t);
}
var X0 = zn ? 'metaKey' : 'ctrlKey';
pn.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = $f(t),
        i = Date.now(),
        o = 'singleClick';
    i - t.input.lastClick.time < 500 &&
        HR(n, t.input.lastClick) &&
        !n[X0] &&
        (t.input.lastClick.type == 'singleClick'
            ? (o = 'doubleClick')
            : t.input.lastClick.type == 'doubleClick' && (o = 'tripleClick')),
        (t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o });
    let s = t.posAtCoords($l(n));
    s &&
        (o == 'singleClick'
            ? (t.input.mouseDown && t.input.mouseDown.done(), (t.input.mouseDown = new Rf(t, s, n, !!r)))
            : (o == 'doubleClick' ? WR : KR)(t, s.pos, s.inside, n)
              ? n.preventDefault()
              : ci(t, 'pointer'));
};
var Rf = class {
    constructor(e, n, r, i) {
        (this.view = e),
            (this.pos = n),
            (this.event = r),
            (this.flushed = i),
            (this.delayedSelectionSync = !1),
            (this.mightDrag = null),
            (this.startDoc = e.state.doc),
            (this.selectNode = !!r[X0]),
            (this.allowDefault = r.shiftKey);
        let o, s;
        if (n.inside > -1) (o = e.state.doc.nodeAt(n.inside)), (s = n.inside);
        else {
            let f = e.state.doc.resolve(n.pos);
            (o = f.parent), (s = f.depth ? f.before() : 0);
        }
        let l = i ? null : r.target,
            u = l ? e.docView.nearestDesc(l, !0) : null;
        this.target = u ? u.dom : null;
        let { selection: d } = e.state;
        ((r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1) ||
            (d instanceof pe && d.from <= s && d.to > s)) &&
            (this.mightDrag = {
                node: o,
                pos: s,
                addAttr: !!(this.target && !this.target.draggable),
                setUneditable: !!(this.target && rr && !this.target.hasAttribute('contentEditable')),
            }),
            this.target &&
                this.mightDrag &&
                (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
                (this.view.domObserver.stop(),
                this.mightDrag.addAttr && (this.target.draggable = !0),
                this.mightDrag.setUneditable &&
                    setTimeout(() => {
                        this.view.input.mouseDown == this && this.target.setAttribute('contentEditable', 'false');
                    }, 20),
                this.view.domObserver.start()),
            e.root.addEventListener('mouseup', (this.up = this.up.bind(this))),
            e.root.addEventListener('mousemove', (this.move = this.move.bind(this))),
            ci(e, 'pointer');
    }
    done() {
        this.view.root.removeEventListener('mouseup', this.up),
            this.view.root.removeEventListener('mousemove', this.move),
            this.mightDrag &&
                this.target &&
                (this.view.domObserver.stop(),
                this.mightDrag.addAttr && this.target.removeAttribute('draggable'),
                this.mightDrag.setUneditable && this.target.removeAttribute('contentEditable'),
                this.view.domObserver.start()),
            this.delayedSelectionSync && setTimeout(() => Br(this.view)),
            (this.view.input.mouseDown = null);
    }
    up(e) {
        if ((this.done(), !this.view.dom.contains(e.target))) return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords($l(e))),
            this.updateAllowDefault(e),
            this.allowDefault || !n
                ? ci(this.view, 'pointer')
                : UR(this.view, n.pos, n.inside, e, this.selectNode)
                  ? e.preventDefault()
                  : e.button == 0 &&
                      (this.flushed ||
                          (fn && this.mightDrag && !this.mightDrag.node.isAtom) ||
                          (dn &&
                              !this.view.state.selection.visible &&
                              Math.min(
                                  Math.abs(n.pos - this.view.state.selection.from),
                                  Math.abs(n.pos - this.view.state.selection.to),
                              ) <= 2))
                    ? ($o(this.view, fe.near(this.view.state.doc.resolve(n.pos)), 'pointer'), e.preventDefault())
                    : ci(this.view, 'pointer');
    }
    move(e) {
        this.updateAllowDefault(e), ci(this.view, 'pointer'), e.buttons == 0 && this.done();
    }
    updateAllowDefault(e) {
        !this.allowDefault &&
            (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) &&
            (this.allowDefault = !0);
    }
};
pn.touchstart = (t) => {
    (t.input.lastTouch = Date.now()), $f(t), ci(t, 'pointer');
};
pn.touchmove = (t) => {
    (t.input.lastTouch = Date.now()), ci(t, 'pointer');
};
pn.contextmenu = (t) => $f(t);
function Z0(t, e) {
    return t.composing
        ? !0
        : fn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
          ? ((t.input.compositionEndedAt = -2e8), !0)
          : !1;
}
var GR = nr ? 5e3 : -1;
hn.compositionstart = hn.compositionupdate = (t) => {
    if (!t.composing) {
        t.domObserver.flush();
        let { state: e } = t,
            n = e.selection.$from;
        if (
            e.selection.empty &&
            (e.storedMarks ||
                (!n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
        )
            (t.markCursor = t.state.storedMarks || n.marks()), Ll(t, !0), (t.markCursor = null);
        else if ((Ll(t), rr && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length)) {
            let r = t.domSelectionRange();
            for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
                let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
                if (!s) break;
                if (s.nodeType == 3) {
                    t.domSelection().collapse(s, s.nodeValue.length);
                    break;
                } else (i = s), (o = -1);
            }
        }
        t.input.composing = !0;
    }
    j0(t, GR);
};
hn.compositionend = (t, e) => {
    t.composing &&
        ((t.input.composing = !1),
        (t.input.compositionEndedAt = e.timeStamp),
        (t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0),
        (t.input.compositionNode = null),
        t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()),
        t.input.compositionID++,
        j0(t, 20));
};
function j0(t, e) {
    clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Ll(t), e));
}
function Q0(t) {
    for (
        t.composing && ((t.input.composing = !1), (t.input.compositionEndedAt = YR()));
        t.input.compositionNodes.length > 0;

    )
        t.input.compositionNodes.pop().markParentsDirty();
}
function qR(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode) return null;
    let n = KO(e.focusNode, e.focusOffset),
        r = VO(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
        let i = r.pmViewDesc;
        if (!i || !i.isText(r.nodeValue)) return r;
        if (t.input.compositionNode == r) {
            let o = n.pmViewDesc;
            if (!(!o || !o.isText(n.nodeValue))) return r;
        }
    }
    return n || r;
}
function YR() {
    let t = document.createEvent('Event');
    return t.initEvent('event', !0, !0), t.timeStamp;
}
function Ll(t, e = !1) {
    if (!(nr && t.domObserver.flushingSoon >= 0)) {
        if ((t.domObserver.forceFlush(), Q0(t), e || (t.docView && t.docView.dirty))) {
            let n = Bf(t);
            return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state), !0;
        }
        return !1;
    }
}
function JR(t, e) {
    if (!t.dom.parentNode) return;
    let n = t.dom.parentNode.appendChild(document.createElement('div'));
    n.appendChild(e), (n.style.cssText = 'position: fixed; left: -10000px; top: 10px');
    let r = getSelection(),
        i = document.createRange();
    i.selectNodeContents(e),
        t.dom.blur(),
        r.removeAllRanges(),
        r.addRange(i),
        setTimeout(() => {
            n.parentNode && n.parentNode.removeChild(n), t.focus();
        }, 50);
}
var Ys = (vn && ui < 15) || (Uo && ZO < 604);
pn.copy = hn.cut = (t, e) => {
    let n = e,
        r = t.state.selection,
        i = n.type == 'cut';
    if (r.empty) return;
    let o = Ys ? null : n.clipboardData,
        s = r.content(),
        { dom: l, text: u } = W0(t, s);
    o ? (n.preventDefault(), o.clearData(), o.setData('text/html', l.innerHTML), o.setData('text/plain', u)) : JR(t, l),
        i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta('uiEvent', 'cut'));
};
function XR(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function ZR(t, e) {
    if (!t.dom.parentNode) return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
        r = t.dom.parentNode.appendChild(document.createElement(n ? 'textarea' : 'div'));
    n || (r.contentEditable = 'true'), (r.style.cssText = 'position: fixed; left: -10000px; top: 10px'), r.focus();
    let i = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout(() => {
        t.focus(),
            r.parentNode && r.parentNode.removeChild(r),
            n ? Js(t, r.value, null, i, e) : Js(t, r.textContent, r.innerHTML, i, e);
    }, 50);
}
function Js(t, e, n, r, i) {
    let o = K0(t, e, n, r, t.state.selection.$from);
    if (t.someProp('handlePaste', (u) => u(t, i, o || X.empty))) return !0;
    if (!o) return !1;
    let s = XR(o),
        l = s ? t.state.tr.replaceSelectionWith(s, r) : t.state.tr.replaceSelection(o);
    return t.dispatch(l.scrollIntoView().setMeta('paste', !0).setMeta('uiEvent', 'paste')), !0;
}
function eE(t) {
    let e = t.getData('text/plain') || t.getData('Text');
    if (e) return e;
    let n = t.getData('text/uri-list');
    return n ? n.replace(/\r?\n/g, ' ') : '';
}
hn.paste = (t, e) => {
    let n = e;
    if (t.composing && !nr) return;
    let r = Ys ? null : n.clipboardData,
        i = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && Js(t, eE(r), r.getData('text/html'), i, n) ? n.preventDefault() : ZR(t, n);
};
var Dl = class {
        constructor(e, n, r) {
            (this.slice = e), (this.move = n), (this.node = r);
        }
    },
    tE = zn ? 'altKey' : 'ctrlKey';
pn.dragstart = (t, e) => {
    let n = e,
        r = t.input.mouseDown;
    if ((r && r.done(), !n.dataTransfer)) return;
    let i = t.state.selection,
        o = i.empty ? null : t.posAtCoords($l(n)),
        s;
    if (!(o && o.pos >= i.from && o.pos <= (i instanceof pe ? i.to - 1 : i.to))) {
        if (r && r.mightDrag) s = pe.create(t.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
            let h = t.docView.nearestDesc(n.target, !0);
            h && h.node.type.spec.draggable && h != t.docView && (s = pe.create(t.state.doc, h.posBefore));
        }
    }
    let l = (s || t.state.selection).content(),
        { dom: u, text: d, slice: f } = W0(t, l);
    n.dataTransfer.clearData(),
        n.dataTransfer.setData(Ys ? 'Text' : 'text/html', u.innerHTML),
        (n.dataTransfer.effectAllowed = 'copyMove'),
        Ys || n.dataTransfer.setData('text/plain', d),
        (t.dragging = new Dl(f, !n[tE], s));
};
pn.dragend = (t) => {
    let e = t.dragging;
    window.setTimeout(() => {
        t.dragging == e && (t.dragging = null);
    }, 50);
};
hn.dragover = hn.dragenter = (t, e) => e.preventDefault();
hn.drop = (t, e) => {
    let n = e,
        r = t.dragging;
    if (((t.dragging = null), !n.dataTransfer)) return;
    let i = t.posAtCoords($l(n));
    if (!i) return;
    let o = t.state.doc.resolve(i.pos),
        s = r && r.slice;
    s
        ? t.someProp('transformPasted', (y) => {
              s = y(s, t);
          })
        : (s = K0(t, eE(n.dataTransfer), Ys ? null : n.dataTransfer.getData('text/html'), !1, o));
    let l = !!(r && !n[tE]);
    if (t.someProp('handleDrop', (y) => y(t, n, s || X.empty, l))) {
        n.preventDefault();
        return;
    }
    if (!s) return;
    n.preventDefault();
    let u = s ? Ml(t.state.doc, o.pos, s) : o.pos;
    u == null && (u = o.pos);
    let d = t.state.tr;
    if (l) {
        let { node: y } = r;
        y ? y.replace(d) : d.deleteSelection();
    }
    let f = d.mapping.map(u),
        h = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
        m = d.doc;
    if ((h ? d.replaceRangeWith(f, f, s.content.firstChild) : d.replaceRange(f, f, s), d.doc.eq(m))) return;
    let b = d.doc.resolve(f);
    if (h && pe.isSelectable(s.content.firstChild) && b.nodeAfter && b.nodeAfter.sameMarkup(s.content.firstChild))
        d.setSelection(new pe(b));
    else {
        let y = d.mapping.map(u);
        d.mapping.maps[d.mapping.maps.length - 1].forEach((v, x, T, D) => (y = D)),
            d.setSelection(Ff(t, b, d.doc.resolve(y)));
    }
    t.focus(), t.dispatch(d.setMeta('uiEvent', 'drop'));
};
pn.focus = (t) => {
    (t.input.lastFocus = Date.now()),
        t.focused ||
            (t.domObserver.stop(),
            t.dom.classList.add('ProseMirror-focused'),
            t.domObserver.start(),
            (t.focused = !0),
            setTimeout(() => {
                t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Br(t);
            }, 20));
};
pn.blur = (t, e) => {
    let n = e;
    t.focused &&
        (t.domObserver.stop(),
        t.dom.classList.remove('ProseMirror-focused'),
        t.domObserver.start(),
        n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
        (t.focused = !1));
};
pn.beforeinput = (t, e) => {
    if (dn && nr && e.inputType == 'deleteContentBackward') {
        t.domObserver.flushSoon();
        let { domChangeCount: r } = t.input;
        setTimeout(() => {
            if (
                t.input.domChangeCount != r ||
                (t.dom.blur(), t.focus(), t.someProp('handleKeyDown', (o) => o(t, Vi(8, 'Backspace'))))
            )
                return;
            let { $cursor: i } = t.state.selection;
            i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
        }, 50);
    }
};
for (let t in hn) pn[t] = hn[t];
function Xs(t, e) {
    if (t == e) return !0;
    for (let n in t) if (t[n] !== e[n]) return !1;
    for (let n in e) if (!(n in t)) return !1;
    return !0;
}
var Pl = class t {
        constructor(e, n) {
            (this.toDOM = e), (this.spec = n || Ji), (this.side = this.spec.side || 0);
        }
        map(e, n, r, i) {
            let { pos: o, deleted: s } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
            return s ? null : new Mt(o - r, o - r, this);
        }
        valid() {
            return !0;
        }
        eq(e) {
            return (
                this == e ||
                (e instanceof t &&
                    ((this.spec.key && this.spec.key == e.spec.key) ||
                        (this.toDOM == e.toDOM && Xs(this.spec, e.spec))))
            );
        }
        destroy(e) {
            this.spec.destroy && this.spec.destroy(e);
        }
    },
    Yi = class t {
        constructor(e, n) {
            (this.attrs = e), (this.spec = n || Ji);
        }
        map(e, n, r, i) {
            let o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r,
                s = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
            return o >= s ? null : new Mt(o, s, this);
        }
        valid(e, n) {
            return n.from < n.to;
        }
        eq(e) {
            return this == e || (e instanceof t && Xs(this.attrs, e.attrs) && Xs(this.spec, e.spec));
        }
        static is(e) {
            return e.type instanceof t;
        }
        destroy() {}
    },
    If = class t {
        constructor(e, n) {
            (this.attrs = e), (this.spec = n || Ji);
        }
        map(e, n, r, i) {
            let o = e.mapResult(n.from + i, 1);
            if (o.deleted) return null;
            let s = e.mapResult(n.to + i, -1);
            return s.deleted || s.pos <= o.pos ? null : new Mt(o.pos - r, s.pos - r, this);
        }
        valid(e, n) {
            let { index: r, offset: i } = e.content.findIndex(n.from),
                o;
            return i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to;
        }
        eq(e) {
            return this == e || (e instanceof t && Xs(this.attrs, e.attrs) && Xs(this.spec, e.spec));
        }
        destroy() {}
    },
    Mt = class t {
        constructor(e, n, r) {
            (this.from = e), (this.to = n), (this.type = r);
        }
        copy(e, n) {
            return new t(e, n, this.type);
        }
        eq(e, n = 0) {
            return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
        }
        map(e, n, r) {
            return this.type.map(e, this, n, r);
        }
        static widget(e, n, r) {
            return new t(e, e, new Pl(n, r));
        }
        static inline(e, n, r, i) {
            return new t(e, n, new Yi(r, i));
        }
        static node(e, n, r, i) {
            return new t(e, n, new If(r, i));
        }
        get spec() {
            return this.type.spec;
        }
        get inline() {
            return this.type instanceof Yi;
        }
        get widget() {
            return this.type instanceof Pl;
        }
    },
    zo = [],
    Ji = {},
    lt = class t {
        constructor(e, n) {
            (this.local = e.length ? e : zo), (this.children = n.length ? n : zo);
        }
        static create(e, n) {
            return n.length ? Fl(n, e, 0, Ji) : rn;
        }
        find(e, n, r) {
            let i = [];
            return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
        }
        findInner(e, n, r, i, o) {
            for (let s = 0; s < this.local.length; s++) {
                let l = this.local[s];
                l.from <= n && l.to >= e && (!o || o(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
            }
            for (let s = 0; s < this.children.length; s += 3)
                if (this.children[s] < n && this.children[s + 1] > e) {
                    let l = this.children[s] + 1;
                    this.children[s + 2].findInner(e - l, n - l, r, i + l, o);
                }
        }
        map(e, n, r) {
            return this == rn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Ji);
        }
        mapInner(e, n, r, i, o) {
            let s;
            for (let l = 0; l < this.local.length; l++) {
                let u = this.local[l].map(e, r, i);
                u && u.type.valid(n, u) ? (s || (s = [])).push(u) : o.onRemove && o.onRemove(this.local[l].spec);
            }
            return this.children.length ? jR(this.children, s || [], e, n, r, i, o) : s ? new t(s.sort(Xi), zo) : rn;
        }
        add(e, n) {
            return n.length ? (this == rn ? t.create(e, n) : this.addInner(e, n, 0)) : this;
        }
        addInner(e, n, r) {
            let i,
                o = 0;
            e.forEach((l, u) => {
                let d = u + r,
                    f;
                if ((f = rE(n, l, d))) {
                    for (i || (i = this.children.slice()); o < i.length && i[o] < u; ) o += 3;
                    i[o] == u
                        ? (i[o + 2] = i[o + 2].addInner(l, f, d + 1))
                        : i.splice(o, 0, u, u + l.nodeSize, Fl(f, l, d + 1, Ji)),
                        (o += 3);
                }
            });
            let s = nE(o ? iE(n) : n, -r);
            for (let l = 0; l < s.length; l++) s[l].type.valid(e, s[l]) || s.splice(l--, 1);
            return new t(s.length ? this.local.concat(s).sort(Xi) : this.local, i || this.children);
        }
        remove(e) {
            return e.length == 0 || this == rn ? this : this.removeInner(e, 0);
        }
        removeInner(e, n) {
            let r = this.children,
                i = this.local;
            for (let o = 0; o < r.length; o += 3) {
                let s,
                    l = r[o] + n,
                    u = r[o + 1] + n;
                for (let f = 0, h; f < e.length; f++)
                    (h = e[f]) && h.from > l && h.to < u && ((e[f] = null), (s || (s = [])).push(h));
                if (!s) continue;
                r == this.children && (r = this.children.slice());
                let d = r[o + 2].removeInner(s, l + 1);
                d != rn ? (r[o + 2] = d) : (r.splice(o, 3), (o -= 3));
            }
            if (i.length) {
                for (let o = 0, s; o < e.length; o++)
                    if ((s = e[o]))
                        for (let l = 0; l < i.length; l++)
                            i[l].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
            }
            return r == this.children && i == this.local ? this : i.length || r.length ? new t(i, r) : rn;
        }
        forChild(e, n) {
            if (this == rn) return this;
            if (n.isLeaf) return t.empty;
            let r, i;
            for (let l = 0; l < this.children.length; l += 3)
                if (this.children[l] >= e) {
                    this.children[l] == e && (r = this.children[l + 2]);
                    break;
                }
            let o = e + 1,
                s = o + n.content.size;
            for (let l = 0; l < this.local.length; l++) {
                let u = this.local[l];
                if (u.from < s && u.to > o && u.type instanceof Yi) {
                    let d = Math.max(o, u.from) - o,
                        f = Math.min(s, u.to) - o;
                    d < f && (i || (i = [])).push(u.copy(d, f));
                }
            }
            if (i) {
                let l = new t(i.sort(Xi), zo);
                return r ? new Bl([l, r]) : l;
            }
            return r || rn;
        }
        eq(e) {
            if (this == e) return !0;
            if (!(e instanceof t) || this.local.length != e.local.length || this.children.length != e.children.length)
                return !1;
            for (let n = 0; n < this.local.length; n++) if (!this.local[n].eq(e.local[n])) return !1;
            for (let n = 0; n < this.children.length; n += 3)
                if (
                    this.children[n] != e.children[n] ||
                    this.children[n + 1] != e.children[n + 1] ||
                    !this.children[n + 2].eq(e.children[n + 2])
                )
                    return !1;
            return !0;
        }
        locals(e) {
            return Uf(this.localsInner(e));
        }
        localsInner(e) {
            if (this == rn) return zo;
            if (e.inlineContent || !this.local.some(Yi.is)) return this.local;
            let n = [];
            for (let r = 0; r < this.local.length; r++) this.local[r].type instanceof Yi || n.push(this.local[r]);
            return n;
        }
    };
lt.empty = new lt([], []);
lt.removeOverlap = Uf;
var rn = lt.empty,
    Bl = class t {
        constructor(e) {
            this.members = e;
        }
        map(e, n) {
            let r = this.members.map((i) => i.map(e, n, Ji));
            return t.from(r);
        }
        forChild(e, n) {
            if (n.isLeaf) return lt.empty;
            let r = [];
            for (let i = 0; i < this.members.length; i++) {
                let o = this.members[i].forChild(e, n);
                o != rn && (o instanceof t ? (r = r.concat(o.members)) : r.push(o));
            }
            return t.from(r);
        }
        eq(e) {
            if (!(e instanceof t) || e.members.length != this.members.length) return !1;
            for (let n = 0; n < this.members.length; n++) if (!this.members[n].eq(e.members[n])) return !1;
            return !0;
        }
        locals(e) {
            let n,
                r = !0;
            for (let i = 0; i < this.members.length; i++) {
                let o = this.members[i].localsInner(e);
                if (o.length)
                    if (!n) n = o;
                    else {
                        r && ((n = n.slice()), (r = !1));
                        for (let s = 0; s < o.length; s++) n.push(o[s]);
                    }
            }
            return n ? Uf(r ? n : n.sort(Xi)) : zo;
        }
        static from(e) {
            switch (e.length) {
                case 0:
                    return rn;
                case 1:
                    return e[0];
                default:
                    return new t(
                        e.every((n) => n instanceof lt)
                            ? e
                            : e.reduce((n, r) => n.concat(r instanceof lt ? r : r.members), []),
                    );
            }
        }
    };
function jR(t, e, n, r, i, o, s) {
    let l = t.slice();
    for (let d = 0, f = o; d < n.maps.length; d++) {
        let h = 0;
        n.maps[d].forEach((m, b, y, v) => {
            let x = v - y - (b - m);
            for (let T = 0; T < l.length; T += 3) {
                let D = l[T + 1];
                if (D < 0 || m > D + f - h) continue;
                let I = l[T] + f - h;
                b >= I ? (l[T + 1] = m <= I ? -2 : -1) : m >= f && x && ((l[T] += x), (l[T + 1] += x));
            }
            h += x;
        }),
            (f = n.maps[d].map(f, -1));
    }
    let u = !1;
    for (let d = 0; d < l.length; d += 3)
        if (l[d + 1] < 0) {
            if (l[d + 1] == -2) {
                (u = !0), (l[d + 1] = -1);
                continue;
            }
            let f = n.map(t[d] + o),
                h = f - i;
            if (h < 0 || h >= r.content.size) {
                u = !0;
                continue;
            }
            let m = n.map(t[d + 1] + o, -1),
                b = m - i,
                { index: y, offset: v } = r.content.findIndex(h),
                x = r.maybeChild(y);
            if (x && v == h && v + x.nodeSize == b) {
                let T = l[d + 2].mapInner(n, x, f + 1, t[d] + o + 1, s);
                T != rn ? ((l[d] = h), (l[d + 1] = b), (l[d + 2] = T)) : ((l[d + 1] = -2), (u = !0));
            } else u = !0;
        }
    if (u) {
        let d = QR(l, t, e, n, i, o, s),
            f = Fl(d, r, 0, s);
        e = f.local;
        for (let h = 0; h < l.length; h += 3) l[h + 1] < 0 && (l.splice(h, 3), (h -= 3));
        for (let h = 0, m = 0; h < f.children.length; h += 3) {
            let b = f.children[h];
            for (; m < l.length && l[m] < b; ) m += 3;
            l.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
        }
    }
    return new lt(e.sort(Xi), l);
}
function nE(t, e) {
    if (!e || !t.length) return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let i = t[r];
        n.push(new Mt(i.from + e, i.to + e, i.type));
    }
    return n;
}
function QR(t, e, n, r, i, o, s) {
    function l(u, d) {
        for (let f = 0; f < u.local.length; f++) {
            let h = u.local[f].map(r, i, d);
            h ? n.push(h) : s.onRemove && s.onRemove(u.local[f].spec);
        }
        for (let f = 0; f < u.children.length; f += 3) l(u.children[f + 2], u.children[f] + d + 1);
    }
    for (let u = 0; u < t.length; u += 3) t[u + 1] == -1 && l(t[u + 2], e[u] + o + 1);
    return n;
}
function rE(t, e, n) {
    if (e.isLeaf) return null;
    let r = n + e.nodeSize,
        i = null;
    for (let o = 0, s; o < t.length; o++)
        (s = t[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), (t[o] = null));
    return i;
}
function iE(t) {
    let e = [];
    for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
    return e;
}
function Fl(t, e, n, r) {
    let i = [],
        o = !1;
    e.forEach((l, u) => {
        let d = rE(t, l, u + n);
        if (d) {
            o = !0;
            let f = Fl(d, l, n + u + 1, r);
            f != rn && i.push(u, u + l.nodeSize, f);
        }
    });
    let s = nE(o ? iE(t) : t, -n).sort(Xi);
    for (let l = 0; l < s.length; l++)
        s[l].type.valid(e, s[l]) || (r.onRemove && r.onRemove(s[l].spec), s.splice(l--, 1));
    return s.length || i.length ? new lt(s, i) : rn;
}
function Xi(t, e) {
    return t.from - e.from || t.to - e.to;
}
function Uf(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
        let r = e[n];
        if (r.from != r.to)
            for (let i = n + 1; i < e.length; i++) {
                let o = e[i];
                if (o.from == r.from) {
                    o.to != r.to &&
                        (e == t && (e = t.slice()), (e[i] = o.copy(o.from, r.to)), y0(e, i + 1, o.copy(r.to, o.to)));
                    continue;
                } else {
                    o.from < r.to &&
                        (e == t && (e = t.slice()), (e[n] = r.copy(r.from, o.from)), y0(e, i, r.copy(o.from, r.to)));
                    break;
                }
            }
    }
    return e;
}
function y0(t, e, n) {
    for (; e < t.length && Xi(n, t[e]) > 0; ) e++;
    t.splice(e, 0, n);
}
function mf(t) {
    let e = [];
    return (
        t.someProp('decorations', (n) => {
            let r = n(t.state);
            r && r != rn && e.push(r);
        }),
        t.cursorWrapper && e.push(lt.create(t.state.doc, [t.cursorWrapper.deco])),
        Bl.from(e)
    );
}
var eI = {
        childList: !0,
        characterData: !0,
        characterDataOldValue: !0,
        attributes: !0,
        attributeOldValue: !0,
        subtree: !0,
    },
    tI = vn && ui <= 11,
    Lf = class {
        constructor() {
            (this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0);
        }
        set(e) {
            (this.anchorNode = e.anchorNode),
                (this.anchorOffset = e.anchorOffset),
                (this.focusNode = e.focusNode),
                (this.focusOffset = e.focusOffset);
        }
        clear() {
            this.anchorNode = this.focusNode = null;
        }
        eq(e) {
            return (
                e.anchorNode == this.anchorNode &&
                e.anchorOffset == this.anchorOffset &&
                e.focusNode == this.focusNode &&
                e.focusOffset == this.focusOffset
            );
        }
    },
    Df = class {
        constructor(e, n) {
            (this.view = e),
                (this.handleDOMChange = n),
                (this.queue = []),
                (this.flushingSoon = -1),
                (this.observer = null),
                (this.currentSelection = new Lf()),
                (this.onCharData = null),
                (this.suppressingSelectionUpdates = !1),
                (this.observer =
                    window.MutationObserver &&
                    new window.MutationObserver((r) => {
                        for (let i = 0; i < r.length; i++) this.queue.push(r[i]);
                        vn &&
                        ui <= 11 &&
                        r.some(
                            (i) =>
                                (i.type == 'childList' && i.removedNodes.length) ||
                                (i.type == 'characterData' && i.oldValue.length > i.target.nodeValue.length),
                        )
                            ? this.flushSoon()
                            : this.flush();
                    })),
                tI &&
                    (this.onCharData = (r) => {
                        this.queue.push({ target: r.target, type: 'characterData', oldValue: r.prevValue }),
                            this.flushSoon();
                    }),
                (this.onSelectionChange = this.onSelectionChange.bind(this));
        }
        flushSoon() {
            this.flushingSoon < 0 &&
                (this.flushingSoon = window.setTimeout(() => {
                    (this.flushingSoon = -1), this.flush();
                }, 20));
        }
        forceFlush() {
            this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), (this.flushingSoon = -1), this.flush());
        }
        start() {
            this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, eI)),
                this.onCharData && this.view.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
                this.connectSelection();
        }
        stop() {
            if (this.observer) {
                let e = this.observer.takeRecords();
                if (e.length) {
                    for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
                    window.setTimeout(() => this.flush(), 20);
                }
                this.observer.disconnect();
            }
            this.onCharData && this.view.dom.removeEventListener('DOMCharacterDataModified', this.onCharData),
                this.disconnectSelection();
        }
        connectSelection() {
            this.view.dom.ownerDocument.addEventListener('selectionchange', this.onSelectionChange);
        }
        disconnectSelection() {
            this.view.dom.ownerDocument.removeEventListener('selectionchange', this.onSelectionChange);
        }
        suppressSelectionUpdates() {
            (this.suppressingSelectionUpdates = !0), setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
        }
        onSelectionChange() {
            if (u0(this.view)) {
                if (this.suppressingSelectionUpdates) return Br(this.view);
                if (vn && ui <= 11 && !this.view.state.selection.empty) {
                    let e = this.view.domSelectionRange();
                    if (e.focusNode && Zi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
                        return this.flushSoon();
                }
                this.flush();
            }
        }
        setCurSelection() {
            this.currentSelection.set(this.view.domSelectionRange());
        }
        ignoreSelectionChange(e) {
            if (!e.focusNode) return !0;
            let n = new Set(),
                r;
            for (let o = e.focusNode; o; o = qs(o)) n.add(o);
            for (let o = e.anchorNode; o; o = qs(o))
                if (n.has(o)) {
                    r = o;
                    break;
                }
            let i = r && this.view.docView.nearestDesc(r);
            if (i && i.ignoreMutation({ type: 'selection', target: r.nodeType == 3 ? r.parentNode : r }))
                return this.setCurSelection(), !0;
        }
        pendingRecords() {
            if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e);
            return this.queue;
        }
        flush() {
            let { view: e } = this;
            if (!e.docView || this.flushingSoon > -1) return;
            let n = this.pendingRecords();
            n.length && (this.queue = []);
            let r = e.domSelectionRange(),
                i =
                    !this.suppressingSelectionUpdates &&
                    !this.currentSelection.eq(r) &&
                    u0(e) &&
                    !this.ignoreSelectionChange(r),
                o = -1,
                s = -1,
                l = !1,
                u = [];
            if (e.editable)
                for (let f = 0; f < n.length; f++) {
                    let h = this.registerMutation(n[f], u);
                    h &&
                        ((o = o < 0 ? h.from : Math.min(h.from, o)),
                        (s = s < 0 ? h.to : Math.max(h.to, s)),
                        h.typeOver && (l = !0));
                }
            if (rr && u.length > 1) {
                let f = u.filter((h) => h.nodeName == 'BR');
                if (f.length == 2) {
                    let h = f[0],
                        m = f[1];
                    h.parentNode && h.parentNode.parentNode == m.parentNode ? m.remove() : h.remove();
                }
            }
            let d = null;
            o < 0 &&
            i &&
            e.input.lastFocus > Date.now() - 200 &&
            Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
            zl(r) &&
            (d = Bf(e)) &&
            d.eq(fe.near(e.state.doc.resolve(0), 1))
                ? ((e.input.lastFocus = 0), Br(e), this.currentSelection.set(r), e.scrollToSelection())
                : (o > -1 || i) &&
                  (o > -1 && (e.docView.markDirty(o, s), nI(e)),
                  this.handleDOMChange(o, s, l, u),
                  e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Br(e),
                  this.currentSelection.set(r));
        }
        registerMutation(e, n) {
            if (n.indexOf(e.target) > -1) return null;
            let r = this.view.docView.nearestDesc(e.target);
            if (
                (e.type == 'attributes' &&
                    (r == this.view.docView ||
                        e.attributeName == 'contenteditable' ||
                        (e.attributeName == 'style' && !e.oldValue && !e.target.getAttribute('style')))) ||
                !r ||
                r.ignoreMutation(e)
            )
                return null;
            if (e.type == 'childList') {
                for (let f = 0; f < e.addedNodes.length; f++) n.push(e.addedNodes[f]);
                if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
                    return { from: r.posBefore, to: r.posAfter };
                let i = e.previousSibling,
                    o = e.nextSibling;
                if (vn && ui <= 11 && e.addedNodes.length)
                    for (let f = 0; f < e.addedNodes.length; f++) {
                        let { previousSibling: h, nextSibling: m } = e.addedNodes[f];
                        (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h),
                            (!m || Array.prototype.indexOf.call(e.addedNodes, m) < 0) && (o = m);
                    }
                let s = i && i.parentNode == e.target ? Yt(i) + 1 : 0,
                    l = r.localPosFromDOM(e.target, s, -1),
                    u = o && o.parentNode == e.target ? Yt(o) : e.target.childNodes.length,
                    d = r.localPosFromDOM(e.target, u, 1);
                return { from: l, to: d };
            } else
                return e.type == 'attributes'
                    ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
                    : { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue };
        }
    },
    E0 = new WeakMap(),
    v0 = !1;
function nI(t) {
    if (
        !E0.has(t) &&
        (E0.set(t, null), ['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)
    ) {
        if (((t.requiresGeckoHackNode = rr), v0)) return;
        console.warn(
            "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.",
        ),
            (v0 = !0);
    }
}
function w0(t, e) {
    let n = e.startContainer,
        r = e.startOffset,
        i = e.endContainer,
        o = e.endOffset,
        s = t.domAtPos(t.state.selection.anchor);
    return (
        Zi(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]),
        { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o }
    );
}
function rI(t, e) {
    if (e.getComposedRanges) {
        let i = e.getComposedRanges(t.root)[0];
        if (i) return w0(t, i);
    }
    let n;
    function r(i) {
        i.preventDefault(), i.stopImmediatePropagation(), (n = i.getTargetRanges()[0]);
    }
    return (
        t.dom.addEventListener('beforeinput', r, !0),
        document.execCommand('indent'),
        t.dom.removeEventListener('beforeinput', r, !0),
        n ? w0(t, n) : null
    );
}
function iI(t, e, n) {
    let { node: r, fromOffset: i, toOffset: o, from: s, to: l } = t.docView.parseRange(e, n),
        u = t.domSelectionRange(),
        d,
        f = u.anchorNode;
    if (
        (f &&
            t.dom.contains(f.nodeType == 1 ? f : f.parentNode) &&
            ((d = [{ node: f, offset: u.anchorOffset }]),
            zl(u) || d.push({ node: u.focusNode, offset: u.focusOffset })),
        dn && t.input.lastKeyCode === 8)
    )
        for (let x = o; x > i; x--) {
            let T = r.childNodes[x - 1],
                D = T.pmViewDesc;
            if (T.nodeName == 'BR' && !D) {
                o = x;
                break;
            }
            if (!D || D.size) break;
        }
    let h = t.state.doc,
        m = t.someProp('domParser') || Ui.fromSchema(t.state.schema),
        b = h.resolve(s),
        y = null,
        v = m.parse(r, {
            topNode: b.parent,
            topMatch: b.parent.contentMatchAt(b.index()),
            topOpen: !0,
            from: i,
            to: o,
            preserveWhitespace: b.parent.type.whitespace == 'pre' ? 'full' : !0,
            findPositions: d,
            ruleFromNode: oI,
            context: b,
        });
    if (d && d[0].pos != null) {
        let x = d[0].pos,
            T = d[1] && d[1].pos;
        T == null && (T = x), (y = { anchor: x + s, head: T + s });
    }
    return { doc: v, sel: y, from: s, to: l };
}
function oI(t) {
    let e = t.pmViewDesc;
    if (e) return e.parseRule();
    if (t.nodeName == 'BR' && t.parentNode) {
        if (fn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
            let n = document.createElement('div');
            return n.appendChild(document.createElement('li')), { skip: n };
        } else if (t.parentNode.lastChild == t || (fn && /^(tr|table)$/i.test(t.parentNode.nodeName)))
            return { ignore: !0 };
    } else if (t.nodeName == 'IMG' && t.getAttribute('mark-placeholder')) return { ignore: !0 };
    return null;
}
var sI =
    /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function aI(t, e, n, r, i) {
    let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
    if (((t.input.compositionPendingChanges = 0), e < 0)) {
        let $ = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null,
            oe = Bf(t, $);
        if (oe && !t.state.selection.eq(oe)) {
            if (
                dn &&
                nr &&
                t.input.lastKeyCode === 13 &&
                Date.now() - 100 < t.input.lastKeyCodeTime &&
                t.someProp('handleKeyDown', (Te) => Te(t, Vi(13, 'Enter')))
            )
                return;
            let me = t.state.tr.setSelection(oe);
            $ == 'pointer' ? me.setMeta('pointer', !0) : $ == 'key' && me.scrollIntoView(),
                o && me.setMeta('composition', o),
                t.dispatch(me);
        }
        return;
    }
    let s = t.state.doc.resolve(e),
        l = s.sharedDepth(n);
    (e = s.before(l + 1)), (n = t.state.doc.resolve(n).after(l + 1));
    let u = t.state.selection,
        d = iI(t, e, n),
        f = t.state.doc,
        h = f.slice(d.from, d.to),
        m,
        b;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
        ? ((m = t.state.selection.to), (b = 'end'))
        : ((m = t.state.selection.from), (b = 'start')),
        (t.input.lastKeyCode = null);
    let y = uI(h.content, d.doc.content, d.from, m, b);
    if (
        ((Uo && t.input.lastIOSEnter > Date.now() - 225) || nr) &&
        i.some(($) => $.nodeType == 1 && !sI.test($.nodeName)) &&
        (!y || y.endA >= y.endB) &&
        t.someProp('handleKeyDown', ($) => $(t, Vi(13, 'Enter')))
    ) {
        t.input.lastIOSEnter = 0;
        return;
    }
    if (!y)
        if (
            r &&
            u instanceof ce &&
            !u.empty &&
            u.$head.sameParent(u.$anchor) &&
            !t.composing &&
            !(d.sel && d.sel.anchor != d.sel.head)
        )
            y = { start: u.from, endA: u.to, endB: u.to };
        else {
            if (d.sel) {
                let $ = x0(t, t.state.doc, d.sel);
                if ($ && !$.eq(t.state.selection)) {
                    let oe = t.state.tr.setSelection($);
                    o && oe.setMeta('composition', o), t.dispatch(oe);
                }
            }
            return;
        }
    t.input.domChangeCount++,
        t.state.selection.from < t.state.selection.to &&
            y.start == y.endB &&
            t.state.selection instanceof ce &&
            (y.start > t.state.selection.from &&
            y.start <= t.state.selection.from + 2 &&
            t.state.selection.from >= d.from
                ? (y.start = t.state.selection.from)
                : y.endA < t.state.selection.to &&
                  y.endA >= t.state.selection.to - 2 &&
                  t.state.selection.to <= d.to &&
                  ((y.endB += t.state.selection.to - y.endA), (y.endA = t.state.selection.to))),
        vn &&
            ui <= 11 &&
            y.endB == y.start + 1 &&
            y.endA == y.start &&
            y.start > d.from &&
            d.doc.textBetween(y.start - d.from - 1, y.start - d.from + 1) == ' \xA0' &&
            (y.start--, y.endA--, y.endB--);
    let v = d.doc.resolveNoCache(y.start - d.from),
        x = d.doc.resolveNoCache(y.endB - d.from),
        T = f.resolve(y.start),
        D = v.sameParent(x) && v.parent.inlineContent && T.end() >= y.endA,
        I;
    if (
        ((Uo &&
            t.input.lastIOSEnter > Date.now() - 225 &&
            (!D || i.some(($) => $.nodeName == 'DIV' || $.nodeName == 'P'))) ||
            (!D &&
                v.pos < d.doc.content.size &&
                !v.sameParent(x) &&
                (I = fe.findFrom(d.doc.resolve(v.pos + 1), 1, !0)) &&
                I.head == x.pos)) &&
        t.someProp('handleKeyDown', ($) => $(t, Vi(13, 'Enter')))
    ) {
        t.input.lastIOSEnter = 0;
        return;
    }
    if (
        t.state.selection.anchor > y.start &&
        cI(f, y.start, y.endA, v, x) &&
        t.someProp('handleKeyDown', ($) => $(t, Vi(8, 'Backspace')))
    ) {
        nr && dn && t.domObserver.suppressSelectionUpdates();
        return;
    }
    dn && nr && y.endB == y.start && (t.input.lastAndroidDelete = Date.now()),
        nr &&
            !D &&
            v.start() != x.start() &&
            x.parentOffset == 0 &&
            v.depth == x.depth &&
            d.sel &&
            d.sel.anchor == d.sel.head &&
            d.sel.head == y.endA &&
            ((y.endB -= 2),
            (x = d.doc.resolveNoCache(y.endB - d.from)),
            setTimeout(() => {
                t.someProp('handleKeyDown', function ($) {
                    return $(t, Vi(13, 'Enter'));
                });
            }, 20));
    let S = y.start,
        z = y.endA,
        N,
        q,
        ne;
    if (D) {
        if (v.pos == x.pos)
            vn &&
                ui <= 11 &&
                v.parentOffset == 0 &&
                (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Br(t), 20)),
                (N = t.state.tr.delete(S, z)),
                (q = f.resolve(y.start).marksAcross(f.resolve(y.endA)));
        else if (
            y.endA == y.endB &&
            (ne = lI(
                v.parent.content.cut(v.parentOffset, x.parentOffset),
                T.parent.content.cut(T.parentOffset, y.endA - T.start()),
            ))
        )
            (N = t.state.tr), ne.type == 'add' ? N.addMark(S, z, ne.mark) : N.removeMark(S, z, ne.mark);
        else if (v.parent.child(v.index()).isText && v.index() == x.index() - (x.textOffset ? 0 : 1)) {
            let $ = v.parent.textBetween(v.parentOffset, x.parentOffset);
            if (t.someProp('handleTextInput', (oe) => oe(t, S, z, $))) return;
            N = t.state.tr.insertText($, S, z);
        }
    }
    if ((N || (N = t.state.tr.replace(S, z, d.doc.slice(y.start - d.from, y.endB - d.from))), d.sel)) {
        let $ = x0(t, N.doc, d.sel);
        $ &&
            !(
                (dn &&
                    nr &&
                    t.composing &&
                    $.empty &&
                    (y.start != y.endB || t.input.lastAndroidDelete < Date.now() - 100) &&
                    ($.head == S || $.head == N.mapping.map(z) - 1)) ||
                (vn && $.empty && $.head == S)
            ) &&
            N.setSelection($);
    }
    q && N.ensureMarks(q), o && N.setMeta('composition', o), t.dispatch(N.scrollIntoView());
}
function x0(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : Ff(t, e.resolve(n.anchor), e.resolve(n.head));
}
function lI(t, e) {
    let n = t.firstChild.marks,
        r = e.firstChild.marks,
        i = n,
        o = r,
        s,
        l,
        u;
    for (let f = 0; f < r.length; f++) i = r[f].removeFromSet(i);
    for (let f = 0; f < n.length; f++) o = n[f].removeFromSet(o);
    if (i.length == 1 && o.length == 0) (l = i[0]), (s = 'add'), (u = (f) => f.mark(l.addToSet(f.marks)));
    else if (i.length == 0 && o.length == 1) (l = o[0]), (s = 'remove'), (u = (f) => f.mark(l.removeFromSet(f.marks)));
    else return null;
    let d = [];
    for (let f = 0; f < e.childCount; f++) d.push(u(e.child(f)));
    if (K.from(d).eq(t)) return { mark: l, type: s };
}
function cI(t, e, n, r, i) {
    if (n - e <= i.pos - r.pos || gf(r, !0, !1) < i.pos) return !1;
    let o = t.resolve(e);
    if (!r.parent.isTextblock) {
        let l = o.nodeAfter;
        return l != null && n == e + l.nodeSize;
    }
    if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock) return !1;
    let s = t.resolve(gf(o, !0, !0));
    return !s.parent.isTextblock || s.pos > n || gf(s, !0, !1) < n
        ? !1
        : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function gf(t, e, n) {
    let r = t.depth,
        i = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); ) r--, i++, (e = !1);
    if (n) {
        let o = t.node(r).maybeChild(t.indexAfter(r));
        for (; o && !o.isLeaf; ) (o = o.firstChild), i++;
    }
    return i;
}
function uI(t, e, n, r, i) {
    let o = t.findDiffStart(e, n);
    if (o == null) return null;
    let { a: s, b: l } = t.findDiffEnd(e, n + t.size, n + e.size);
    if (i == 'end') {
        let u = Math.max(0, o - Math.min(s, l));
        r -= s + u - o;
    }
    if (s < o && t.size < e.size) {
        let u = r <= o && r >= s ? o - r : 0;
        (o -= u), o && o < e.size && _0(e.textBetween(o - 1, o + 1)) && (o += u ? 1 : -1), (l = o + (l - s)), (s = o);
    } else if (l < o) {
        let u = r <= o && r >= l ? o - r : 0;
        (o -= u), o && o < t.size && _0(t.textBetween(o - 1, o + 1)) && (o += u ? 1 : -1), (s = o + (s - l)), (l = o);
    }
    return { start: o, endA: s, endB: l };
}
function _0(t) {
    if (t.length != 2) return !1;
    let e = t.charCodeAt(0),
        n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
var Hl = class {
    constructor(e, n) {
        (this._root = null),
            (this.focused = !1),
            (this.trackWrites = null),
            (this.mounted = !1),
            (this.markCursor = null),
            (this.cursorWrapper = null),
            (this.lastSelectedViewDesc = void 0),
            (this.input = new Nf()),
            (this.prevDirectPlugins = []),
            (this.pluginViews = []),
            (this.requiresGeckoHackNode = !1),
            (this.dragging = null),
            (this._props = n),
            (this.state = n.state),
            (this.directPlugins = n.plugins || []),
            this.directPlugins.forEach(C0),
            (this.dispatch = this.dispatch.bind(this)),
            (this.dom = (e && e.mount) || document.createElement('div')),
            e &&
                (e.appendChild
                    ? e.appendChild(this.dom)
                    : typeof e == 'function'
                      ? e(this.dom)
                      : e.mount && (this.mounted = !0)),
            (this.editable = M0(this)),
            T0(this),
            (this.nodeViews = A0(this)),
            (this.docView = i0(this.state.doc, S0(this), mf(this), this.dom, this)),
            (this.domObserver = new Df(this, (r, i, o, s) => aI(this, r, i, o, s))),
            this.domObserver.start(),
            DR(this),
            this.updatePluginViews();
    }
    get composing() {
        return this.input.composing;
    }
    get props() {
        if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let n in e) this._props[n] = e[n];
            this._props.state = this.state;
        }
        return this._props;
    }
    update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && Of(this);
        let n = this._props;
        (this._props = e),
            e.plugins && (e.plugins.forEach(C0), (this.directPlugins = e.plugins)),
            this.updateStateInner(e.state, n);
    }
    setProps(e) {
        let n = {};
        for (let r in this._props) n[r] = this._props[r];
        n.state = this.state;
        for (let r in e) n[r] = e[r];
        this.update(n);
    }
    updateState(e) {
        this.updateStateInner(e, this._props);
    }
    updateStateInner(e, n) {
        var r;
        let i = this.state,
            o = !1,
            s = !1;
        e.storedMarks && this.composing && (Q0(this), (s = !0)), (this.state = e);
        let l = i.plugins != e.plugins || this._props.plugins != n.plugins;
        if (l || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let b = A0(this);
            fI(b, this.nodeViews) && ((this.nodeViews = b), (o = !0));
        }
        (l || n.handleDOMEvents != this._props.handleDOMEvents) && Of(this), (this.editable = M0(this)), T0(this);
        let u = mf(this),
            d = S0(this),
            f =
                i.plugins != e.plugins && !i.doc.eq(e.doc)
                    ? 'reset'
                    : e.scrollToSelection > i.scrollToSelection
                      ? 'to selection'
                      : 'preserve',
            h = o || !this.docView.matchesNode(e.doc, d, u);
        (h || !e.selection.eq(i.selection)) && (s = !0);
        let m = f == 'preserve' && s && this.dom.style.overflowAnchor == null && eR(this);
        if (s) {
            this.domObserver.stop();
            let b =
                h &&
                (vn || dn) &&
                !this.composing &&
                !i.selection.empty &&
                !e.selection.empty &&
                dI(i.selection, e.selection);
            if (h) {
                let y = dn ? (this.trackWrites = this.domSelectionRange().focusNode) : null;
                this.composing && (this.input.compositionNode = qR(this)),
                    (o || !this.docView.update(e.doc, d, u, this)) &&
                        (this.docView.updateOuterDeco(d),
                        this.docView.destroy(),
                        (this.docView = i0(e.doc, d, u, this.dom, this))),
                    y && !this.trackWrites && (b = !0);
            }
            b || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && wR(this))
                ? Br(this, b)
                : (z0(this, e.selection), this.domObserver.setCurSelection()),
                this.domObserver.start();
        }
        this.updatePluginViews(i),
            !((r = this.dragging) === null || r === void 0) &&
                r.node &&
                !i.doc.eq(e.doc) &&
                this.updateDraggedNode(this.dragging, i),
            f == 'reset' ? (this.dom.scrollTop = 0) : f == 'to selection' ? this.scrollToSelection() : m && tR(m);
    }
    scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!this.someProp('handleScrollToSelection', (n) => n(this)))
            if (this.state.selection instanceof pe) {
                let n = this.docView.domAfterPos(this.state.selection.from);
                n.nodeType == 1 && jy(this, n.getBoundingClientRect(), e);
            } else jy(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
    destroyPluginViews() {
        let e;
        for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
    }
    updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            (this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this));
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this));
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, e);
            }
    }
    updateDraggedNode(e, n) {
        let r = e.node,
            i = -1;
        if (this.state.doc.nodeAt(r.from) == r.node) i = r.from;
        else {
            let o = r.from + (this.state.doc.content.size - n.doc.content.size);
            (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
        }
        this.dragging = new Dl(e.slice, e.move, i < 0 ? void 0 : pe.create(this.state.doc, i));
    }
    someProp(e, n) {
        let r = this._props && this._props[e],
            i;
        if (r != null && (i = n ? n(r) : r)) return i;
        for (let s = 0; s < this.directPlugins.length; s++) {
            let l = this.directPlugins[s].props[e];
            if (l != null && (i = n ? n(l) : l)) return i;
        }
        let o = this.state.plugins;
        if (o)
            for (let s = 0; s < o.length; s++) {
                let l = o[s].props[e];
                if (l != null && (i = n ? n(l) : l)) return i;
            }
    }
    hasFocus() {
        if (vn) {
            let e = this.root.activeElement;
            if (e == this.dom) return !0;
            if (!e || !this.dom.contains(e)) return !1;
            for (; e && this.dom != e && this.dom.contains(e); ) {
                if (e.contentEditable == 'false') return !1;
                e = e.parentElement;
            }
            return !0;
        }
        return this.root.activeElement == this.dom;
    }
    focus() {
        this.domObserver.stop(), this.editable && nR(this.dom), Br(this), this.domObserver.start();
    }
    get root() {
        let e = this._root;
        if (e == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
                    return (
                        n.getSelection ||
                            (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
                        (this._root = n)
                    );
        }
        return e || document;
    }
    updateRoot() {
        this._root = null;
    }
    posAtCoords(e) {
        return aR(this, e);
    }
    coordsAtPos(e, n = 1) {
        return L0(this, e, n);
    }
    domAtPos(e, n = 0) {
        return this.docView.domFromPos(e, n);
    }
    nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null;
    }
    posAtDOM(e, n, r = -1) {
        let i = this.docView.posFromDOM(e, n, r);
        if (i == null) throw new RangeError('DOM position not inside the editor');
        return i;
    }
    endOfTextblock(e, n) {
        return fR(this, n || this.state, e);
    }
    pasteHTML(e, n) {
        return Js(this, '', e, !1, n || new ClipboardEvent('paste'));
    }
    pasteText(e, n) {
        return Js(this, e, null, !0, n || new ClipboardEvent('paste'));
    }
    destroy() {
        this.docView &&
            (PR(this),
            this.destroyPluginViews(),
            this.mounted
                ? (this.docView.update(this.state.doc, [], mf(this), this), (this.dom.textContent = ''))
                : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
            this.docView.destroy(),
            (this.docView = null),
            UO());
    }
    get isDestroyed() {
        return this.docView == null;
    }
    dispatchEvent(e) {
        return FR(this, e);
    }
    dispatch(e) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, e) : this.updateState(this.state.apply(e));
    }
    domSelectionRange() {
        let e = this.domSelection();
        return (fn && this.root.nodeType === 11 && qO(this.dom.ownerDocument) == this.dom && rI(this, e)) || e;
    }
    domSelection() {
        return this.root.getSelection();
    }
};
function S0(t) {
    let e = Object.create(null);
    return (
        (e.class = 'ProseMirror'),
        (e.contenteditable = String(t.editable)),
        t.someProp('attributes', (n) => {
            if ((typeof n == 'function' && (n = n(t.state)), n))
                for (let r in n)
                    r == 'class'
                        ? (e.class += ' ' + n[r])
                        : r == 'style'
                          ? (e.style = (e.style ? e.style + ';' : '') + n[r])
                          : !e[r] && r != 'contenteditable' && r != 'nodeName' && (e[r] = String(n[r]));
        }),
        e.translate || (e.translate = 'no'),
        [Mt.node(0, t.state.doc.content.size, e)]
    );
}
function T0(t) {
    if (t.markCursor) {
        let e = document.createElement('img');
        (e.className = 'ProseMirror-separator'),
            e.setAttribute('mark-placeholder', 'true'),
            e.setAttribute('alt', ''),
            (t.cursorWrapper = {
                dom: e,
                deco: Mt.widget(t.state.selection.head, e, { raw: !0, marks: t.markCursor }),
            });
    } else t.cursorWrapper = null;
}
function M0(t) {
    return !t.someProp('editable', (e) => e(t.state) === !1);
}
function dI(t, e) {
    let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
    return t.$anchor.start(n) != e.$anchor.start(n);
}
function A0(t) {
    let e = Object.create(null);
    function n(r) {
        for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
    }
    return t.someProp('nodeViews', n), t.someProp('markViews', n), e;
}
function fI(t, e) {
    let n = 0,
        r = 0;
    for (let i in t) {
        if (t[i] != e[i]) return !0;
        n++;
    }
    for (let i in e) r++;
    return n != r;
}
function C0(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
        throw new RangeError('Plugins passed directly to the view must not have a state component');
}
var Fr = {
        8: 'Backspace',
        9: 'Tab',
        10: 'Enter',
        12: 'NumLock',
        13: 'Enter',
        16: 'Shift',
        17: 'Control',
        18: 'Alt',
        20: 'CapsLock',
        27: 'Escape',
        32: ' ',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'ArrowLeft',
        38: 'ArrowUp',
        39: 'ArrowRight',
        40: 'ArrowDown',
        44: 'PrintScreen',
        45: 'Insert',
        46: 'Delete',
        59: ';',
        61: '=',
        91: 'Meta',
        92: 'Meta',
        106: '*',
        107: '+',
        108: ',',
        109: '-',
        110: '.',
        111: '/',
        144: 'NumLock',
        145: 'ScrollLock',
        160: 'Shift',
        161: 'Shift',
        162: 'Control',
        163: 'Control',
        164: 'Alt',
        165: 'Alt',
        173: '-',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: "'",
    },
    Wl = {
        48: ')',
        49: '!',
        50: '@',
        51: '#',
        52: '$',
        53: '%',
        54: '^',
        55: '&',
        56: '*',
        57: '(',
        59: ':',
        61: '+',
        173: '_',
        186: ':',
        187: '+',
        188: '<',
        189: '_',
        190: '>',
        191: '?',
        192: '~',
        219: '{',
        220: '|',
        221: '}',
        222: '"',
    },
    pI = typeof navigator < 'u' && /Mac/.test(navigator.platform),
    hI = typeof navigator < 'u' && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (At = 0; At < 10; At++) Fr[48 + At] = Fr[96 + At] = String(At);
var At;
for (At = 1; At <= 24; At++) Fr[At + 111] = 'F' + At;
var At;
for (At = 65; At <= 90; At++) (Fr[At] = String.fromCharCode(At + 32)), (Wl[At] = String.fromCharCode(At));
var At;
for (Ul in Fr) Wl.hasOwnProperty(Ul) || (Wl[Ul] = Fr[Ul]);
var Ul;
function oE(t) {
    var e =
            (pI && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
            (hI && t.shiftKey && t.key && t.key.length == 1) ||
            t.key == 'Unidentified',
        n = (!e && t.key) || (t.shiftKey ? Wl : Fr)[t.keyCode] || t.key || 'Unidentified';
    return (
        n == 'Esc' && (n = 'Escape'),
        n == 'Del' && (n = 'Delete'),
        n == 'Left' && (n = 'ArrowLeft'),
        n == 'Up' && (n = 'ArrowUp'),
        n == 'Right' && (n = 'ArrowRight'),
        n == 'Down' && (n = 'ArrowDown'),
        n
    );
}
var mI = typeof navigator < 'u' ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function gI(t) {
    let e = t.split(/-(?!$)/),
        n = e[e.length - 1];
    n == 'Space' && (n = ' ');
    let r, i, o, s;
    for (let l = 0; l < e.length - 1; l++) {
        let u = e[l];
        if (/^(cmd|meta|m)$/i.test(u)) s = !0;
        else if (/^a(lt)?$/i.test(u)) r = !0;
        else if (/^(c|ctrl|control)$/i.test(u)) i = !0;
        else if (/^s(hift)?$/i.test(u)) o = !0;
        else if (/^mod$/i.test(u)) mI ? (s = !0) : (i = !0);
        else throw new Error('Unrecognized modifier name: ' + u);
    }
    return r && (n = 'Alt-' + n), i && (n = 'Ctrl-' + n), s && (n = 'Meta-' + n), o && (n = 'Shift-' + n), n;
}
function bI(t) {
    let e = Object.create(null);
    for (let n in t) e[gI(n)] = t[n];
    return e;
}
function Wf(t, e, n = !0) {
    return (
        e.altKey && (t = 'Alt-' + t),
        e.ctrlKey && (t = 'Ctrl-' + t),
        e.metaKey && (t = 'Meta-' + t),
        n && e.shiftKey && (t = 'Shift-' + t),
        t
    );
}
function sE(t) {
    return new Oe({ props: { handleKeyDown: Qs(t) } });
}
function Qs(t) {
    let e = bI(t);
    return function (n, r) {
        let i = oE(r),
            o,
            s = e[Wf(i, r)];
        if (s && s(n.state, n.dispatch, n)) return !0;
        if (i.length == 1 && i != ' ') {
            if (r.shiftKey) {
                let l = e[Wf(i, r, !1)];
                if (l && l(n.state, n.dispatch, n)) return !0;
            }
            if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = Fr[r.keyCode]) && o != i) {
                let l = e[Wf(o, r)];
                if (l && l(n.state, n.dispatch, n)) return !0;
            }
        }
        return !1;
    };
}
var Kl = (t, e) => (t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0));
function lE(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock('backward', t) : n.parentOffset > 0) ? null : n;
}
var Vf = (t, e, n) => {
        let r = lE(t, n);
        if (!r) return !1;
        let i = qf(r);
        if (!i) {
            let s = r.blockRange(),
                l = s && Lr(s);
            return l == null ? !1 : (e && e(t.tr.lift(s, l).scrollIntoView()), !0);
        }
        let o = i.nodeBefore;
        if (!o.type.spec.isolating && bE(t, i, e)) return !0;
        if (r.parent.content.size == 0 && (Ko(o, 'end') || pe.isSelectable(o))) {
            let s = $s(t.doc, r.before(), r.after(), X.empty);
            if (s && s.slice.size < s.to - s.from) {
                if (e) {
                    let l = t.tr.step(s);
                    l.setSelection(
                        Ko(o, 'end')
                            ? fe.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1)
                            : pe.create(l.doc, i.pos - o.nodeSize),
                    ),
                        e(l.scrollIntoView());
                }
                return !0;
            }
        }
        return o.isAtom && i.depth == r.depth - 1
            ? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0)
            : !1;
    },
    cE = (t, e, n) => {
        let r = lE(t, n);
        if (!r) return !1;
        let i = qf(r);
        return i ? dE(t, i, e) : !1;
    },
    uE = (t, e, n) => {
        let r = fE(t, n);
        if (!r) return !1;
        let i = Xf(r);
        return i ? dE(t, i, e) : !1;
    };
function dE(t, e, n) {
    let r = e.nodeBefore,
        i = r,
        o = e.pos - 1;
    for (; !i.isTextblock; o--) {
        if (i.type.spec.isolating) return !1;
        let f = i.lastChild;
        if (!f) return !1;
        i = f;
    }
    let s = e.nodeAfter,
        l = s,
        u = e.pos + 1;
    for (; !l.isTextblock; u++) {
        if (l.type.spec.isolating) return !1;
        let f = l.firstChild;
        if (!f) return !1;
        l = f;
    }
    let d = $s(t.doc, o, u, X.empty);
    if (!d || d.from != o || (d instanceof nn && d.slice.size >= u - o)) return !1;
    if (n) {
        let f = t.tr.step(d);
        f.setSelection(ce.create(f.doc, o)), n(f.scrollIntoView());
    }
    return !0;
}
function Ko(t, e, n = !1) {
    for (let r = t; r; r = e == 'start' ? r.firstChild : r.lastChild) {
        if (r.isTextblock) return !0;
        if (n && r.childCount != 1) return !1;
    }
    return !1;
}
var Gf = (t, e, n) => {
    let { $head: r, empty: i } = t.selection,
        o = r;
    if (!i) return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock('backward', t) : r.parentOffset > 0) return !1;
        o = qf(r);
    }
    let s = o && o.nodeBefore;
    return !s || !pe.isSelectable(s)
        ? !1
        : (e && e(t.tr.setSelection(pe.create(t.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function qf(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
            if (t.node(e).type.spec.isolating) break;
        }
    return null;
}
function fE(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock('forward', t) : n.parentOffset < n.parent.content.size) ? null : n;
}
var Yf = (t, e, n) => {
        let r = fE(t, n);
        if (!r) return !1;
        let i = Xf(r);
        if (!i) return !1;
        let o = i.nodeAfter;
        if (bE(t, i, e)) return !0;
        if (r.parent.content.size == 0 && (Ko(o, 'start') || pe.isSelectable(o))) {
            let s = $s(t.doc, r.before(), r.after(), X.empty);
            if (s && s.slice.size < s.to - s.from) {
                if (e) {
                    let l = t.tr.step(s);
                    l.setSelection(
                        Ko(o, 'start')
                            ? fe.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1)
                            : pe.create(l.doc, l.mapping.map(i.pos)),
                    ),
                        e(l.scrollIntoView());
                }
                return !0;
            }
        }
        return o.isAtom && i.depth == r.depth - 1
            ? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0)
            : !1;
    },
    Jf = (t, e, n) => {
        let { $head: r, empty: i } = t.selection,
            o = r;
        if (!i) return !1;
        if (r.parent.isTextblock) {
            if (n ? !n.endOfTextblock('forward', t) : r.parentOffset < r.parent.content.size) return !1;
            o = Xf(r);
        }
        let s = o && o.nodeAfter;
        return !s || !pe.isSelectable(s)
            ? !1
            : (e && e(t.tr.setSelection(pe.create(t.doc, o.pos)).scrollIntoView()), !0);
    };
function Xf(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            let n = t.node(e);
            if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
            if (n.type.spec.isolating) break;
        }
    return null;
}
var pE = (t, e) => {
        let n = t.selection,
            r = n instanceof pe,
            i;
        if (r) {
            if (n.node.isTextblock || !tr(t.doc, n.from)) return !1;
            i = n.from;
        } else if (((i = Po(t.doc, n.from, -1)), i == null)) return !1;
        if (e) {
            let o = t.tr.join(i);
            r && o.setSelection(pe.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(o.scrollIntoView());
        }
        return !0;
    },
    hE = (t, e) => {
        let n = t.selection,
            r;
        if (n instanceof pe) {
            if (n.node.isTextblock || !tr(t.doc, n.to)) return !1;
            r = n.to;
        } else if (((r = Po(t.doc, n.to, 1)), r == null)) return !1;
        return e && e(t.tr.join(r).scrollIntoView()), !0;
    },
    mE = (t, e) => {
        let { $from: n, $to: r } = t.selection,
            i = n.blockRange(r),
            o = i && Lr(i);
        return o == null ? !1 : (e && e(t.tr.lift(i, o).scrollIntoView()), !0);
    },
    Zf = (t, e) => {
        let { $head: n, $anchor: r } = t.selection;
        return !n.parent.type.spec.code || !n.sameParent(r)
            ? !1
            : (e &&
                  e(
                      t.tr
                          .insertText(
                              `
`,
                          )
                          .scrollIntoView(),
                  ),
              !0);
    };
function jf(t) {
    for (let e = 0; e < t.edgeCount; e++) {
        let { type: n } = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs()) return n;
    }
    return null;
}
var Qf = (t, e) => {
        let { $head: n, $anchor: r } = t.selection;
        if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
        let i = n.node(-1),
            o = n.indexAfter(-1),
            s = jf(i.contentMatchAt(o));
        if (!s || !i.canReplaceWith(o, o, s)) return !1;
        if (e) {
            let l = n.after(),
                u = t.tr.replaceWith(l, l, s.createAndFill());
            u.setSelection(fe.near(u.doc.resolve(l), 1)), e(u.scrollIntoView());
        }
        return !0;
    },
    ep = (t, e) => {
        let n = t.selection,
            { $from: r, $to: i } = n;
        if (n instanceof Nn || r.parent.inlineContent || i.parent.inlineContent) return !1;
        let o = jf(i.parent.contentMatchAt(i.indexAfter()));
        if (!o || !o.isTextblock) return !1;
        if (e) {
            let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos,
                l = t.tr.insert(s, o.createAndFill());
            l.setSelection(ce.create(l.doc, s + 1)), e(l.scrollIntoView());
        }
        return !0;
    },
    tp = (t, e) => {
        let { $cursor: n } = t.selection;
        if (!n || n.parent.content.size) return !1;
        if (n.depth > 1 && n.after() != n.end(-1)) {
            let o = n.before();
            if (Hn(t.doc, o)) return e && e(t.tr.split(o).scrollIntoView()), !0;
        }
        let r = n.blockRange(),
            i = r && Lr(r);
        return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
    };
function yI(t) {
    return (e, n) => {
        let { $from: r, $to: i } = e.selection;
        if (e.selection instanceof pe && e.selection.node.isBlock)
            return !r.parentOffset || !Hn(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
        if (!r.parent.isBlock) return !1;
        if (n) {
            let o = i.parentOffset == i.parent.content.size,
                s = e.tr;
            (e.selection instanceof ce || e.selection instanceof Nn) && s.deleteSelection();
            let l = r.depth == 0 ? null : jf(r.node(-1).contentMatchAt(r.indexAfter(-1))),
                u = t && t(i.parent, o),
                d = u ? [u] : o && l ? [{ type: l }] : void 0,
                f = Hn(s.doc, s.mapping.map(r.pos), 1, d);
            if (
                (!d &&
                    !f &&
                    Hn(s.doc, s.mapping.map(r.pos), 1, l ? [{ type: l }] : void 0) &&
                    (l && (d = [{ type: l }]), (f = !0)),
                f && (s.split(s.mapping.map(r.pos), 1, d), !o && !r.parentOffset && r.parent.type != l))
            ) {
                let h = s.mapping.map(r.before()),
                    m = s.doc.resolve(h);
                l &&
                    r.node(-1).canReplaceWith(m.index(), m.index() + 1, l) &&
                    s.setNodeMarkup(s.mapping.map(r.before()), l);
            }
            n(s.scrollIntoView());
        }
        return !0;
    };
}
var EI = yI();
var gE = (t, e) => {
        let { $from: n, to: r } = t.selection,
            i,
            o = n.sharedDepth(r);
        return o == 0 ? !1 : ((i = n.before(o)), e && e(t.tr.setSelection(pe.create(t.doc, i))), !0);
    },
    vI = (t, e) => (e && e(t.tr.setSelection(new Nn(t.doc))), !0);
function wI(t, e, n) {
    let r = e.nodeBefore,
        i = e.nodeAfter,
        o = e.index();
    return !r || !i || !r.type.compatibleContent(i.type)
        ? !1
        : !r.content.size && e.parent.canReplace(o - 1, o)
          ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
          : !e.parent.canReplace(o, o + 1) || !(i.isTextblock || tr(t.doc, e.pos))
            ? !1
            : (n &&
                  n(t.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()),
              !0);
}
function bE(t, e, n) {
    let r = e.nodeBefore,
        i = e.nodeAfter,
        o,
        s;
    if (r.type.spec.isolating || i.type.spec.isolating) return !1;
    if (wI(t, e, n)) return !0;
    let l = e.parent.canReplace(e.index(), e.index() + 1);
    if (l && (o = (s = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && s.matchType(o[0] || i.type).validEnd) {
        if (n) {
            let h = e.pos + i.nodeSize,
                m = K.empty;
            for (let v = o.length - 1; v >= 0; v--) m = K.from(o[v].create(null, m));
            m = K.from(r.copy(m));
            let b = t.tr.step(new Tt(e.pos - 1, h, e.pos, h, new X(m, 1, 0), o.length, !0)),
                y = h + 2 * o.length;
            tr(b.doc, y) && b.join(y), n(b.scrollIntoView());
        }
        return !0;
    }
    let u = fe.findFrom(e, 1),
        d = u && u.$from.blockRange(u.$to),
        f = d && Lr(d);
    if (f != null && f >= e.depth) return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
    if (l && Ko(i, 'start', !0) && Ko(r, 'end')) {
        let h = r,
            m = [];
        for (; m.push(h), !h.isTextblock; ) h = h.lastChild;
        let b = i,
            y = 1;
        for (; !b.isTextblock; b = b.firstChild) y++;
        if (h.canReplace(h.childCount, h.childCount, b.content)) {
            if (n) {
                let v = K.empty;
                for (let T = m.length - 1; T >= 0; T--) v = K.from(m[T].copy(v));
                let x = t.tr.step(
                    new Tt(
                        e.pos - m.length,
                        e.pos + i.nodeSize,
                        e.pos + y,
                        e.pos + i.nodeSize - y,
                        new X(v, m.length, 0),
                        0,
                        !0,
                    ),
                );
                n(x.scrollIntoView());
            }
            return !0;
        }
    }
    return !1;
}
function yE(t) {
    return function (e, n) {
        let r = e.selection,
            i = t < 0 ? r.$from : r.$to,
            o = i.depth;
        for (; i.node(o).isInline; ) {
            if (!o) return !1;
            o--;
        }
        return i.node(o).isTextblock
            ? (n && n(e.tr.setSelection(ce.create(e.doc, t < 0 ? i.start(o) : i.end(o)))), !0)
            : !1;
    };
}
var np = yE(-1),
    rp = yE(1);
function EE(t, e = null) {
    return function (n, r) {
        let { $from: i, $to: o } = n.selection,
            s = i.blockRange(o),
            l = s && Do(s, t, e);
        return l ? (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) : !1;
    };
}
function ip(t, e = null) {
    return function (n, r) {
        let i = !1;
        for (let o = 0; o < n.selection.ranges.length && !i; o++) {
            let {
                $from: { pos: s },
                $to: { pos: l },
            } = n.selection.ranges[o];
            n.doc.nodesBetween(s, l, (u, d) => {
                if (i) return !1;
                if (!(!u.isTextblock || u.hasMarkup(t, e)))
                    if (u.type == t) i = !0;
                    else {
                        let f = n.doc.resolve(d),
                            h = f.index();
                        i = f.parent.canReplaceWith(h, h + 1, t);
                    }
            });
        }
        if (!i) return !1;
        if (r) {
            let o = n.tr;
            for (let s = 0; s < n.selection.ranges.length; s++) {
                let {
                    $from: { pos: l },
                    $to: { pos: u },
                } = n.selection.ranges[s];
                o.setBlockType(l, u, t, e);
            }
            r(o.scrollIntoView());
        }
        return !0;
    };
}
function op(...t) {
    return function (e, n, r) {
        for (let i = 0; i < t.length; i++) if (t[i](e, n, r)) return !0;
        return !1;
    };
}
var Kf = op(Kl, Vf, Gf),
    aE = op(Kl, Yf, Jf),
    pi = {
        Enter: op(Zf, ep, tp, EI),
        'Mod-Enter': Qf,
        Backspace: Kf,
        'Mod-Backspace': Kf,
        'Shift-Backspace': Kf,
        Delete: aE,
        'Mod-Delete': aE,
        'Mod-a': vI,
    },
    xI = {
        'Ctrl-h': pi.Backspace,
        'Alt-Backspace': pi['Mod-Backspace'],
        'Ctrl-d': pi.Delete,
        'Ctrl-Alt-Backspace': pi['Mod-Delete'],
        'Alt-Delete': pi['Mod-Delete'],
        'Alt-d': pi['Mod-Delete'],
        'Ctrl-a': np,
        'Ctrl-e': rp,
    };
for (let t in pi) xI[t] = pi[t];
var Ez =
    typeof navigator < 'u'
        ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
        : typeof os < 'u' && os.platform
          ? os.platform() == 'darwin'
          : !1;
function vE(t, e = null) {
    return function (n, r) {
        let { $from: i, $to: o } = n.selection,
            s = i.blockRange(o),
            l = !1,
            u = s;
        if (!s) return !1;
        if (s.depth >= 2 && i.node(s.depth - 1).type.compatibleContent(t) && s.startIndex == 0) {
            if (i.index(s.depth - 1) == 0) return !1;
            let f = n.doc.resolve(s.start - 2);
            (u = new zi(f, f, s.depth)),
                s.endIndex < s.parent.childCount && (s = new zi(i, n.doc.resolve(o.end(s.depth)), s.depth)),
                (l = !0);
        }
        let d = Do(u, t, e, s);
        return d ? (r && r(_I(n.tr, s, d, l, t).scrollIntoView()), !0) : !1;
    };
}
function _I(t, e, n, r, i) {
    let o = K.empty;
    for (let f = n.length - 1; f >= 0; f--) o = K.from(n[f].type.create(n[f].attrs, o));
    t.step(new Tt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new X(o, 0, 0), n.length, !0));
    let s = 0;
    for (let f = 0; f < n.length; f++) n[f].type == i && (s = f + 1);
    let l = n.length - s,
        u = e.start + n.length - (r ? 2 : 0),
        d = e.parent;
    for (let f = e.startIndex, h = e.endIndex, m = !0; f < h; f++, m = !1)
        !m && Hn(t.doc, u, l) && (t.split(u, l), (u += 2 * l)), (u += d.child(f).nodeSize);
    return t;
}
function wE(t) {
    return function (e, n) {
        let { $from: r, $to: i } = e.selection,
            o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == t);
        return o ? (n ? (r.node(o.depth - 1).type == t ? SI(e, n, t, o) : TI(e, n, o)) : !0) : !1;
    };
}
function SI(t, e, n, r) {
    let i = t.tr,
        o = r.end,
        s = r.$to.end(r.depth);
    o < s &&
        (i.step(new Tt(o - 1, s, o, s, new X(K.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)),
        (r = new zi(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth)));
    let l = Lr(r);
    if (l == null) return !1;
    i.lift(r, l);
    let u = i.mapping.map(o, -1) - 1;
    return tr(i.doc, u) && i.join(u), e(i.scrollIntoView()), !0;
}
function TI(t, e, n) {
    let r = t.tr,
        i = n.parent;
    for (let b = n.end, y = n.endIndex - 1, v = n.startIndex; y > v; y--)
        (b -= i.child(y).nodeSize), r.delete(b - 1, b + 1);
    let o = r.doc.resolve(n.start),
        s = o.nodeAfter;
    if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize) return !1;
    let l = n.startIndex == 0,
        u = n.endIndex == i.childCount,
        d = o.node(-1),
        f = o.index(-1);
    if (!d.canReplace(f + (l ? 0 : 1), f + 1, s.content.append(u ? K.empty : K.from(i)))) return !1;
    let h = o.pos,
        m = h + s.nodeSize;
    return (
        r.step(
            new Tt(
                h - (l ? 1 : 0),
                m + (u ? 1 : 0),
                h + 1,
                m - 1,
                new X(
                    (l ? K.empty : K.from(i.copy(K.empty))).append(u ? K.empty : K.from(i.copy(K.empty))),
                    l ? 0 : 1,
                    u ? 0 : 1,
                ),
                l ? 0 : 1,
            ),
        ),
        e(r.scrollIntoView()),
        !0
    );
}
function xE(t) {
    return function (e, n) {
        let { $from: r, $to: i } = e.selection,
            o = r.blockRange(i, (d) => d.childCount > 0 && d.firstChild.type == t);
        if (!o) return !1;
        let s = o.startIndex;
        if (s == 0) return !1;
        let l = o.parent,
            u = l.child(s - 1);
        if (u.type != t) return !1;
        if (n) {
            let d = u.lastChild && u.lastChild.type == l.type,
                f = K.from(d ? t.create() : null),
                h = new X(K.from(t.create(null, K.from(l.type.create(null, f)))), d ? 3 : 1, 0),
                m = o.start,
                b = o.end;
            n(e.tr.step(new Tt(m - (d ? 3 : 1), b, m, b, h, 1, !0)).scrollIntoView());
        }
        return !0;
    };
}
function Xl(t) {
    let { state: e, transaction: n } = t,
        { selection: r } = n,
        { doc: i } = n,
        { storedMarks: o } = n;
    return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
            return o;
        },
        get selection() {
            return r;
        },
        get doc() {
            return i;
        },
        get tr() {
            return (r = n.selection), (i = n.doc), (o = n.storedMarks), n;
        },
    };
}
var Vo = class {
        constructor(e) {
            (this.editor = e.editor),
                (this.rawCommands = this.editor.extensionManager.commands),
                (this.customState = e.state);
        }
        get hasCustomState() {
            return !!this.customState;
        }
        get state() {
            return this.customState || this.editor.state;
        }
        get commands() {
            let { rawCommands: e, editor: n, state: r } = this,
                { view: i } = n,
                { tr: o } = r,
                s = this.buildProps(o);
            return Object.fromEntries(
                Object.entries(e).map(([l, u]) => [
                    l,
                    (...f) => {
                        let h = u(...f)(s);
                        return !o.getMeta('preventDispatch') && !this.hasCustomState && i.dispatch(o), h;
                    },
                ]),
            );
        }
        get chain() {
            return () => this.createChain();
        }
        get can() {
            return () => this.createCan();
        }
        createChain(e, n = !0) {
            let { rawCommands: r, editor: i, state: o } = this,
                { view: s } = i,
                l = [],
                u = !!e,
                d = e || o.tr,
                f = () => (
                    !u && n && !d.getMeta('preventDispatch') && !this.hasCustomState && s.dispatch(d),
                    l.every((m) => m === !0)
                ),
                h = {
                    ...Object.fromEntries(
                        Object.entries(r).map(([m, b]) => [
                            m,
                            (...v) => {
                                let x = this.buildProps(d, n),
                                    T = b(...v)(x);
                                return l.push(T), h;
                            },
                        ]),
                    ),
                    run: f,
                };
            return h;
        }
        createCan(e) {
            let { rawCommands: n, state: r } = this,
                i = !1,
                o = e || r.tr,
                s = this.buildProps(o, i);
            return {
                ...Object.fromEntries(
                    Object.entries(n).map(([u, d]) => [u, (...f) => d(...f)({ ...s, dispatch: void 0 })]),
                ),
                chain: () => this.createChain(o, i),
            };
        }
        buildProps(e, n = !0) {
            let { rawCommands: r, editor: i, state: o } = this,
                { view: s } = i,
                l = {
                    tr: e,
                    editor: i,
                    view: s,
                    state: Xl({ state: o, transaction: e }),
                    dispatch: n ? () => {} : void 0,
                    chain: () => this.createChain(e, n),
                    can: () => this.createCan(e),
                    get commands() {
                        return Object.fromEntries(Object.entries(r).map(([u, d]) => [u, (...f) => d(...f)(l)]));
                    },
                };
            return l;
        }
    },
    up = class {
        constructor() {
            this.callbacks = {};
        }
        on(e, n) {
            return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
        }
        emit(e, ...n) {
            let r = this.callbacks[e];
            return r && r.forEach((i) => i.apply(this, n)), this;
        }
        off(e, n) {
            let r = this.callbacks[e];
            return r && (n ? (this.callbacks[e] = r.filter((i) => i !== n)) : delete this.callbacks[e]), this;
        }
        removeAllListeners() {
            this.callbacks = {};
        }
    };
function ie(t, e, n) {
    return t.config[e] === void 0 && t.parent
        ? ie(t.parent, e, n)
        : typeof t.config[e] == 'function'
          ? t.config[e].bind({ ...n, parent: t.parent ? ie(t.parent, e, n) : null })
          : t.config[e];
}
function Zl(t) {
    let e = t.filter((i) => i.type === 'extension'),
        n = t.filter((i) => i.type === 'node'),
        r = t.filter((i) => i.type === 'mark');
    return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
}
function NE(t) {
    let e = [],
        { nodeExtensions: n, markExtensions: r } = Zl(t),
        i = [...n, ...r],
        o = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 };
    return (
        t.forEach((s) => {
            let l = { name: s.name, options: s.options, storage: s.storage },
                u = ie(s, 'addGlobalAttributes', l);
            if (!u) return;
            u().forEach((f) => {
                f.types.forEach((h) => {
                    Object.entries(f.attributes).forEach(([m, b]) => {
                        e.push({ type: h, name: m, attribute: { ...o, ...b } });
                    });
                });
            });
        }),
        i.forEach((s) => {
            let l = { name: s.name, options: s.options, storage: s.storage },
                u = ie(s, 'addAttributes', l);
            if (!u) return;
            let d = u();
            Object.entries(d).forEach(([f, h]) => {
                let m = { ...o, ...h };
                typeof m?.default == 'function' && (m.default = m.default()),
                    m?.isRequired && m?.default === void 0 && delete m.default,
                    e.push({ type: s.name, name: f, attribute: m });
            });
        }),
        e
    );
}
function $t(t, e) {
    if (typeof t == 'string') {
        if (!e.nodes[t]) throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
        return e.nodes[t];
    }
    return t;
}
function Z(...t) {
    return t
        .filter((e) => !!e)
        .reduce((e, n) => {
            let r = { ...e };
            return (
                Object.entries(n).forEach(([i, o]) => {
                    if (!r[i]) {
                        r[i] = o;
                        return;
                    }
                    if (i === 'class') {
                        let l = o ? o.split(' ') : [],
                            u = r[i] ? r[i].split(' ') : [],
                            d = l.filter((f) => !u.includes(f));
                        r[i] = [...u, ...d].join(' ');
                    } else i === 'style' ? (r[i] = [r[i], o].join('; ')) : (r[i] = o);
                }),
                r
            );
        }, {});
}
function dp(t, e) {
    return e
        .filter((n) => n.attribute.rendered)
        .map((n) => (n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : { [n.name]: t.attrs[n.name] }))
        .reduce((n, r) => Z(n, r), {});
}
function OE(t) {
    return typeof t == 'function';
}
function Se(t, e = void 0, ...n) {
    return OE(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function MI(t = {}) {
    return Object.keys(t).length === 0 && t.constructor === Object;
}
function AI(t) {
    return typeof t != 'string'
        ? t
        : t.match(/^[+-]?(?:\d*\.)?\d+$/)
          ? Number(t)
          : t === 'true'
            ? !0
            : t === 'false'
              ? !1
              : t;
}
function _E(t, e) {
    return t.style
        ? t
        : {
              ...t,
              getAttrs: (n) => {
                  let r = t.getAttrs ? t.getAttrs(n) : t.attrs;
                  if (r === !1) return !1;
                  let i = e.reduce((o, s) => {
                      let l = s.attribute.parseHTML ? s.attribute.parseHTML(n) : AI(n.getAttribute(s.name));
                      return l == null ? o : { ...o, [s.name]: l };
                  }, {});
                  return { ...r, ...i };
              },
          };
}
function SE(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, n]) => (e === 'attrs' && MI(n) ? !1 : n != null)));
}
function CI(t, e) {
    var n;
    let r = NE(t),
        { nodeExtensions: i, markExtensions: o } = Zl(t),
        s = (n = i.find((d) => ie(d, 'topNode'))) === null || n === void 0 ? void 0 : n.name,
        l = Object.fromEntries(
            i.map((d) => {
                let f = r.filter((T) => T.type === d.name),
                    h = { name: d.name, options: d.options, storage: d.storage, editor: e },
                    m = t.reduce((T, D) => {
                        let I = ie(D, 'extendNodeSchema', h);
                        return { ...T, ...(I ? I(d) : {}) };
                    }, {}),
                    b = SE({
                        ...m,
                        content: Se(ie(d, 'content', h)),
                        marks: Se(ie(d, 'marks', h)),
                        group: Se(ie(d, 'group', h)),
                        inline: Se(ie(d, 'inline', h)),
                        atom: Se(ie(d, 'atom', h)),
                        selectable: Se(ie(d, 'selectable', h)),
                        draggable: Se(ie(d, 'draggable', h)),
                        code: Se(ie(d, 'code', h)),
                        defining: Se(ie(d, 'defining', h)),
                        isolating: Se(ie(d, 'isolating', h)),
                        attrs: Object.fromEntries(
                            f.map((T) => {
                                var D;
                                return [
                                    T.name,
                                    { default: (D = T?.attribute) === null || D === void 0 ? void 0 : D.default },
                                ];
                            }),
                        ),
                    }),
                    y = Se(ie(d, 'parseHTML', h));
                y && (b.parseDOM = y.map((T) => _E(T, f)));
                let v = ie(d, 'renderHTML', h);
                v && (b.toDOM = (T) => v({ node: T, HTMLAttributes: dp(T, f) }));
                let x = ie(d, 'renderText', h);
                return x && (b.toText = x), [d.name, b];
            }),
        ),
        u = Object.fromEntries(
            o.map((d) => {
                let f = r.filter((x) => x.type === d.name),
                    h = { name: d.name, options: d.options, storage: d.storage, editor: e },
                    m = t.reduce((x, T) => {
                        let D = ie(T, 'extendMarkSchema', h);
                        return { ...x, ...(D ? D(d) : {}) };
                    }, {}),
                    b = SE({
                        ...m,
                        inclusive: Se(ie(d, 'inclusive', h)),
                        excludes: Se(ie(d, 'excludes', h)),
                        group: Se(ie(d, 'group', h)),
                        spanning: Se(ie(d, 'spanning', h)),
                        code: Se(ie(d, 'code', h)),
                        attrs: Object.fromEntries(
                            f.map((x) => {
                                var T;
                                return [
                                    x.name,
                                    { default: (T = x?.attribute) === null || T === void 0 ? void 0 : T.default },
                                ];
                            }),
                        ),
                    }),
                    y = Se(ie(d, 'parseHTML', h));
                y && (b.parseDOM = y.map((x) => _E(x, f)));
                let v = ie(d, 'renderHTML', h);
                return v && (b.toDOM = (x) => v({ mark: x, HTMLAttributes: dp(x, f) })), [d.name, b];
            }),
        );
    return new El({ topNode: s, nodes: l, marks: u });
}
function sp(t, e) {
    return e.nodes[t] || e.marks[t] || null;
}
function TE(t, e) {
    return Array.isArray(e) ? e.some((n) => (typeof n == 'string' ? n : n.name) === t.name) : e;
}
var kI = (t, e = 500) => {
    let n = '',
        r = t.parentOffset;
    return (
        t.parent.nodesBetween(Math.max(0, r - e), r, (i, o, s, l) => {
            var u, d;
            let f =
                ((d = (u = i.type.spec).toText) === null || d === void 0
                    ? void 0
                    : d.call(u, { node: i, pos: o, parent: s, index: l })) ||
                i.textContent ||
                '%leaf%';
            n += f.slice(0, Math.max(0, r - o));
        }),
        n
    );
};
function bp(t) {
    return Object.prototype.toString.call(t) === '[object RegExp]';
}
var Go = class {
        constructor(e) {
            (this.find = e.find), (this.handler = e.handler);
        }
    },
    NI = (t, e) => {
        if (bp(e)) return e.exec(t);
        let n = e(t);
        if (!n) return null;
        let r = [n.text];
        return (
            (r.index = n.index),
            (r.input = t),
            (r.data = n.data),
            n.replaceWith &&
                (n.text.includes(n.replaceWith) ||
                    console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),
                r.push(n.replaceWith)),
            r
        );
    };
function Vl(t) {
    var e;
    let { editor: n, from: r, to: i, text: o, rules: s, plugin: l } = t,
        { view: u } = n;
    if (u.composing) return !1;
    let d = u.state.doc.resolve(r);
    if (
        d.parent.type.spec.code ||
        (!((e = d.nodeBefore || d.nodeAfter) === null || e === void 0) && e.marks.find((m) => m.type.spec.code))
    )
        return !1;
    let f = !1,
        h = kI(d) + o;
    return (
        s.forEach((m) => {
            if (f) return;
            let b = NI(h, m.find);
            if (!b) return;
            let y = u.state.tr,
                v = Xl({ state: u.state, transaction: y }),
                x = { from: r - (b[0].length - o.length), to: i },
                { commands: T, chain: D, can: I } = new Vo({ editor: n, state: v });
            m.handler({ state: v, range: x, match: b, commands: T, chain: D, can: I }) === null ||
                !y.steps.length ||
                (y.setMeta(l, { transform: y, from: r, to: i, text: o }), u.dispatch(y), (f = !0));
        }),
        f
    );
}
function OI(t) {
    let { editor: e, rules: n } = t,
        r = new Oe({
            state: {
                init() {
                    return null;
                },
                apply(i, o) {
                    let s = i.getMeta(r);
                    if (s) return s;
                    let l = i.getMeta('applyInputRules');
                    return (
                        !!l &&
                            setTimeout(() => {
                                let { from: d, text: f } = l,
                                    h = d + f.length;
                                Vl({ editor: e, from: d, to: h, text: f, rules: n, plugin: r });
                            }),
                        i.selectionSet || i.docChanged ? null : o
                    );
                },
            },
            props: {
                handleTextInput(i, o, s, l) {
                    return Vl({ editor: e, from: o, to: s, text: l, rules: n, plugin: r });
                },
                handleDOMEvents: {
                    compositionend: (i) => (
                        setTimeout(() => {
                            let { $cursor: o } = i.state.selection;
                            o && Vl({ editor: e, from: o.pos, to: o.pos, text: '', rules: n, plugin: r });
                        }),
                        !1
                    ),
                },
                handleKeyDown(i, o) {
                    if (o.key !== 'Enter') return !1;
                    let { $cursor: s } = i.state.selection;
                    return s
                        ? Vl({
                              editor: e,
                              from: s.pos,
                              to: s.pos,
                              text: `
`,
                              rules: n,
                              plugin: r,
                          })
                        : !1;
                },
            },
            isInputRules: !0,
        });
    return r;
}
function RI(t) {
    return typeof t == 'number';
}
var fp = class {
        constructor(e) {
            (this.find = e.find), (this.handler = e.handler);
        }
    },
    II = (t, e, n) => {
        if (bp(e)) return [...t.matchAll(e)];
        let r = e(t, n);
        return r
            ? r.map((i) => {
                  let o = [i.text];
                  return (
                      (o.index = i.index),
                      (o.input = t),
                      (o.data = i.data),
                      i.replaceWith &&
                          (i.text.includes(i.replaceWith) ||
                              console.warn(
                                  '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".',
                              ),
                          o.push(i.replaceWith)),
                      o
                  );
              })
            : [];
    };
function LI(t) {
    let { editor: e, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: l } = t,
        { commands: u, chain: d, can: f } = new Vo({ editor: e, state: n }),
        h = [];
    return (
        n.doc.nodesBetween(r, i, (b, y) => {
            if (!b.isTextblock || b.type.spec.code) return;
            let v = Math.max(r, y),
                x = Math.min(i, y + b.content.size),
                T = b.textBetween(v - y, x - y, void 0, '\uFFFC');
            II(T, o.find, s).forEach((I) => {
                if (I.index === void 0) return;
                let S = v + I.index + 1,
                    z = S + I[0].length,
                    N = { from: n.tr.mapping.map(S), to: n.tr.mapping.map(z) },
                    q = o.handler({
                        state: n,
                        range: N,
                        match: I,
                        commands: u,
                        chain: d,
                        can: f,
                        pasteEvent: s,
                        dropEvent: l,
                    });
                h.push(q);
            });
        }),
        h.every((b) => b !== null)
    );
}
var DI = (t) => {
    var e;
    let n = new ClipboardEvent('paste', { clipboardData: new DataTransfer() });
    return (e = n.clipboardData) === null || e === void 0 || e.setData('text/html', t), n;
};
function PI(t) {
    let { editor: e, rules: n } = t,
        r = null,
        i = !1,
        o = !1,
        s = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null,
        l = typeof DragEvent < 'u' ? new DragEvent('drop') : null,
        u = ({ state: f, from: h, to: m, rule: b, pasteEvt: y }) => {
            let v = f.tr,
                x = Xl({ state: f, transaction: v });
            if (
                !(
                    !LI({
                        editor: e,
                        state: x,
                        from: Math.max(h - 1, 0),
                        to: m.b - 1,
                        rule: b,
                        pasteEvent: y,
                        dropEvent: l,
                    }) || !v.steps.length
                )
            )
                return (
                    (l = typeof DragEvent < 'u' ? new DragEvent('drop') : null),
                    (s = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null),
                    v
                );
        };
    return n.map(
        (f) =>
            new Oe({
                view(h) {
                    let m = (b) => {
                        var y;
                        r =
                            !((y = h.dom.parentElement) === null || y === void 0) && y.contains(b.target)
                                ? h.dom.parentElement
                                : null;
                    };
                    return (
                        window.addEventListener('dragstart', m),
                        {
                            destroy() {
                                window.removeEventListener('dragstart', m);
                            },
                        }
                    );
                },
                props: {
                    handleDOMEvents: {
                        drop: (h, m) => ((o = r === h.dom.parentElement), (l = m), !1),
                        paste: (h, m) => {
                            var b;
                            let y = (b = m.clipboardData) === null || b === void 0 ? void 0 : b.getData('text/html');
                            return (s = m), (i = !!y?.includes('data-pm-slice')), !1;
                        },
                    },
                },
                appendTransaction: (h, m, b) => {
                    let y = h[0],
                        v = y.getMeta('uiEvent') === 'paste' && !i,
                        x = y.getMeta('uiEvent') === 'drop' && !o,
                        T = y.getMeta('applyPasteRules'),
                        D = !!T;
                    if (!v && !x && !D) return;
                    if (D) {
                        let { from: z, text: N } = T,
                            q = z + N.length,
                            ne = DI(N);
                        return u({ rule: f, state: b, from: z, to: { b: q }, pasteEvt: ne });
                    }
                    let I = m.doc.content.findDiffStart(b.doc.content),
                        S = m.doc.content.findDiffEnd(b.doc.content);
                    if (!(!RI(I) || !S || I === S.b)) return u({ rule: f, state: b, from: I, to: S, pasteEvt: s });
                },
            }),
    );
}
function BI(t) {
    let e = t.filter((n, r) => t.indexOf(n) !== r);
    return [...new Set(e)];
}
var pp = class t {
    constructor(e, n) {
        (this.splittableMarks = []),
            (this.editor = n),
            (this.extensions = t.resolve(e)),
            (this.schema = CI(this.extensions, n)),
            this.setupExtensions();
    }
    static resolve(e) {
        let n = t.sort(t.flatten(e)),
            r = BI(n.map((i) => i.name));
        return (
            r.length &&
                console.warn(
                    `[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(', ')}]. This can lead to issues.`,
                ),
            n
        );
    }
    static flatten(e) {
        return e
            .map((n) => {
                let r = { name: n.name, options: n.options, storage: n.storage },
                    i = ie(n, 'addExtensions', r);
                return i ? [n, ...this.flatten(i())] : n;
            })
            .flat(10);
    }
    static sort(e) {
        return e.sort((r, i) => {
            let o = ie(r, 'priority') || 100,
                s = ie(i, 'priority') || 100;
            return o > s ? -1 : o < s ? 1 : 0;
        });
    }
    get commands() {
        return this.extensions.reduce((e, n) => {
            let r = {
                    name: n.name,
                    options: n.options,
                    storage: n.storage,
                    editor: this.editor,
                    type: sp(n.name, this.schema),
                },
                i = ie(n, 'addCommands', r);
            return i ? { ...e, ...i() } : e;
        }, {});
    }
    get plugins() {
        let { editor: e } = this,
            n = t.sort([...this.extensions].reverse()),
            r = [],
            i = [],
            o = n
                .map((s) => {
                    let l = {
                            name: s.name,
                            options: s.options,
                            storage: s.storage,
                            editor: e,
                            type: sp(s.name, this.schema),
                        },
                        u = [],
                        d = ie(s, 'addKeyboardShortcuts', l),
                        f = {};
                    if (
                        (s.type === 'mark' &&
                            s.config.exitable &&
                            (f.ArrowRight = () => tt.handleExit({ editor: e, mark: s })),
                        d)
                    ) {
                        let v = Object.fromEntries(Object.entries(d()).map(([x, T]) => [x, () => T({ editor: e })]));
                        f = { ...f, ...v };
                    }
                    let h = sE(f);
                    u.push(h);
                    let m = ie(s, 'addInputRules', l);
                    TE(s, e.options.enableInputRules) && m && r.push(...m());
                    let b = ie(s, 'addPasteRules', l);
                    TE(s, e.options.enablePasteRules) && b && i.push(...b());
                    let y = ie(s, 'addProseMirrorPlugins', l);
                    if (y) {
                        let v = y();
                        u.push(...v);
                    }
                    return u;
                })
                .flat();
        return [OI({ editor: e, rules: r }), ...PI({ editor: e, rules: i }), ...o];
    }
    get attributes() {
        return NE(this.extensions);
    }
    get nodeViews() {
        let { editor: e } = this,
            { nodeExtensions: n } = Zl(this.extensions);
        return Object.fromEntries(
            n
                .filter((r) => !!ie(r, 'addNodeView'))
                .map((r) => {
                    let i = this.attributes.filter((u) => u.type === r.name),
                        o = {
                            name: r.name,
                            options: r.options,
                            storage: r.storage,
                            editor: e,
                            type: $t(r.name, this.schema),
                        },
                        s = ie(r, 'addNodeView', o);
                    if (!s) return [];
                    let l = (u, d, f, h) => {
                        let m = dp(u, i);
                        return s()({ editor: e, node: u, getPos: f, decorations: h, HTMLAttributes: m, extension: r });
                    };
                    return [r.name, l];
                }),
        );
    }
    setupExtensions() {
        this.extensions.forEach((e) => {
            var n;
            this.editor.extensionStorage[e.name] = e.storage;
            let r = {
                name: e.name,
                options: e.options,
                storage: e.storage,
                editor: this.editor,
                type: sp(e.name, this.schema),
            };
            e.type === 'mark' &&
                (!((n = Se(ie(e, 'keepOnSplit', r))) !== null && n !== void 0) || n) &&
                this.splittableMarks.push(e.name);
            let i = ie(e, 'onBeforeCreate', r),
                o = ie(e, 'onCreate', r),
                s = ie(e, 'onUpdate', r),
                l = ie(e, 'onSelectionUpdate', r),
                u = ie(e, 'onTransaction', r),
                d = ie(e, 'onFocus', r),
                f = ie(e, 'onBlur', r),
                h = ie(e, 'onDestroy', r);
            i && this.editor.on('beforeCreate', i),
                o && this.editor.on('create', o),
                s && this.editor.on('update', s),
                l && this.editor.on('selectionUpdate', l),
                u && this.editor.on('transaction', u),
                d && this.editor.on('focus', d),
                f && this.editor.on('blur', f),
                h && this.editor.on('destroy', h);
        });
    }
};
function FI(t) {
    return Object.prototype.toString.call(t).slice(8, -1);
}
function ap(t) {
    return FI(t) !== 'Object' ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function jl(t, e) {
    let n = { ...t };
    return (
        ap(t) &&
            ap(e) &&
            Object.keys(e).forEach((r) => {
                ap(e[r])
                    ? r in t
                        ? (n[r] = jl(t[r], e[r]))
                        : Object.assign(n, { [r]: e[r] })
                    : Object.assign(n, { [r]: e[r] });
            }),
        n
    );
}
var Ge = class t {
    constructor(e = {}) {
        (this.type = 'extension'),
            (this.name = 'extension'),
            (this.parent = null),
            (this.child = null),
            (this.config = { name: this.name, defaultOptions: {} }),
            (this.config = { ...this.config, ...e }),
            (this.name = this.config.name),
            e.defaultOptions &&
                Object.keys(e.defaultOptions).length > 0 &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`,
                ),
            (this.options = this.config.defaultOptions),
            this.config.addOptions && (this.options = Se(ie(this, 'addOptions', { name: this.name }))),
            (this.storage = Se(ie(this, 'addStorage', { name: this.name, options: this.options })) || {});
    }
    static create(e = {}) {
        return new t(e);
    }
    configure(e = {}) {
        let n = this.extend();
        return (
            (n.parent = this.parent),
            (n.options = jl(this.options, e)),
            (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
            n
        );
    }
    extend(e = {}) {
        let n = new t({ ...this.config, ...e });
        return (
            (n.parent = this),
            (this.child = n),
            (n.name = e.name ? e.name : n.parent.name),
            e.defaultOptions &&
                console.warn(
                    `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`,
                ),
            (n.options = Se(ie(n, 'addOptions', { name: n.name }))),
            (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
            n
        );
    }
};
function RE(t, e, n) {
    let { from: r, to: i } = e,
        {
            blockSeparator: o = `

`,
            textSerializers: s = {},
        } = n || {},
        l = '';
    return (
        t.nodesBetween(r, i, (u, d, f, h) => {
            var m;
            u.isBlock && d > r && (l += o);
            let b = s?.[u.type.name];
            if (b) return f && (l += b({ node: u, pos: d, parent: f, index: h, range: e })), !1;
            u.isText && (l += (m = u?.text) === null || m === void 0 ? void 0 : m.slice(Math.max(r, d) - d, i - d));
        }),
        l
    );
}
function IE(t) {
    return Object.fromEntries(
        Object.entries(t.nodes)
            .filter(([, e]) => e.spec.toText)
            .map(([e, n]) => [e, n.spec.toText]),
    );
}
var HI = Ge.create({
        name: 'clipboardTextSerializer',
        addOptions() {
            return { blockSeparator: void 0 };
        },
        addProseMirrorPlugins() {
            return [
                new Oe({
                    key: new ze('clipboardTextSerializer'),
                    props: {
                        clipboardTextSerializer: () => {
                            let { editor: t } = this,
                                { state: e, schema: n } = t,
                                { doc: r, selection: i } = e,
                                { ranges: o } = i,
                                s = Math.min(...o.map((f) => f.$from.pos)),
                                l = Math.max(...o.map((f) => f.$to.pos)),
                                u = IE(n);
                            return RE(
                                r,
                                { from: s, to: l },
                                {
                                    ...(this.options.blockSeparator !== void 0
                                        ? { blockSeparator: this.options.blockSeparator }
                                        : {}),
                                    textSerializers: u,
                                },
                            );
                        },
                    },
                }),
            ];
        },
    }),
    zI =
        () =>
        ({ editor: t, view: e }) => (
            requestAnimationFrame(() => {
                var n;
                t.isDestroyed ||
                    (e.dom.blur(), (n = window?.getSelection()) === null || n === void 0 || n.removeAllRanges());
            }),
            !0
        ),
    $I =
        (t = !1) =>
        ({ commands: e }) =>
            e.setContent('', t),
    UI =
        () =>
        ({ state: t, tr: e, dispatch: n }) => {
            let { selection: r } = e,
                { ranges: i } = r;
            return (
                n &&
                    i.forEach(({ $from: o, $to: s }) => {
                        t.doc.nodesBetween(o.pos, s.pos, (l, u) => {
                            if (l.type.isText) return;
                            let { doc: d, mapping: f } = e,
                                h = d.resolve(f.map(u)),
                                m = d.resolve(f.map(u + l.nodeSize)),
                                b = h.blockRange(m);
                            if (!b) return;
                            let y = Lr(b);
                            if (l.type.isTextblock) {
                                let { defaultType: v } = h.parent.contentMatchAt(h.index());
                                e.setNodeMarkup(b.start, v);
                            }
                            (y || y === 0) && e.lift(b, y);
                        });
                    }),
                !0
            );
        },
    WI = (t) => (e) => t(e),
    KI =
        () =>
        ({ state: t, dispatch: e }) =>
            ep(t, e),
    VI =
        (t, e) =>
        ({ editor: n, tr: r }) => {
            let { state: i } = n,
                o = i.doc.slice(t.from, t.to);
            r.deleteRange(t.from, t.to);
            let s = r.mapping.map(e);
            return r.insert(s, o.content), r.setSelection(new ce(r.doc.resolve(s - 1))), !0;
        },
    GI =
        () =>
        ({ tr: t, dispatch: e }) => {
            let { selection: n } = t,
                r = n.$anchor.node();
            if (r.content.size > 0) return !1;
            let i = t.selection.$anchor;
            for (let o = i.depth; o > 0; o -= 1)
                if (i.node(o).type === r.type) {
                    if (e) {
                        let l = i.before(o),
                            u = i.after(o);
                        t.delete(l, u).scrollIntoView();
                    }
                    return !0;
                }
            return !1;
        },
    qI =
        (t) =>
        ({ tr: e, state: n, dispatch: r }) => {
            let i = $t(t, n.schema),
                o = e.selection.$anchor;
            for (let s = o.depth; s > 0; s -= 1)
                if (o.node(s).type === i) {
                    if (r) {
                        let u = o.before(s),
                            d = o.after(s);
                        e.delete(u, d).scrollIntoView();
                    }
                    return !0;
                }
            return !1;
        },
    YI =
        (t) =>
        ({ tr: e, dispatch: n }) => {
            let { from: r, to: i } = t;
            return n && e.delete(r, i), !0;
        },
    JI =
        () =>
        ({ state: t, dispatch: e }) =>
            Kl(t, e),
    XI =
        () =>
        ({ commands: t }) =>
            t.keyboardShortcut('Enter'),
    ZI =
        () =>
        ({ state: t, dispatch: e }) =>
            Qf(t, e);
function ql(t, e, n = { strict: !0 }) {
    let r = Object.keys(e);
    return r.length ? r.every((i) => (n.strict ? e[i] === t[i] : bp(e[i]) ? e[i].test(t[i]) : e[i] === t[i])) : !0;
}
function hp(t, e, n = {}) {
    return t.find((r) => r.type === e && ql(r.attrs, n));
}
function jI(t, e, n = {}) {
    return !!hp(t, e, n);
}
function yp(t, e, n = {}) {
    if (!t || !e) return;
    let r = t.parent.childAfter(t.parentOffset);
    if ((t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)), !r.node)) return;
    let i = hp([...r.node.marks], e, n);
    if (!i) return;
    let o = r.index,
        s = t.start() + r.offset,
        l = o + 1,
        u = s + r.node.nodeSize;
    for (hp([...r.node.marks], e, n); o > 0 && i.isInSet(t.parent.child(o - 1).marks); )
        (o -= 1), (s -= t.parent.child(o).nodeSize);
    for (; l < t.parent.childCount && jI([...t.parent.child(l).marks], e, n); )
        (u += t.parent.child(l).nodeSize), (l += 1);
    return { from: s, to: u };
}
function hi(t, e) {
    if (typeof t == 'string') {
        if (!e.marks[t]) throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
        return e.marks[t];
    }
    return t;
}
var QI =
        (t, e = {}) =>
        ({ tr: n, state: r, dispatch: i }) => {
            let o = hi(t, r.schema),
                { doc: s, selection: l } = n,
                { $from: u, from: d, to: f } = l;
            if (i) {
                let h = yp(u, o, e);
                if (h && h.from <= d && h.to >= f) {
                    let m = ce.create(s, h.from, h.to);
                    n.setSelection(m);
                }
            }
            return !0;
        },
    eL = (t) => (e) => {
        let n = typeof t == 'function' ? t(e) : t;
        for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
        return !1;
    };
function Ql(t) {
    return t instanceof ce;
}
function Hr(t = 0, e = 0, n = 0) {
    return Math.min(Math.max(t, e), n);
}
function LE(t, e = null) {
    if (!e) return null;
    let n = fe.atStart(t),
        r = fe.atEnd(t);
    if (e === 'start' || e === !0) return n;
    if (e === 'end') return r;
    let i = n.from,
        o = r.to;
    return e === 'all' ? ce.create(t, Hr(0, i, o), Hr(t.content.size, i, o)) : ce.create(t, Hr(e, i, o), Hr(e, i, o));
}
function Ep() {
    return (
        ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
            navigator.platform,
        ) ||
        (navigator.userAgent.includes('Mac') && 'ontouchend' in document)
    );
}
var tL =
        (t = null, e = {}) =>
        ({ editor: n, view: r, tr: i, dispatch: o }) => {
            e = { scrollIntoView: !0, ...e };
            let s = () => {
                Ep() && r.dom.focus(),
                    requestAnimationFrame(() => {
                        n.isDestroyed || (r.focus(), e?.scrollIntoView && n.commands.scrollIntoView());
                    });
            };
            if ((r.hasFocus() && t === null) || t === !1) return !0;
            if (o && t === null && !Ql(n.state.selection)) return s(), !0;
            let l = LE(i.doc, t) || n.state.selection,
                u = n.state.selection.eq(l);
            return o && (u || i.setSelection(l), u && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
        },
    nL = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })),
    rL =
        (t, e) =>
        ({ tr: n, commands: r }) =>
            r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
    DE = (t) => {
        let e = t.childNodes;
        for (let n = e.length - 1; n >= 0; n -= 1) {
            let r = e[n];
            r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
                ? t.removeChild(r)
                : r.nodeType === 1 && DE(r);
        }
        return t;
    };
function ME(t) {
    let e = `<body>${t}</body>`,
        n = new window.DOMParser().parseFromString(e, 'text/html').body;
    return DE(n);
}
function Yl(t, e, n) {
    n = { slice: !0, parseOptions: {}, ...n };
    let r = typeof t == 'object' && t !== null,
        i = typeof t == 'string';
    if (r)
        try {
            return Array.isArray(t) && t.length > 0 ? K.fromArray(t.map((s) => e.nodeFromJSON(s))) : e.nodeFromJSON(t);
        } catch (o) {
            return console.warn('[tiptap warn]: Invalid content.', 'Passed value:', t, 'Error:', o), Yl('', e, n);
        }
    if (i) {
        let o = Ui.fromSchema(e);
        return n.slice ? o.parseSlice(ME(t), n.parseOptions).content : o.parse(ME(t), n.parseOptions);
    }
    return Yl('', e, n);
}
function iL(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e) return;
    let i = t.steps[r];
    if (!(i instanceof nn || i instanceof Tt)) return;
    let o = t.mapping.maps[r],
        s = 0;
    o.forEach((l, u, d, f) => {
        s === 0 && (s = f);
    }),
        t.setSelection(fe.near(t.doc.resolve(s), n));
}
var oL = (t) => t.toString().startsWith('<'),
    sL =
        (t, e, n) =>
        ({ tr: r, dispatch: i, editor: o }) => {
            if (i) {
                n = { parseOptions: {}, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...n };
                let s = Yl(e, o.schema, { parseOptions: { preserveWhitespace: 'full', ...n.parseOptions } });
                if (s.toString() === '<>') return !0;
                let { from: l, to: u } = typeof t == 'number' ? { from: t, to: t } : { from: t.from, to: t.to },
                    d = !0,
                    f = !0;
                if (
                    ((oL(s) ? s : [s]).forEach((b) => {
                        b.check(), (d = d ? b.isText && b.marks.length === 0 : !1), (f = f ? b.isBlock : !1);
                    }),
                    l === u && f)
                ) {
                    let { parent: b } = r.doc.resolve(l);
                    b.isTextblock && !b.type.spec.code && !b.childCount && ((l -= 1), (u += 1));
                }
                let m;
                d
                    ? (Array.isArray(e)
                          ? (m = e.map((b) => b.text || '').join(''))
                          : typeof e == 'object' && e && e.text
                            ? (m = e.text)
                            : (m = e),
                      r.insertText(m, l, u))
                    : ((m = s), r.replaceWith(l, u, m)),
                    n.updateSelection && iL(r, r.steps.length - 1, -1),
                    n.applyInputRules && r.setMeta('applyInputRules', { from: l, text: m }),
                    n.applyPasteRules && r.setMeta('applyPasteRules', { from: l, text: m });
            }
            return !0;
        },
    aL =
        () =>
        ({ state: t, dispatch: e }) =>
            pE(t, e),
    lL =
        () =>
        ({ state: t, dispatch: e }) =>
            hE(t, e),
    cL =
        () =>
        ({ state: t, dispatch: e }) =>
            Vf(t, e),
    uL =
        () =>
        ({ state: t, dispatch: e }) =>
            Yf(t, e),
    dL =
        () =>
        ({ tr: t, state: e, dispatch: n }) => {
            try {
                let r = Po(e.doc, e.selection.$from.pos, -1);
                return r == null ? !1 : (t.join(r, 2), n && n(t), !0);
            } catch {
                return !1;
            }
        },
    fL =
        () =>
        ({ state: t, dispatch: e, tr: n }) => {
            try {
                let r = Po(t.doc, t.selection.$from.pos, 1);
                return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
            } catch {
                return !1;
            }
        },
    pL =
        () =>
        ({ state: t, dispatch: e }) =>
            cE(t, e),
    hL =
        () =>
        ({ state: t, dispatch: e }) =>
            uE(t, e);
function PE() {
    return typeof navigator < 'u' ? /Mac/.test(navigator.platform) : !1;
}
function mL(t) {
    let e = t.split(/-(?!$)/),
        n = e[e.length - 1];
    n === 'Space' && (n = ' ');
    let r, i, o, s;
    for (let l = 0; l < e.length - 1; l += 1) {
        let u = e[l];
        if (/^(cmd|meta|m)$/i.test(u)) s = !0;
        else if (/^a(lt)?$/i.test(u)) r = !0;
        else if (/^(c|ctrl|control)$/i.test(u)) i = !0;
        else if (/^s(hift)?$/i.test(u)) o = !0;
        else if (/^mod$/i.test(u)) Ep() || PE() ? (s = !0) : (i = !0);
        else throw new Error(`Unrecognized modifier name: ${u}`);
    }
    return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
var gL =
    (t) =>
    ({ editor: e, view: n, tr: r, dispatch: i }) => {
        let o = mL(t).split(/-(?!$)/),
            s = o.find((d) => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(d)),
            l = new KeyboardEvent('keydown', {
                key: s === 'Space' ? ' ' : s,
                altKey: o.includes('Alt'),
                ctrlKey: o.includes('Ctrl'),
                metaKey: o.includes('Meta'),
                shiftKey: o.includes('Shift'),
                bubbles: !0,
                cancelable: !0,
            }),
            u = e.captureTransaction(() => {
                n.someProp('handleKeyDown', (d) => d(n, l));
            });
        return (
            u?.steps.forEach((d) => {
                let f = d.map(r.mapping);
                f && i && r.maybeStep(f);
            }),
            !0
        );
    };
function ea(t, e, n = {}) {
    let { from: r, to: i, empty: o } = t.selection,
        s = e ? $t(e, t.schema) : null,
        l = [];
    t.doc.nodesBetween(r, i, (h, m) => {
        if (h.isText) return;
        let b = Math.max(r, m),
            y = Math.min(i, m + h.nodeSize);
        l.push({ node: h, from: b, to: y });
    });
    let u = i - r,
        d = l.filter((h) => (s ? s.name === h.node.type.name : !0)).filter((h) => ql(h.node.attrs, n, { strict: !1 }));
    return o ? !!d.length : d.reduce((h, m) => h + m.to - m.from, 0) >= u;
}
var bL =
        (t, e = {}) =>
        ({ state: n, dispatch: r }) => {
            let i = $t(t, n.schema);
            return ea(n, i, e) ? mE(n, r) : !1;
        },
    yL =
        () =>
        ({ state: t, dispatch: e }) =>
            tp(t, e),
    EL =
        (t) =>
        ({ state: e, dispatch: n }) => {
            let r = $t(t, e.schema);
            return wE(r)(e, n);
        },
    vL =
        () =>
        ({ state: t, dispatch: e }) =>
            Zf(t, e);
function ec(t, e) {
    return e.nodes[t] ? 'node' : e.marks[t] ? 'mark' : null;
}
function AE(t, e) {
    let n = typeof e == 'string' ? [e] : e;
    return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
var wL =
        (t, e) =>
        ({ tr: n, state: r, dispatch: i }) => {
            let o = null,
                s = null,
                l = ec(typeof t == 'string' ? t : t.name, r.schema);
            return l
                ? (l === 'node' && (o = $t(t, r.schema)),
                  l === 'mark' && (s = hi(t, r.schema)),
                  i &&
                      n.selection.ranges.forEach((u) => {
                          r.doc.nodesBetween(u.$from.pos, u.$to.pos, (d, f) => {
                              o && o === d.type && n.setNodeMarkup(f, void 0, AE(d.attrs, e)),
                                  s &&
                                      d.marks.length &&
                                      d.marks.forEach((h) => {
                                          s === h.type && n.addMark(f, f + d.nodeSize, s.create(AE(h.attrs, e)));
                                      });
                          });
                      }),
                  !0)
                : !1;
        },
    xL =
        () =>
        ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
    _L =
        () =>
        ({ tr: t, commands: e }) =>
            e.setTextSelection({ from: 0, to: t.doc.content.size }),
    SL =
        () =>
        ({ state: t, dispatch: e }) =>
            Gf(t, e),
    TL =
        () =>
        ({ state: t, dispatch: e }) =>
            Jf(t, e),
    ML =
        () =>
        ({ state: t, dispatch: e }) =>
            gE(t, e),
    AL =
        () =>
        ({ state: t, dispatch: e }) =>
            rp(t, e),
    CL =
        () =>
        ({ state: t, dispatch: e }) =>
            np(t, e);
function BE(t, e, n = {}) {
    return Yl(t, e, { slice: !1, parseOptions: n });
}
var kL =
    (t, e = !1, n = {}) =>
    ({ tr: r, editor: i, dispatch: o }) => {
        let { doc: s } = r,
            l = BE(t, i.schema, n);
        return o && r.replaceWith(0, s.content.size, l).setMeta('preventUpdate', !e), !0;
    };
function mi(t, e) {
    let n = hi(e, t.schema),
        { from: r, to: i, empty: o } = t.selection,
        s = [];
    o
        ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks()))
        : t.doc.nodesBetween(r, i, (u) => {
              s.push(...u.marks);
          });
    let l = s.find((u) => u.type.name === n.name);
    return l ? { ...l.attrs } : {};
}
function FE(t, e) {
    let n = new si(t);
    return (
        e.forEach((r) => {
            r.steps.forEach((i) => {
                n.step(i);
            });
        }),
        n
    );
}
function vp(t) {
    for (let e = 0; e < t.edgeCount; e += 1) {
        let { type: n } = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs()) return n;
    }
    return null;
}
function Qi(t, e) {
    let n = [];
    return (
        t.descendants((r, i) => {
            e(r) && n.push({ node: r, pos: i });
        }),
        n
    );
}
function HE(t, e, n) {
    let r = [];
    return (
        t.nodesBetween(e.from, e.to, (i, o) => {
            n(i) && r.push({ node: i, pos: o });
        }),
        r
    );
}
function wp(t, e) {
    for (let n = t.depth; n > 0; n -= 1) {
        let r = t.node(n);
        if (e(r)) return { pos: n > 0 ? t.before(n) : 0, start: t.start(n), depth: n, node: r };
    }
}
function eo(t) {
    return (e) => wp(e.$from, t);
}
function NL(t, e) {
    let n = Rr.fromSchema(e).serializeFragment(t),
        i = document.implementation.createHTMLDocument().createElement('div');
    return i.appendChild(n), i.innerHTML;
}
function OL(t, e) {
    let n = { from: 0, to: t.content.size };
    return RE(t, n, e);
}
function RL(t, e) {
    let n = $t(e, t.schema),
        { from: r, to: i } = t.selection,
        o = [];
    t.doc.nodesBetween(r, i, (l) => {
        o.push(l);
    });
    let s = o.reverse().find((l) => l.type.name === n.name);
    return s ? { ...s.attrs } : {};
}
function xp(t, e) {
    let n = ec(typeof e == 'string' ? e : e.name, t.schema);
    return n === 'node' ? RL(t, e) : n === 'mark' ? mi(t, e) : {};
}
function IL(t, e = JSON.stringify) {
    let n = {};
    return t.filter((r) => {
        let i = e(r);
        return Object.prototype.hasOwnProperty.call(n, i) ? !1 : (n[i] = !0);
    });
}
function LL(t) {
    let e = IL(t);
    return e.length === 1
        ? e
        : e.filter(
              (n, r) =>
                  !e
                      .filter((o, s) => s !== r)
                      .some(
                          (o) =>
                              n.oldRange.from >= o.oldRange.from &&
                              n.oldRange.to <= o.oldRange.to &&
                              n.newRange.from >= o.newRange.from &&
                              n.newRange.to <= o.newRange.to,
                      ),
          );
}
function zE(t) {
    let { mapping: e, steps: n } = t,
        r = [];
    return (
        e.maps.forEach((i, o) => {
            let s = [];
            if (i.ranges.length)
                i.forEach((l, u) => {
                    s.push({ from: l, to: u });
                });
            else {
                let { from: l, to: u } = n[o];
                if (l === void 0 || u === void 0) return;
                s.push({ from: l, to: u });
            }
            s.forEach(({ from: l, to: u }) => {
                let d = e.slice(o).map(l, -1),
                    f = e.slice(o).map(u),
                    h = e.invert().map(d, -1),
                    m = e.invert().map(f);
                r.push({ oldRange: { from: h, to: m }, newRange: { from: d, to: f } });
            });
        }),
        LL(r)
    );
}
function tc(t, e, n) {
    let r = [];
    return (
        t === e
            ? n
                  .resolve(t)
                  .marks()
                  .forEach((i) => {
                      let o = n.resolve(t - 1),
                          s = yp(o, i.type);
                      s && r.push({ mark: i, ...s });
                  })
            : n.nodesBetween(t, e, (i, o) => {
                  !i ||
                      i?.nodeSize === void 0 ||
                      r.push(...i.marks.map((s) => ({ from: o, to: o + i.nodeSize, mark: s })));
              }),
        r
    );
}
function Gl(t, e, n) {
    return Object.fromEntries(
        Object.entries(n).filter(([r]) => {
            let i = t.find((o) => o.type === e && o.name === r);
            return i ? i.attribute.keepOnSplit : !1;
        }),
    );
}
function mp(t, e, n = {}) {
    let { empty: r, ranges: i } = t.selection,
        o = e ? hi(e, t.schema) : null;
    if (r)
        return !!(t.storedMarks || t.selection.$from.marks())
            .filter((h) => (o ? o.name === h.type.name : !0))
            .find((h) => ql(h.attrs, n, { strict: !1 }));
    let s = 0,
        l = [];
    if (
        (i.forEach(({ $from: h, $to: m }) => {
            let b = h.pos,
                y = m.pos;
            t.doc.nodesBetween(b, y, (v, x) => {
                if (!v.isText && !v.marks.length) return;
                let T = Math.max(b, x),
                    D = Math.min(y, x + v.nodeSize),
                    I = D - T;
                (s += I), l.push(...v.marks.map((S) => ({ mark: S, from: T, to: D })));
            });
        }),
        s === 0)
    )
        return !1;
    let u = l
            .filter((h) => (o ? o.name === h.mark.type.name : !0))
            .filter((h) => ql(h.mark.attrs, n, { strict: !1 }))
            .reduce((h, m) => h + m.to - m.from, 0),
        d = l
            .filter((h) => (o ? h.mark.type !== o && h.mark.type.excludes(o) : !0))
            .reduce((h, m) => h + m.to - m.from, 0);
    return (u > 0 ? u + d : u) >= s;
}
function zr(t, e, n = {}) {
    if (!e) return ea(t, null, n) || mp(t, null, n);
    let r = ec(e, t.schema);
    return r === 'node' ? ea(t, e, n) : r === 'mark' ? mp(t, e, n) : !1;
}
function CE(t, e) {
    let { nodeExtensions: n } = Zl(e),
        r = n.find((s) => s.name === t);
    if (!r) return !1;
    let i = { name: r.name, options: r.options, storage: r.storage },
        o = Se(ie(r, 'group', i));
    return typeof o != 'string' ? !1 : o.split(' ').includes('list');
}
function DL(t) {
    var e;
    let n = (e = t.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON(),
        r = t.toJSON();
    return JSON.stringify(n) === JSON.stringify(r);
}
function $E(t) {
    return t instanceof pe;
}
function nc(t, e, n) {
    let i = t.state.doc.content.size,
        o = Hr(e, 0, i),
        s = Hr(n, 0, i),
        l = t.coordsAtPos(o),
        u = t.coordsAtPos(s, -1),
        d = Math.min(l.top, u.top),
        f = Math.max(l.bottom, u.bottom),
        h = Math.min(l.left, u.left),
        m = Math.max(l.right, u.right),
        b = m - h,
        y = f - d,
        T = { top: d, bottom: f, left: h, right: m, width: b, height: y, x: h, y: d };
    return { ...T, toJSON: () => T };
}
function PL(t, e, n) {
    var r;
    let { selection: i } = e,
        o = null;
    if ((Ql(i) && (o = i.$cursor), o)) {
        let l = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks();
        return !!n.isInSet(l) || !l.some((u) => u.type.excludes(n));
    }
    let { ranges: s } = i;
    return s.some(({ $from: l, $to: u }) => {
        let d = l.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
        return (
            t.doc.nodesBetween(l.pos, u.pos, (f, h, m) => {
                if (d) return !1;
                if (f.isInline) {
                    let b = !m || m.type.allowsMarkType(n),
                        y = !!n.isInSet(f.marks) || !f.marks.some((v) => v.type.excludes(n));
                    d = b && y;
                }
                return !d;
            }),
            d
        );
    });
}
var BL =
        (t, e = {}) =>
        ({ tr: n, state: r, dispatch: i }) => {
            let { selection: o } = n,
                { empty: s, ranges: l } = o,
                u = hi(t, r.schema);
            if (i)
                if (s) {
                    let d = mi(r, u);
                    n.addStoredMark(u.create({ ...d, ...e }));
                } else
                    l.forEach((d) => {
                        let f = d.$from.pos,
                            h = d.$to.pos;
                        r.doc.nodesBetween(f, h, (m, b) => {
                            let y = Math.max(b, f),
                                v = Math.min(b + m.nodeSize, h);
                            m.marks.find((T) => T.type === u)
                                ? m.marks.forEach((T) => {
                                      u === T.type && n.addMark(y, v, u.create({ ...T.attrs, ...e }));
                                  })
                                : n.addMark(y, v, u.create(e));
                        });
                    });
            return PL(r, n, u);
        },
    FL =
        (t, e) =>
        ({ tr: n }) => (n.setMeta(t, e), !0),
    HL =
        (t, e = {}) =>
        ({ state: n, dispatch: r, chain: i }) => {
            let o = $t(t, n.schema);
            return o.isTextblock
                ? i()
                      .command(({ commands: s }) => (ip(o, e)(n) ? !0 : s.clearNodes()))
                      .command(({ state: s }) => ip(o, e)(s, r))
                      .run()
                : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
        },
    zL =
        (t) =>
        ({ tr: e, dispatch: n }) => {
            if (n) {
                let { doc: r } = e,
                    i = Hr(t, 0, r.content.size),
                    o = pe.create(r, i);
                e.setSelection(o);
            }
            return !0;
        },
    $L =
        (t) =>
        ({ tr: e, dispatch: n }) => {
            if (n) {
                let { doc: r } = e,
                    { from: i, to: o } = typeof t == 'number' ? { from: t, to: t } : t,
                    s = ce.atStart(r).from,
                    l = ce.atEnd(r).to,
                    u = Hr(i, s, l),
                    d = Hr(o, s, l),
                    f = ce.create(r, u, d);
                e.setSelection(f);
            }
            return !0;
        },
    UL =
        (t) =>
        ({ state: e, dispatch: n }) => {
            let r = $t(t, e.schema);
            return xE(r)(e, n);
        };
function kE(t, e) {
    let n = t.storedMarks || (t.selection.$to.parentOffset && t.selection.$from.marks());
    if (n) {
        let r = n.filter((i) => e?.includes(i.type.name));
        t.tr.ensureMarks(r);
    }
}
var WL =
        ({ keepMarks: t = !0 } = {}) =>
        ({ tr: e, state: n, dispatch: r, editor: i }) => {
            let { selection: o, doc: s } = e,
                { $from: l, $to: u } = o,
                d = i.extensionManager.attributes,
                f = Gl(d, l.node().type.name, l.node().attrs);
            if (o instanceof pe && o.node.isBlock)
                return !l.parentOffset || !Hn(s, l.pos)
                    ? !1
                    : (r && (t && kE(n, i.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()), !0);
            if (!l.parent.isBlock) return !1;
            if (r) {
                let h = u.parentOffset === u.parent.content.size;
                o instanceof ce && e.deleteSelection();
                let m = l.depth === 0 ? void 0 : vp(l.node(-1).contentMatchAt(l.indexAfter(-1))),
                    b = h && m ? [{ type: m, attrs: f }] : void 0,
                    y = Hn(e.doc, e.mapping.map(l.pos), 1, b);
                if (
                    (!b &&
                        !y &&
                        Hn(e.doc, e.mapping.map(l.pos), 1, m ? [{ type: m }] : void 0) &&
                        ((y = !0), (b = m ? [{ type: m, attrs: f }] : void 0)),
                    y && (e.split(e.mapping.map(l.pos), 1, b), m && !h && !l.parentOffset && l.parent.type !== m))
                ) {
                    let v = e.mapping.map(l.before()),
                        x = e.doc.resolve(v);
                    l.node(-1).canReplaceWith(x.index(), x.index() + 1, m) &&
                        e.setNodeMarkup(e.mapping.map(l.before()), m);
                }
                t && kE(n, i.extensionManager.splittableMarks), e.scrollIntoView();
            }
            return !0;
        },
    KL =
        (t) =>
        ({ tr: e, state: n, dispatch: r, editor: i }) => {
            var o;
            let s = $t(t, n.schema),
                { $from: l, $to: u } = n.selection,
                d = n.selection.node;
            if ((d && d.isBlock) || l.depth < 2 || !l.sameParent(u)) return !1;
            let f = l.node(-1);
            if (f.type !== s) return !1;
            let h = i.extensionManager.attributes;
            if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
                if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1) return !1;
                if (r) {
                    let x = K.empty,
                        T = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
                    for (let q = l.depth - T; q >= l.depth - 3; q -= 1) x = K.from(l.node(q).copy(x));
                    let D =
                            l.indexAfter(-1) < l.node(-2).childCount
                                ? 1
                                : l.indexAfter(-2) < l.node(-3).childCount
                                  ? 2
                                  : 3,
                        I = Gl(h, l.node().type.name, l.node().attrs),
                        S =
                            ((o = s.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(I)) ||
                            void 0;
                    x = x.append(K.from(s.createAndFill(null, S) || void 0));
                    let z = l.before(l.depth - (T - 1));
                    e.replace(z, l.after(-D), new X(x, 4 - T, 0));
                    let N = -1;
                    e.doc.nodesBetween(z, e.doc.content.size, (q, ne) => {
                        if (N > -1) return !1;
                        q.isTextblock && q.content.size === 0 && (N = ne + 1);
                    }),
                        N > -1 && e.setSelection(ce.near(e.doc.resolve(N))),
                        e.scrollIntoView();
                }
                return !0;
            }
            let m = u.pos === l.end() ? f.contentMatchAt(0).defaultType : null,
                b = Gl(h, f.type.name, f.attrs),
                y = Gl(h, l.node().type.name, l.node().attrs);
            e.delete(l.pos, u.pos);
            let v = m
                ? [
                      { type: s, attrs: b },
                      { type: m, attrs: y },
                  ]
                : [{ type: s, attrs: b }];
            if (!Hn(e.doc, l.pos, 2)) return !1;
            if (r) {
                let { selection: x, storedMarks: T } = n,
                    { splittableMarks: D } = i.extensionManager,
                    I = T || (x.$to.parentOffset && x.$from.marks());
                if ((e.split(l.pos, 2, v).scrollIntoView(), !I || !r)) return !0;
                let S = I.filter((z) => D.includes(z.type.name));
                e.ensureMarks(S);
            }
            return !0;
        },
    lp = (t, e) => {
        let n = eo((s) => s.type === e)(t.selection);
        if (!n) return !0;
        let r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
        if (r === void 0) return !0;
        let i = t.doc.nodeAt(r);
        return n.node.type === i?.type && tr(t.doc, n.pos) && t.join(n.pos), !0;
    },
    cp = (t, e) => {
        let n = eo((s) => s.type === e)(t.selection);
        if (!n) return !0;
        let r = t.doc.resolve(n.start).after(n.depth);
        if (r === void 0) return !0;
        let i = t.doc.nodeAt(r);
        return n.node.type === i?.type && tr(t.doc, r) && t.join(r), !0;
    },
    VL =
        (t, e, n, r = {}) =>
        ({ editor: i, tr: o, state: s, dispatch: l, chain: u, commands: d, can: f }) => {
            let { extensions: h, splittableMarks: m } = i.extensionManager,
                b = $t(t, s.schema),
                y = $t(e, s.schema),
                { selection: v, storedMarks: x } = s,
                { $from: T, $to: D } = v,
                I = T.blockRange(D),
                S = x || (v.$to.parentOffset && v.$from.marks());
            if (!I) return !1;
            let z = eo((N) => CE(N.type.name, h))(v);
            if (I.depth >= 1 && z && I.depth - z.depth <= 1) {
                if (z.node.type === b) return d.liftListItem(y);
                if (CE(z.node.type.name, h) && b.validContent(z.node.content) && l)
                    return u()
                        .command(() => (o.setNodeMarkup(z.pos, b), !0))
                        .command(() => lp(o, b))
                        .command(() => cp(o, b))
                        .run();
            }
            return !n || !S || !l
                ? u()
                      .command(() => (f().wrapInList(b, r) ? !0 : d.clearNodes()))
                      .wrapInList(b, r)
                      .command(() => lp(o, b))
                      .command(() => cp(o, b))
                      .run()
                : u()
                      .command(() => {
                          let N = f().wrapInList(b, r),
                              q = S.filter((ne) => m.includes(ne.type.name));
                          return o.ensureMarks(q), N ? !0 : d.clearNodes();
                      })
                      .wrapInList(b, r)
                      .command(() => lp(o, b))
                      .command(() => cp(o, b))
                      .run();
        },
    GL =
        (t, e = {}, n = {}) =>
        ({ state: r, commands: i }) => {
            let { extendEmptyMarkRange: o = !1 } = n,
                s = hi(t, r.schema);
            return mp(r, s, e) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, e);
        },
    qL =
        (t, e, n = {}) =>
        ({ state: r, commands: i }) => {
            let o = $t(t, r.schema),
                s = $t(e, r.schema);
            return ea(r, o, n) ? i.setNode(s) : i.setNode(o, n);
        },
    YL =
        (t, e = {}) =>
        ({ state: n, commands: r }) => {
            let i = $t(t, n.schema);
            return ea(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
        },
    JL =
        () =>
        ({ state: t, dispatch: e }) => {
            let n = t.plugins;
            for (let r = 0; r < n.length; r += 1) {
                let i = n[r],
                    o;
                if (i.spec.isInputRules && (o = i.getState(t))) {
                    if (e) {
                        let s = t.tr,
                            l = o.transform;
                        for (let u = l.steps.length - 1; u >= 0; u -= 1) s.step(l.steps[u].invert(l.docs[u]));
                        if (o.text) {
                            let u = s.doc.resolve(o.from).marks();
                            s.replaceWith(o.from, o.to, t.schema.text(o.text, u));
                        } else s.delete(o.from, o.to);
                    }
                    return !0;
                }
            }
            return !1;
        },
    XL =
        () =>
        ({ tr: t, dispatch: e }) => {
            let { selection: n } = t,
                { empty: r, ranges: i } = n;
            return (
                r ||
                    (e &&
                        i.forEach((o) => {
                            t.removeMark(o.$from.pos, o.$to.pos);
                        })),
                !0
            );
        },
    ZL =
        (t, e = {}) =>
        ({ tr: n, state: r, dispatch: i }) => {
            var o;
            let { extendEmptyMarkRange: s = !1 } = e,
                { selection: l } = n,
                u = hi(t, r.schema),
                { $from: d, empty: f, ranges: h } = l;
            if (!i) return !0;
            if (f && s) {
                let { from: m, to: b } = l,
                    y = (o = d.marks().find((x) => x.type === u)) === null || o === void 0 ? void 0 : o.attrs,
                    v = yp(d, u, y);
                v && ((m = v.from), (b = v.to)), n.removeMark(m, b, u);
            } else
                h.forEach((m) => {
                    n.removeMark(m.$from.pos, m.$to.pos, u);
                });
            return n.removeStoredMark(u), !0;
        },
    jL =
        (t, e = {}) =>
        ({ tr: n, state: r, dispatch: i }) => {
            let o = null,
                s = null,
                l = ec(typeof t == 'string' ? t : t.name, r.schema);
            return l
                ? (l === 'node' && (o = $t(t, r.schema)),
                  l === 'mark' && (s = hi(t, r.schema)),
                  i &&
                      n.selection.ranges.forEach((u) => {
                          let d = u.$from.pos,
                              f = u.$to.pos;
                          r.doc.nodesBetween(d, f, (h, m) => {
                              o && o === h.type && n.setNodeMarkup(m, void 0, { ...h.attrs, ...e }),
                                  s &&
                                      h.marks.length &&
                                      h.marks.forEach((b) => {
                                          if (s === b.type) {
                                              let y = Math.max(m, d),
                                                  v = Math.min(m + h.nodeSize, f);
                                              n.addMark(y, v, s.create({ ...b.attrs, ...e }));
                                          }
                                      });
                          });
                      }),
                  !0)
                : !1;
        },
    QL =
        (t, e = {}) =>
        ({ state: n, dispatch: r }) => {
            let i = $t(t, n.schema);
            return EE(i, e)(n, r);
        },
    eD =
        (t, e = {}) =>
        ({ state: n, dispatch: r }) => {
            let i = $t(t, n.schema);
            return vE(i, e)(n, r);
        },
    tD = Object.freeze({
        __proto__: null,
        blur: zI,
        clearContent: $I,
        clearNodes: UI,
        command: WI,
        createParagraphNear: KI,
        cut: VI,
        deleteCurrentNode: GI,
        deleteNode: qI,
        deleteRange: YI,
        deleteSelection: JI,
        enter: XI,
        exitCode: ZI,
        extendMarkRange: QI,
        first: eL,
        focus: tL,
        forEach: nL,
        insertContent: rL,
        insertContentAt: sL,
        joinUp: aL,
        joinDown: lL,
        joinBackward: cL,
        joinForward: uL,
        joinItemBackward: dL,
        joinItemForward: fL,
        joinTextblockBackward: pL,
        joinTextblockForward: hL,
        keyboardShortcut: gL,
        lift: bL,
        liftEmptyBlock: yL,
        liftListItem: EL,
        newlineInCode: vL,
        resetAttributes: wL,
        scrollIntoView: xL,
        selectAll: _L,
        selectNodeBackward: SL,
        selectNodeForward: TL,
        selectParentNode: ML,
        selectTextblockEnd: AL,
        selectTextblockStart: CL,
        setContent: kL,
        setMark: BL,
        setMeta: FL,
        setNode: HL,
        setNodeSelection: zL,
        setTextSelection: $L,
        sinkListItem: UL,
        splitBlock: WL,
        splitListItem: KL,
        toggleList: VL,
        toggleMark: GL,
        toggleNode: qL,
        toggleWrap: YL,
        undoInputRule: JL,
        unsetAllMarks: XL,
        unsetMark: ZL,
        updateAttributes: jL,
        wrapIn: QL,
        wrapInList: eD,
    }),
    nD = Ge.create({
        name: 'commands',
        addCommands() {
            return { ...tD };
        },
    }),
    rD = Ge.create({
        name: 'editable',
        addProseMirrorPlugins() {
            return [new Oe({ key: new ze('editable'), props: { editable: () => this.editor.options.editable } })];
        },
    }),
    iD = Ge.create({
        name: 'focusEvents',
        addProseMirrorPlugins() {
            let { editor: t } = this;
            return [
                new Oe({
                    key: new ze('focusEvents'),
                    props: {
                        handleDOMEvents: {
                            focus: (e, n) => {
                                t.isFocused = !0;
                                let r = t.state.tr.setMeta('focus', { event: n }).setMeta('addToHistory', !1);
                                return e.dispatch(r), !1;
                            },
                            blur: (e, n) => {
                                t.isFocused = !1;
                                let r = t.state.tr.setMeta('blur', { event: n }).setMeta('addToHistory', !1);
                                return e.dispatch(r), !1;
                            },
                        },
                    },
                }),
            ];
        },
    }),
    oD = Ge.create({
        name: 'keymap',
        addKeyboardShortcuts() {
            let t = () =>
                    this.editor.commands.first(({ commands: s }) => [
                        () => s.undoInputRule(),
                        () =>
                            s.command(({ tr: l }) => {
                                let { selection: u, doc: d } = l,
                                    { empty: f, $anchor: h } = u,
                                    { pos: m, parent: b } = h,
                                    y = h.parent.isTextblock && m > 0 ? l.doc.resolve(m - 1) : h,
                                    v = y.parent.type.spec.isolating,
                                    x = h.pos - h.parentOffset,
                                    T = v && y.parent.childCount === 1 ? x === h.pos : fe.atStart(d).from === m;
                                return !f ||
                                    !b.type.isTextblock ||
                                    b.textContent.length ||
                                    !T ||
                                    (T && h.parent.type.name === 'paragraph')
                                    ? !1
                                    : s.clearNodes();
                            }),
                        () => s.deleteSelection(),
                        () => s.joinBackward(),
                        () => s.selectNodeBackward(),
                    ]),
                e = () =>
                    this.editor.commands.first(({ commands: s }) => [
                        () => s.deleteSelection(),
                        () => s.deleteCurrentNode(),
                        () => s.joinForward(),
                        () => s.selectNodeForward(),
                    ]),
                r = {
                    Enter: () =>
                        this.editor.commands.first(({ commands: s }) => [
                            () => s.newlineInCode(),
                            () => s.createParagraphNear(),
                            () => s.liftEmptyBlock(),
                            () => s.splitBlock(),
                        ]),
                    'Mod-Enter': () => this.editor.commands.exitCode(),
                    Backspace: t,
                    'Mod-Backspace': t,
                    'Shift-Backspace': t,
                    Delete: e,
                    'Mod-Delete': e,
                    'Mod-a': () => this.editor.commands.selectAll(),
                },
                i = { ...r },
                o = {
                    ...r,
                    'Ctrl-h': t,
                    'Alt-Backspace': t,
                    'Ctrl-d': e,
                    'Ctrl-Alt-Backspace': e,
                    'Alt-Delete': e,
                    'Alt-d': e,
                    'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
                    'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),
                };
            return Ep() || PE() ? o : i;
        },
        addProseMirrorPlugins() {
            return [
                new Oe({
                    key: new ze('clearDocument'),
                    appendTransaction: (t, e, n) => {
                        if (!(t.some((y) => y.docChanged) && !e.doc.eq(n.doc))) return;
                        let { empty: i, from: o, to: s } = e.selection,
                            l = fe.atStart(e.doc).from,
                            u = fe.atEnd(e.doc).to;
                        if (
                            i ||
                            !(o === l && s === u) ||
                            !(n.doc.textBetween(0, n.doc.content.size, ' ', ' ').length === 0)
                        )
                            return;
                        let h = n.tr,
                            m = Xl({ state: n, transaction: h }),
                            { commands: b } = new Vo({ editor: this.editor, state: m });
                        if ((b.clearNodes(), !!h.steps.length)) return h;
                    },
                }),
            ];
        },
    }),
    sD = Ge.create({
        name: 'tabindex',
        addProseMirrorPlugins() {
            return [
                new Oe({
                    key: new ze('tabindex'),
                    props: { attributes: this.editor.isEditable ? { tabindex: '0' } : {} },
                }),
            ];
        },
    });
var gp = class t {
        constructor(e, n, r = !1, i = null) {
            (this.currentNode = null),
                (this.actualDepth = null),
                (this.isBlock = r),
                (this.resolvedPos = e),
                (this.editor = n),
                (this.currentNode = i);
        }
        get name() {
            return this.node.type.name;
        }
        get node() {
            return this.currentNode || this.resolvedPos.node();
        }
        get element() {
            return this.editor.view.domAtPos(this.pos).node;
        }
        get depth() {
            var e;
            return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
        }
        get pos() {
            return this.resolvedPos.pos;
        }
        get content() {
            return this.node.content;
        }
        set content(e) {
            let n = this.from,
                r = this.to;
            if (this.isBlock) {
                if (this.content.size === 0) {
                    console.error(
                        `You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`,
                    );
                    return;
                }
                (n = this.from + 1), (r = this.to - 1);
            }
            this.editor.commands.insertContentAt({ from: n, to: r }, e);
        }
        get attributes() {
            return this.node.attrs;
        }
        get textContent() {
            return this.node.textContent;
        }
        get size() {
            return this.node.nodeSize;
        }
        get from() {
            return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
        }
        get range() {
            return { from: this.from, to: this.to };
        }
        get to() {
            return this.isBlock
                ? this.pos + this.size
                : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
        }
        get parent() {
            if (this.depth === 0) return null;
            let e = this.resolvedPos.start(this.resolvedPos.depth - 1),
                n = this.resolvedPos.doc.resolve(e);
            return new t(n, this.editor);
        }
        get before() {
            let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
            return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new t(e, this.editor);
        }
        get after() {
            let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
            return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new t(e, this.editor);
        }
        get children() {
            let e = [];
            return (
                this.node.content.forEach((n, r) => {
                    let i = n.isBlock && !n.isTextblock,
                        o = this.pos + r + 1,
                        s = this.resolvedPos.doc.resolve(o);
                    if (!i && s.depth <= this.depth) return;
                    let l = new t(s, this.editor, i, i ? n : null);
                    i && (l.actualDepth = this.depth + 1), e.push(new t(s, this.editor, i, i ? n : null));
                }),
                e
            );
        }
        get firstChild() {
            return this.children[0] || null;
        }
        get lastChild() {
            let e = this.children;
            return e[e.length - 1] || null;
        }
        closest(e, n = {}) {
            let r = null,
                i = this.parent;
            for (; i && !r; ) {
                if (i.node.type.name === e)
                    if (Object.keys(n).length > 0) {
                        let o = i.node.attrs,
                            s = Object.keys(n);
                        for (let l = 0; l < s.length; l += 1) {
                            let u = s[l];
                            if (o[u] !== n[u]) break;
                        }
                    } else r = i;
                i = i.parent;
            }
            return r;
        }
        querySelector(e, n = {}) {
            return this.querySelectorAll(e, n, !0)[0] || null;
        }
        querySelectorAll(e, n = {}, r = !1) {
            let i = [];
            if (!this.children || this.children.length === 0) return i;
            let o = Object.keys(n);
            return (
                this.children.forEach((s) => {
                    (r && i.length > 0) ||
                        (s.node.type.name === e && o.every((u) => n[u] === s.node.attrs[u]) && i.push(s),
                        !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(e, n, r))));
                }),
                i
            );
        }
        setAttribute(e) {
            let n = this.editor.state.selection;
            this.editor
                .chain()
                .setTextSelection(this.from)
                .updateAttributes(this.node.type.name, e)
                .setTextSelection(n.from)
                .run();
        }
    },
    aD = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function lD(t, e, n) {
    let r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ''}]`);
    if (r !== null) return r;
    let i = document.createElement('style');
    return (
        e && i.setAttribute('nonce', e),
        i.setAttribute(`data-tiptap-style${n ? `-${n}` : ''}`, ''),
        (i.innerHTML = t),
        document.getElementsByTagName('head')[0].appendChild(i),
        i
    );
}
var Jl = class extends up {
    constructor(e = {}) {
        super(),
            (this.isFocused = !1),
            (this.extensionStorage = {}),
            (this.options = {
                element: document.createElement('div'),
                content: '',
                injectCSS: !0,
                injectNonce: void 0,
                extensions: [],
                autofocus: !1,
                editable: !0,
                editorProps: {},
                parseOptions: {},
                coreExtensionOptions: {},
                enableInputRules: !0,
                enablePasteRules: !0,
                enableCoreExtensions: !0,
                onBeforeCreate: () => null,
                onCreate: () => null,
                onUpdate: () => null,
                onSelectionUpdate: () => null,
                onTransaction: () => null,
                onFocus: () => null,
                onBlur: () => null,
                onDestroy: () => null,
            }),
            (this.isCapturingTransaction = !1),
            (this.capturedTransaction = null),
            this.setOptions(e),
            this.createExtensionManager(),
            this.createCommandManager(),
            this.createSchema(),
            this.on('beforeCreate', this.options.onBeforeCreate),
            this.emit('beforeCreate', { editor: this }),
            this.createView(),
            this.injectCSS(),
            this.on('create', this.options.onCreate),
            this.on('update', this.options.onUpdate),
            this.on('selectionUpdate', this.options.onSelectionUpdate),
            this.on('transaction', this.options.onTransaction),
            this.on('focus', this.options.onFocus),
            this.on('blur', this.options.onBlur),
            this.on('destroy', this.options.onDestroy),
            window.setTimeout(() => {
                this.isDestroyed ||
                    (this.commands.focus(this.options.autofocus), this.emit('create', { editor: this }));
            }, 0);
    }
    get storage() {
        return this.extensionStorage;
    }
    get commands() {
        return this.commandManager.commands;
    }
    chain() {
        return this.commandManager.chain();
    }
    can() {
        return this.commandManager.can();
    }
    injectCSS() {
        this.options.injectCSS && document && (this.css = lD(aD, this.options.injectNonce));
    }
    setOptions(e = {}) {
        (this.options = { ...this.options, ...e }),
            !(!this.view || !this.state || this.isDestroyed) &&
                (this.options.editorProps && this.view.setProps(this.options.editorProps),
                this.view.updateState(this.state));
    }
    setEditable(e, n = !0) {
        this.setOptions({ editable: e }), n && this.emit('update', { editor: this, transaction: this.state.tr });
    }
    get isEditable() {
        return this.options.editable && this.view && this.view.editable;
    }
    get state() {
        return this.view.state;
    }
    registerPlugin(e, n) {
        let r = OE(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e],
            i = this.state.reconfigure({ plugins: r });
        this.view.updateState(i);
    }
    unregisterPlugin(e) {
        if (this.isDestroyed) return;
        let n = typeof e == 'string' ? `${e}$` : e.key,
            r = this.state.reconfigure({ plugins: this.state.plugins.filter((i) => !i.key.startsWith(n)) });
        this.view.updateState(r);
    }
    createExtensionManager() {
        var e, n;
        let i = [
            ...(this.options.enableCoreExtensions
                ? [
                      rD,
                      HI.configure({
                          blockSeparator:
                              (n =
                                  (e = this.options.coreExtensionOptions) === null || e === void 0
                                      ? void 0
                                      : e.clipboardTextSerializer) === null || n === void 0
                                  ? void 0
                                  : n.blockSeparator,
                      }),
                      nD,
                      iD,
                      oD,
                      sD,
                  ]
                : []),
            ...this.options.extensions,
        ].filter((o) => ['extension', 'node', 'mark'].includes(o?.type));
        this.extensionManager = new pp(i, this);
    }
    createCommandManager() {
        this.commandManager = new Vo({ editor: this });
    }
    createSchema() {
        this.schema = this.extensionManager.schema;
    }
    createView() {
        let e = BE(this.options.content, this.schema, this.options.parseOptions),
            n = LE(e, this.options.autofocus);
        this.view = new Hl(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: kl.create({ doc: e, selection: n || void 0 }),
        });
        let r = this.state.reconfigure({ plugins: this.extensionManager.plugins });
        this.view.updateState(r), this.createNodeViews(), this.prependClass();
        let i = this.view.dom;
        i.editor = this;
    }
    createNodeViews() {
        this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
    }
    prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(e) {
        (this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1);
        let n = this.capturedTransaction;
        return (this.capturedTransaction = null), n;
    }
    dispatchTransaction(e) {
        if (this.view.isDestroyed) return;
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = e;
                return;
            }
            e.steps.forEach((s) => {
                var l;
                return (l = this.capturedTransaction) === null || l === void 0 ? void 0 : l.step(s);
            });
            return;
        }
        let n = this.state.apply(e),
            r = !this.state.selection.eq(n.selection);
        this.view.updateState(n),
            this.emit('transaction', { editor: this, transaction: e }),
            r && this.emit('selectionUpdate', { editor: this, transaction: e });
        let i = e.getMeta('focus'),
            o = e.getMeta('blur');
        i && this.emit('focus', { editor: this, event: i.event, transaction: e }),
            o && this.emit('blur', { editor: this, event: o.event, transaction: e }),
            !(!e.docChanged || e.getMeta('preventUpdate')) && this.emit('update', { editor: this, transaction: e });
    }
    getAttributes(e) {
        return xp(this.state, e);
    }
    isActive(e, n) {
        let r = typeof e == 'string' ? e : null,
            i = typeof e == 'string' ? n : e;
        return zr(this.state, r, i);
    }
    getJSON() {
        return this.state.doc.toJSON();
    }
    getHTML() {
        return NL(this.state.doc.content, this.schema);
    }
    getText(e) {
        let {
            blockSeparator: n = `

`,
            textSerializers: r = {},
        } = e || {};
        return OL(this.state.doc, { blockSeparator: n, textSerializers: { ...IE(this.schema), ...r } });
    }
    get isEmpty() {
        return DL(this.state.doc);
    }
    getCharacterCount() {
        return (
            console.warn(
                '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.',
            ),
            this.state.doc.content.size - 2
        );
    }
    destroy() {
        this.emit('destroy'), this.view && this.view.destroy(), this.removeAllListeners();
    }
    get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView);
    }
    $node(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
    }
    $nodes(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
    }
    $pos(e) {
        let n = this.state.doc.resolve(e);
        return new gp(n, this);
    }
    get $doc() {
        return this.$pos(0);
    }
};
function Un(t) {
    return new Go({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            let i = Se(t.getAttributes, void 0, r);
            if (i === !1 || i === null) return null;
            let { tr: o } = e,
                s = r[r.length - 1],
                l = r[0];
            if (s) {
                let u = l.search(/\S/),
                    d = n.from + l.indexOf(s),
                    f = d + s.length;
                if (
                    tc(n.from, n.to, e.doc)
                        .filter((b) => b.mark.type.excluded.find((v) => v === t.type && v !== b.mark.type))
                        .filter((b) => b.to > d).length
                )
                    return null;
                f < n.to && o.delete(f, n.to), d > n.from && o.delete(n.from + u, d);
                let m = n.from + u + s.length;
                o.addMark(n.from + u, m, t.type.create(i || {})), o.removeStoredMark(t.type);
            }
        },
    });
}
function rc(t) {
    return new Go({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            let i = Se(t.getAttributes, void 0, r) || {},
                { tr: o } = e,
                s = n.from,
                l = n.to,
                u = t.type.create(i);
            if (r[1]) {
                let d = r[0].lastIndexOf(r[1]),
                    f = s + d;
                f > l ? (f = l) : (l = f + r[1].length);
                let h = r[0][r[0].length - 1];
                o.insertText(h, s + r[0].length - 1), o.replaceWith(f, l, u);
            } else r[0] && o.insert(s - 1, t.type.create(i)).delete(o.mapping.map(s), o.mapping.map(l));
            o.scrollIntoView();
        },
    });
}
function ta(t) {
    return new Go({
        find: t.find,
        handler: ({ state: e, range: n, match: r }) => {
            let i = e.doc.resolve(n.from),
                o = Se(t.getAttributes, void 0, r) || {};
            if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type)) return null;
            e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
        },
    });
}
function gi(t) {
    return new Go({
        find: t.find,
        handler: ({ state: e, range: n, match: r, chain: i }) => {
            let o = Se(t.getAttributes, void 0, r) || {},
                s = e.tr.delete(n.from, n.to),
                u = s.doc.resolve(n.from).blockRange(),
                d = u && Do(u, t.type, o);
            if (!d) return null;
            if ((s.wrap(u, d), t.keepMarks && t.editor)) {
                let { selection: h, storedMarks: m } = e,
                    { splittableMarks: b } = t.editor.extensionManager,
                    y = m || (h.$to.parentOffset && h.$from.marks());
                if (y) {
                    let v = y.filter((x) => b.includes(x.type.name));
                    s.ensureMarks(v);
                }
            }
            if (t.keepAttributes) {
                let h = t.type.name === 'bulletList' || t.type.name === 'orderedList' ? 'listItem' : 'taskList';
                i().updateAttributes(h, o).run();
            }
            let f = s.doc.resolve(n.from - 1).nodeBefore;
            f &&
                f.type === t.type &&
                tr(s.doc, n.from - 1) &&
                (!t.joinPredicate || t.joinPredicate(r, f)) &&
                s.join(n.from - 1);
        },
    });
}
var tt = class t {
        constructor(e = {}) {
            (this.type = 'mark'),
                (this.name = 'mark'),
                (this.parent = null),
                (this.child = null),
                (this.config = { name: this.name, defaultOptions: {} }),
                (this.config = { ...this.config, ...e }),
                (this.name = this.config.name),
                e.defaultOptions &&
                    Object.keys(e.defaultOptions).length > 0 &&
                    console.warn(
                        `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`,
                    ),
                (this.options = this.config.defaultOptions),
                this.config.addOptions && (this.options = Se(ie(this, 'addOptions', { name: this.name }))),
                (this.storage = Se(ie(this, 'addStorage', { name: this.name, options: this.options })) || {});
        }
        static create(e = {}) {
            return new t(e);
        }
        configure(e = {}) {
            let n = this.extend();
            return (
                (n.options = jl(this.options, e)),
                (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
                n
            );
        }
        extend(e = {}) {
            let n = new t({ ...this.config, ...e });
            return (
                (n.parent = this),
                (this.child = n),
                (n.name = e.name ? e.name : n.parent.name),
                e.defaultOptions &&
                    console.warn(
                        `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`,
                    ),
                (n.options = Se(ie(n, 'addOptions', { name: n.name }))),
                (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
                n
            );
        }
        static handleExit({ editor: e, mark: n }) {
            let { tr: r } = e.state,
                i = e.state.selection.$from;
            if (i.pos === i.end()) {
                let s = i.marks();
                if (!!!s.find((d) => d?.type.name === n.name)) return !1;
                let u = s.find((d) => d?.type.name === n.name);
                return u && r.removeStoredMark(u), r.insertText(' ', i.pos), e.view.dispatch(r), !0;
            }
            return !1;
        }
    },
    ae = class t {
        constructor(e = {}) {
            (this.type = 'node'),
                (this.name = 'node'),
                (this.parent = null),
                (this.child = null),
                (this.config = { name: this.name, defaultOptions: {} }),
                (this.config = { ...this.config, ...e }),
                (this.name = this.config.name),
                e.defaultOptions &&
                    Object.keys(e.defaultOptions).length > 0 &&
                    console.warn(
                        `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`,
                    ),
                (this.options = this.config.defaultOptions),
                this.config.addOptions && (this.options = Se(ie(this, 'addOptions', { name: this.name }))),
                (this.storage = Se(ie(this, 'addStorage', { name: this.name, options: this.options })) || {});
        }
        static create(e = {}) {
            return new t(e);
        }
        configure(e = {}) {
            let n = this.extend();
            return (
                (n.options = jl(this.options, e)),
                (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
                n
            );
        }
        extend(e = {}) {
            let n = new t({ ...this.config, ...e });
            return (
                (n.parent = this),
                (this.child = n),
                (n.name = e.name ? e.name : n.parent.name),
                e.defaultOptions &&
                    console.warn(
                        `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`,
                    ),
                (n.options = Se(ie(n, 'addOptions', { name: n.name }))),
                (n.storage = Se(ie(n, 'addStorage', { name: n.name, options: n.options }))),
                n
            );
        }
    };
function wn(t) {
    return new fp({
        find: t.find,
        handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
            let o = Se(t.getAttributes, void 0, r, i);
            if (o === !1 || o === null) return null;
            let { tr: s } = e,
                l = r[r.length - 1],
                u = r[0],
                d = n.to;
            if (l) {
                let f = u.search(/\S/),
                    h = n.from + u.indexOf(l),
                    m = h + l.length;
                if (
                    tc(n.from, n.to, e.doc)
                        .filter((y) => y.mark.type.excluded.find((x) => x === t.type && x !== y.mark.type))
                        .filter((y) => y.to > h).length
                )
                    return null;
                m < n.to && s.delete(m, n.to),
                    h > n.from && s.delete(n.from + f, h),
                    (d = n.from + f + l.length),
                    s.addMark(n.from + f, d, t.type.create(o || {})),
                    s.removeStoredMark(t.type);
            }
        },
    });
}
function UE(t) {
    return t.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
var cD = /^\s*>\s$/,
    WE = ae.create({
        name: 'blockquote',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        content: 'block+',
        group: 'block',
        defining: !0,
        parseHTML() {
            return [{ tag: 'blockquote' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['blockquote', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setBlockquote:
                    () =>
                    ({ commands: t }) =>
                        t.wrapIn(this.name),
                toggleBlockquote:
                    () =>
                    ({ commands: t }) =>
                        t.toggleWrap(this.name),
                unsetBlockquote:
                    () =>
                    ({ commands: t }) =>
                        t.lift(this.name),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-Shift-b': () => this.editor.commands.toggleBlockquote() };
        },
        addInputRules() {
            return [gi({ find: cD, type: this.type })];
        },
    });
var uD = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
    dD = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
    fD = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
    pD = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
    KE = tt.create({
        name: 'bold',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        parseHTML() {
            return [
                { tag: 'strong' },
                { tag: 'b', getAttrs: (t) => t.style.fontWeight !== 'normal' && null },
                { style: 'font-weight', getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null },
            ];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['strong', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setBold:
                    () =>
                    ({ commands: t }) =>
                        t.setMark(this.name),
                toggleBold:
                    () =>
                    ({ commands: t }) =>
                        t.toggleMark(this.name),
                unsetBold:
                    () =>
                    ({ commands: t }) =>
                        t.unsetMark(this.name),
            };
        },
        addKeyboardShortcuts() {
            return {
                'Mod-b': () => this.editor.commands.toggleBold(),
                'Mod-B': () => this.editor.commands.toggleBold(),
            };
        },
        addInputRules() {
            return [Un({ find: uD, type: this.type }), Un({ find: fD, type: this.type })];
        },
        addPasteRules() {
            return [wn({ find: dD, type: this.type }), wn({ find: pD, type: this.type })];
        },
    });
var hD = ae.create({
        name: 'listItem',
        addOptions() {
            return { HTMLAttributes: {}, bulletListTypeName: 'bulletList', orderedListTypeName: 'orderedList' };
        },
        content: 'paragraph block*',
        defining: !0,
        parseHTML() {
            return [{ tag: 'li' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['li', Z(this.options.HTMLAttributes, t), 0];
        },
        addKeyboardShortcuts() {
            return {
                Enter: () => this.editor.commands.splitListItem(this.name),
                Tab: () => this.editor.commands.sinkListItem(this.name),
                'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
            };
        },
    }),
    VE = tt.create({
        name: 'textStyle',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        parseHTML() {
            return [{ tag: 'span', getAttrs: (t) => (t.hasAttribute('style') ? {} : !1) }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['span', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                removeEmptyTextStyle:
                    () =>
                    ({ state: t, commands: e }) => {
                        let n = mi(t, this.type);
                        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
                    },
            };
        },
    }),
    GE = /^\s*([-+*])\s$/,
    qE = ae.create({
        name: 'bulletList',
        addOptions() {
            return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 };
        },
        group: 'block list',
        content() {
            return `${this.options.itemTypeName}+`;
        },
        parseHTML() {
            return [{ tag: 'ul' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['ul', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                toggleBulletList:
                    () =>
                    ({ commands: t, chain: e }) =>
                        this.options.keepAttributes
                            ? e()
                                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                                  .updateAttributes(hD.name, this.editor.getAttributes(VE.name))
                                  .run()
                            : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-Shift-8': () => this.editor.commands.toggleBulletList() };
        },
        addInputRules() {
            let t = gi({ find: GE, type: this.type });
            return (
                (this.options.keepMarks || this.options.keepAttributes) &&
                    (t = gi({
                        find: GE,
                        type: this.type,
                        keepMarks: this.options.keepMarks,
                        keepAttributes: this.options.keepAttributes,
                        getAttributes: () => this.editor.getAttributes(VE.name),
                        editor: this.editor,
                    })),
                [t]
            );
        },
    });
var mD = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/,
    gD = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g,
    YE = tt.create({
        name: 'code',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        excludes: '_',
        code: !0,
        exitable: !0,
        parseHTML() {
            return [{ tag: 'code' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['code', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setCode:
                    () =>
                    ({ commands: t }) =>
                        t.setMark(this.name),
                toggleCode:
                    () =>
                    ({ commands: t }) =>
                        t.toggleMark(this.name),
                unsetCode:
                    () =>
                    ({ commands: t }) =>
                        t.unsetMark(this.name),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-e': () => this.editor.commands.toggleCode() };
        },
        addInputRules() {
            return [Un({ find: mD, type: this.type })];
        },
        addPasteRules() {
            return [wn({ find: gD, type: this.type })];
        },
    });
var JE = tt.create({
    name: 'textStyle',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [{ tag: 'span', getAttrs: (t) => (t.hasAttribute('style') ? {} : !1) }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['span', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            removeEmptyTextStyle:
                () =>
                ({ state: t, commands: e }) => {
                    let n = mi(t, this.type);
                    return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
                },
        };
    },
});
var XE = Ge.create({
    name: 'color',
    addOptions() {
        return { types: ['textStyle'] };
    },
    addGlobalAttributes() {
        return [
            {
                types: this.options.types,
                attributes: {
                    color: {
                        default: null,
                        parseHTML: (t) => {
                            var e;
                            return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, '');
                        },
                        renderHTML: (t) => (t.color ? { style: `color: ${t.color}` } : {}),
                    },
                },
            },
        ];
    },
    addCommands() {
        return {
            setColor:
                (t) =>
                ({ chain: e }) =>
                    e().setMark('textStyle', { color: t }).run(),
            unsetColor:
                () =>
                ({ chain: t }) =>
                    t().setMark('textStyle', { color: null }).removeEmptyTextStyle().run(),
        };
    },
});
var ZE = ae.create({ name: 'doc', topNode: !0, content: 'block+' });
function jE(t = {}) {
    return new Oe({
        view(e) {
            return new _p(e, t);
        },
    });
}
var _p = class {
    constructor(e, n) {
        var r;
        (this.editorView = e),
            (this.cursorPos = null),
            (this.element = null),
            (this.timeout = -1),
            (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
            (this.color = n.color === !1 ? void 0 : n.color || 'black'),
            (this.class = n.class),
            (this.handlers = ['dragover', 'dragend', 'drop', 'dragleave'].map((i) => {
                let o = (s) => {
                    this[i](s);
                };
                return e.dom.addEventListener(i, o), { name: i, handler: o };
            }));
    }
    destroy() {
        this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
    }
    update(e, n) {
        this.cursorPos != null &&
            n.doc != e.state.doc &&
            (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
    }
    setCursor(e) {
        e != this.cursorPos &&
            ((this.cursorPos = e),
            e == null
                ? (this.element.parentNode.removeChild(this.element), (this.element = null))
                : this.updateOverlay());
    }
    updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos),
            n = !e.parent.inlineContent,
            r;
        if (n) {
            let l = e.nodeBefore,
                u = e.nodeAfter;
            if (l || u) {
                let d = this.editorView.nodeDOM(this.cursorPos - (l ? l.nodeSize : 0));
                if (d) {
                    let f = d.getBoundingClientRect(),
                        h = l ? f.bottom : f.top;
                    l && u && (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
                        (r = { left: f.left, right: f.right, top: h - this.width / 2, bottom: h + this.width / 2 });
                }
            }
        }
        if (!r) {
            let l = this.editorView.coordsAtPos(this.cursorPos);
            r = { left: l.left - this.width / 2, right: l.left + this.width / 2, top: l.top, bottom: l.bottom };
        }
        let i = this.editorView.dom.offsetParent;
        this.element ||
            ((this.element = i.appendChild(document.createElement('div'))),
            this.class && (this.element.className = this.class),
            (this.element.style.cssText = 'position: absolute; z-index: 50; pointer-events: none;'),
            this.color && (this.element.style.backgroundColor = this.color)),
            this.element.classList.toggle('prosemirror-dropcursor-block', n),
            this.element.classList.toggle('prosemirror-dropcursor-inline', !n);
        let o, s;
        if (!i || (i == document.body && getComputedStyle(i).position == 'static'))
            (o = -pageXOffset), (s = -pageYOffset);
        else {
            let l = i.getBoundingClientRect();
            (o = l.left - i.scrollLeft), (s = l.top - i.scrollTop);
        }
        (this.element.style.left = r.left - o + 'px'),
            (this.element.style.top = r.top - s + 'px'),
            (this.element.style.width = r.right - r.left + 'px'),
            (this.element.style.height = r.bottom - r.top + 'px');
    }
    scheduleRemoval(e) {
        clearTimeout(this.timeout), (this.timeout = setTimeout(() => this.setCursor(null), e));
    }
    dragover(e) {
        if (!this.editorView.editable) return;
        let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
            r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
            i = r && r.type.spec.disableDropCursor,
            o = typeof i == 'function' ? i(this.editorView, n, e) : i;
        if (n && !o) {
            let s = n.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                let l = Ml(this.editorView.state.doc, s, this.editorView.dragging.slice);
                l != null && (s = l);
            }
            this.setCursor(s), this.scheduleRemoval(5e3);
        }
    }
    dragend() {
        this.scheduleRemoval(20);
    }
    drop() {
        this.scheduleRemoval(20);
    }
    dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
    }
};
var QE = Ge.create({
    name: 'dropCursor',
    addOptions() {
        return { color: 'currentColor', width: 1, class: void 0 };
    },
    addProseMirrorPlugins() {
        return [jE(this.options)];
    },
});
var on = class t extends fe {
    constructor(e) {
        super(e, e);
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        return t.valid(r) ? new t(r) : fe.near(r);
    }
    content() {
        return X.empty;
    }
    eq(e) {
        return e instanceof t && e.head == this.head;
    }
    toJSON() {
        return { type: 'gapcursor', pos: this.head };
    }
    static fromJSON(e, n) {
        if (typeof n.pos != 'number') throw new RangeError('Invalid input for GapCursor.fromJSON');
        return new t(e.resolve(n.pos));
    }
    getBookmark() {
        return new Sp(this.anchor);
    }
    static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !bD(e) || !yD(e)) return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null) return r;
        let i = n.contentMatchAt(e.index()).defaultType;
        return i && i.isTextblock;
    }
    static findGapCursorFrom(e, n, r = !1) {
        e: for (;;) {
            if (!r && t.valid(e)) return e;
            let i = e.pos,
                o = null;
            for (let s = e.depth; ; s--) {
                let l = e.node(s);
                if (n > 0 ? e.indexAfter(s) < l.childCount : e.index(s) > 0) {
                    o = l.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
                    break;
                } else if (s == 0) return null;
                i += n;
                let u = e.doc.resolve(i);
                if (t.valid(u)) return u;
            }
            for (;;) {
                let s = n > 0 ? o.firstChild : o.lastChild;
                if (!s) {
                    if (o.isAtom && !o.isText && !pe.isSelectable(o)) {
                        (e = e.doc.resolve(i + o.nodeSize * n)), (r = !1);
                        continue e;
                    }
                    break;
                }
                (o = s), (i += n);
                let l = e.doc.resolve(i);
                if (t.valid(l)) return l;
            }
            return null;
        }
    }
};
on.prototype.visible = !1;
on.findFrom = on.findGapCursorFrom;
fe.jsonID('gapcursor', on);
var Sp = class t {
    constructor(e) {
        this.pos = e;
    }
    map(e) {
        return new t(e.map(this.pos));
    }
    resolve(e) {
        let n = e.resolve(this.pos);
        return on.valid(n) ? new on(n) : fe.near(n);
    }
};
function bD(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.index(e),
            r = t.node(e);
        if (n == 0) {
            if (r.type.spec.isolating) return !0;
            continue;
        }
        for (let i = r.child(n - 1); ; i = i.lastChild) {
            if ((i.childCount == 0 && !i.inlineContent) || i.isAtom || i.type.spec.isolating) return !0;
            if (i.inlineContent) return !1;
        }
    }
    return !0;
}
function yD(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.indexAfter(e),
            r = t.node(e);
        if (n == r.childCount) {
            if (r.type.spec.isolating) return !0;
            continue;
        }
        for (let i = r.child(n); ; i = i.firstChild) {
            if ((i.childCount == 0 && !i.inlineContent) || i.isAtom || i.type.spec.isolating) return !0;
            if (i.inlineContent) return !1;
        }
    }
    return !0;
}
function ev() {
    return new Oe({
        props: {
            decorations: xD,
            createSelectionBetween(t, e, n) {
                return e.pos == n.pos && on.valid(n) ? new on(n) : null;
            },
            handleClick: vD,
            handleKeyDown: ED,
            handleDOMEvents: { beforeinput: wD },
        },
    });
}
var ED = Qs({
    ArrowLeft: ic('horiz', -1),
    ArrowRight: ic('horiz', 1),
    ArrowUp: ic('vert', -1),
    ArrowDown: ic('vert', 1),
});
function ic(t, e) {
    let n = t == 'vert' ? (e > 0 ? 'down' : 'up') : e > 0 ? 'right' : 'left';
    return function (r, i, o) {
        let s = r.selection,
            l = e > 0 ? s.$to : s.$from,
            u = s.empty;
        if (s instanceof ce) {
            if (!o.endOfTextblock(n) || l.depth == 0) return !1;
            (u = !1), (l = r.doc.resolve(e > 0 ? l.after() : l.before()));
        }
        let d = on.findGapCursorFrom(l, e, u);
        return d ? (i && i(r.tr.setSelection(new on(d))), !0) : !1;
    };
}
function vD(t, e, n) {
    if (!t || !t.editable) return !1;
    let r = t.state.doc.resolve(e);
    if (!on.valid(r)) return !1;
    let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
    return i && i.inside > -1 && pe.isSelectable(t.state.doc.nodeAt(i.inside))
        ? !1
        : (t.dispatch(t.state.tr.setSelection(new on(r))), !0);
}
function wD(t, e) {
    if (e.inputType != 'insertCompositionText' || !(t.state.selection instanceof on)) return !1;
    let { $from: n } = t.state.selection,
        r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
    if (!r) return !1;
    let i = K.empty;
    for (let s = r.length - 1; s >= 0; s--) i = K.from(r[s].createAndFill(null, i));
    let o = t.state.tr.replace(n.pos, n.pos, new X(i, 0, 0));
    return o.setSelection(ce.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function xD(t) {
    if (!(t.selection instanceof on)) return null;
    let e = document.createElement('div');
    return (
        (e.className = 'ProseMirror-gapcursor'),
        lt.create(t.doc, [Mt.widget(t.selection.head, e, { key: 'gapcursor' })])
    );
}
var tv = Ge.create({
    name: 'gapCursor',
    addProseMirrorPlugins() {
        return [ev()];
    },
    extendNodeSchema(t) {
        var e;
        let n = { name: t.name, options: t.options, storage: t.storage };
        return { allowGapCursor: (e = Se(ie(t, 'allowGapCursor', n))) !== null && e !== void 0 ? e : null };
    },
});
var nv = ae.create({
    name: 'hardBreak',
    addOptions() {
        return { keepMarks: !0, HTMLAttributes: {} };
    },
    inline: !0,
    group: 'inline',
    selectable: !1,
    parseHTML() {
        return [{ tag: 'br' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['br', Z(this.options.HTMLAttributes, t)];
    },
    renderText() {
        return `
`;
    },
    addCommands() {
        return {
            setHardBreak:
                () =>
                ({ commands: t, chain: e, state: n, editor: r }) =>
                    t.first([
                        () => t.exitCode(),
                        () =>
                            t.command(() => {
                                let { selection: i, storedMarks: o } = n;
                                if (i.$from.parent.type.spec.isolating) return !1;
                                let { keepMarks: s } = this.options,
                                    { splittableMarks: l } = r.extensionManager,
                                    u = o || (i.$to.parentOffset && i.$from.marks());
                                return e()
                                    .insertContent({ type: this.name })
                                    .command(({ tr: d, dispatch: f }) => {
                                        if (f && u && s) {
                                            let h = u.filter((m) => l.includes(m.type.name));
                                            d.ensureMarks(h);
                                        }
                                        return !0;
                                    })
                                    .run();
                            }),
                    ]),
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Enter': () => this.editor.commands.setHardBreak(),
            'Shift-Enter': () => this.editor.commands.setHardBreak(),
        };
    },
});
var rv = ae.create({
    name: 'heading',
    addOptions() {
        return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
    },
    content: 'inline*',
    group: 'block',
    defining: !0,
    addAttributes() {
        return { level: { default: 1, rendered: !1 } };
    },
    parseHTML() {
        return this.options.levels.map((t) => ({ tag: `h${t}`, attrs: { level: t } }));
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
        return [
            `h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`,
            Z(this.options.HTMLAttributes, e),
            0,
        ];
    },
    addCommands() {
        return {
            setHeading:
                (t) =>
                ({ commands: e }) =>
                    this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
            toggleHeading:
                (t) =>
                ({ commands: e }) =>
                    this.options.levels.includes(t.level) ? e.toggleNode(this.name, 'paragraph', t) : !1,
        };
    },
    addKeyboardShortcuts() {
        return this.options.levels.reduce(
            (t, e) => ({ ...t, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }),
            {},
        );
    },
    addInputRules() {
        return this.options.levels.map((t) =>
            ta({ find: new RegExp(`^(#{1,${t}})\\s$`), type: this.type, getAttributes: { level: t } }),
        );
    },
});
var oc = 200,
    Jt = function () {};
Jt.prototype.append = function (e) {
    return e.length
        ? ((e = Jt.from(e)),
          (!this.length && e) ||
              (e.length < oc && this.leafAppend(e)) ||
              (this.length < oc && e.leafPrepend(this)) ||
              this.appendInner(e))
        : this;
};
Jt.prototype.prepend = function (e) {
    return e.length ? Jt.from(e).append(this) : this;
};
Jt.prototype.appendInner = function (e) {
    return new _D(this, e);
};
Jt.prototype.slice = function (e, n) {
    return (
        e === void 0 && (e = 0),
        n === void 0 && (n = this.length),
        e >= n ? Jt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
    );
};
Jt.prototype.get = function (e) {
    if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
Jt.prototype.forEach = function (e, n, r) {
    n === void 0 && (n = 0),
        r === void 0 && (r = this.length),
        n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
Jt.prototype.map = function (e, n, r) {
    n === void 0 && (n = 0), r === void 0 && (r = this.length);
    var i = [];
    return (
        this.forEach(
            function (o, s) {
                return i.push(e(o, s));
            },
            n,
            r,
        ),
        i
    );
};
Jt.from = function (e) {
    return e instanceof Jt ? e : e && e.length ? new iv(e) : Jt.empty;
};
var iv = (function (t) {
    function e(r) {
        t.call(this), (this.values = r);
    }
    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)), (e.prototype.constructor = e);
    var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
    return (
        (e.prototype.flatten = function () {
            return this.values;
        }),
        (e.prototype.sliceInner = function (i, o) {
            return i == 0 && o == this.length ? this : new e(this.values.slice(i, o));
        }),
        (e.prototype.getInner = function (i) {
            return this.values[i];
        }),
        (e.prototype.forEachInner = function (i, o, s, l) {
            for (var u = o; u < s; u++) if (i(this.values[u], l + u) === !1) return !1;
        }),
        (e.prototype.forEachInvertedInner = function (i, o, s, l) {
            for (var u = o - 1; u >= s; u--) if (i(this.values[u], l + u) === !1) return !1;
        }),
        (e.prototype.leafAppend = function (i) {
            if (this.length + i.length <= oc) return new e(this.values.concat(i.flatten()));
        }),
        (e.prototype.leafPrepend = function (i) {
            if (this.length + i.length <= oc) return new e(i.flatten().concat(this.values));
        }),
        (n.length.get = function () {
            return this.values.length;
        }),
        (n.depth.get = function () {
            return 0;
        }),
        Object.defineProperties(e.prototype, n),
        e
    );
})(Jt);
Jt.empty = new iv([]);
var _D = (function (t) {
        function e(n, r) {
            t.call(this),
                (this.left = n),
                (this.right = r),
                (this.length = n.length + r.length),
                (this.depth = Math.max(n.depth, r.depth) + 1);
        }
        return (
            t && (e.__proto__ = t),
            (e.prototype = Object.create(t && t.prototype)),
            (e.prototype.constructor = e),
            (e.prototype.flatten = function () {
                return this.left.flatten().concat(this.right.flatten());
            }),
            (e.prototype.getInner = function (r) {
                return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
            }),
            (e.prototype.forEachInner = function (r, i, o, s) {
                var l = this.left.length;
                if (
                    (i < l && this.left.forEachInner(r, i, Math.min(o, l), s) === !1) ||
                    (o > l &&
                        this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, o) - l, s + l) === !1)
                )
                    return !1;
            }),
            (e.prototype.forEachInvertedInner = function (r, i, o, s) {
                var l = this.left.length;
                if (
                    (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(o, l) - l, s + l) === !1) ||
                    (o < l && this.left.forEachInvertedInner(r, Math.min(i, l), o, s) === !1)
                )
                    return !1;
            }),
            (e.prototype.sliceInner = function (r, i) {
                if (r == 0 && i == this.length) return this;
                var o = this.left.length;
                return i <= o
                    ? this.left.slice(r, i)
                    : r >= o
                      ? this.right.slice(r - o, i - o)
                      : this.left.slice(r, o).append(this.right.slice(0, i - o));
            }),
            (e.prototype.leafAppend = function (r) {
                var i = this.right.leafAppend(r);
                if (i) return new e(this.left, i);
            }),
            (e.prototype.leafPrepend = function (r) {
                var i = this.left.leafPrepend(r);
                if (i) return new e(i, this.right);
            }),
            (e.prototype.appendInner = function (r) {
                return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
                    ? new e(this.left, new e(this.right, r))
                    : new e(this, r);
            }),
            e
        );
    })(Jt),
    Tp = Jt;
var SD = 500,
    no = class t {
        constructor(e, n) {
            (this.items = e), (this.eventCount = n);
        }
        popEvent(e, n) {
            if (this.eventCount == 0) return null;
            let r = this.items.length;
            for (; ; r--)
                if (this.items.get(r - 1).selection) {
                    --r;
                    break;
                }
            let i, o;
            n && ((i = this.remapping(r, this.items.length)), (o = i.maps.length));
            let s = e.tr,
                l,
                u,
                d = [],
                f = [];
            return (
                this.items.forEach(
                    (h, m) => {
                        if (!h.step) {
                            i || ((i = this.remapping(r, m + 1)), (o = i.maps.length)), o--, f.push(h);
                            return;
                        }
                        if (i) {
                            f.push(new mr(h.map));
                            let b = h.step.map(i.slice(o)),
                                y;
                            b &&
                                s.maybeStep(b).doc &&
                                ((y = s.mapping.maps[s.mapping.maps.length - 1]),
                                d.push(new mr(y, void 0, void 0, d.length + f.length))),
                                o--,
                                y && i.appendMap(y, o);
                        } else s.maybeStep(h.step);
                        if (h.selection)
                            return (
                                (l = i ? h.selection.map(i.slice(o)) : h.selection),
                                (u = new t(this.items.slice(0, r).append(f.reverse().concat(d)), this.eventCount - 1)),
                                !1
                            );
                    },
                    this.items.length,
                    0,
                ),
                { remaining: u, transform: s, selection: l }
            );
        }
        addTransform(e, n, r, i) {
            let o = [],
                s = this.eventCount,
                l = this.items,
                u = !i && l.length ? l.get(l.length - 1) : null;
            for (let f = 0; f < e.steps.length; f++) {
                let h = e.steps[f].invert(e.docs[f]),
                    m = new mr(e.mapping.maps[f], h, n),
                    b;
                (b = u && u.merge(m)) && ((m = b), f ? o.pop() : (l = l.slice(0, l.length - 1))),
                    o.push(m),
                    n && (s++, (n = void 0)),
                    i || (u = m);
            }
            let d = s - r.depth;
            return d > MD && ((l = TD(l, d)), (s -= d)), new t(l.append(o), s);
        }
        remapping(e, n) {
            let r = new Bs();
            return (
                this.items.forEach(
                    (i, o) => {
                        let s =
                            i.mirrorOffset != null && o - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
                        r.appendMap(i.map, s);
                    },
                    e,
                    n,
                ),
                r
            );
        }
        addMaps(e) {
            return this.eventCount == 0 ? this : new t(this.items.append(e.map((n) => new mr(n))), this.eventCount);
        }
        rebased(e, n) {
            if (!this.eventCount) return this;
            let r = [],
                i = Math.max(0, this.items.length - n),
                o = e.mapping,
                s = e.steps.length,
                l = this.eventCount;
            this.items.forEach((m) => {
                m.selection && l--;
            }, i);
            let u = n;
            this.items.forEach((m) => {
                let b = o.getMirror(--u);
                if (b == null) return;
                s = Math.min(s, b);
                let y = o.maps[b];
                if (m.step) {
                    let v = e.steps[b].invert(e.docs[b]),
                        x = m.selection && m.selection.map(o.slice(u + 1, b));
                    x && l++, r.push(new mr(y, v, x));
                } else r.push(new mr(y));
            }, i);
            let d = [];
            for (let m = n; m < s; m++) d.push(new mr(o.maps[m]));
            let f = this.items.slice(0, i).append(d).append(r),
                h = new t(f, l);
            return h.emptyItemCount() > SD && (h = h.compress(this.items.length - r.length)), h;
        }
        emptyItemCount() {
            let e = 0;
            return (
                this.items.forEach((n) => {
                    n.step || e++;
                }),
                e
            );
        }
        compress(e = this.items.length) {
            let n = this.remapping(0, e),
                r = n.maps.length,
                i = [],
                o = 0;
            return (
                this.items.forEach(
                    (s, l) => {
                        if (l >= e) i.push(s), s.selection && o++;
                        else if (s.step) {
                            let u = s.step.map(n.slice(r)),
                                d = u && u.getMap();
                            if ((r--, d && n.appendMap(d, r), u)) {
                                let f = s.selection && s.selection.map(n.slice(r));
                                f && o++;
                                let h = new mr(d.invert(), u, f),
                                    m,
                                    b = i.length - 1;
                                (m = i.length && i[b].merge(h)) ? (i[b] = m) : i.push(h);
                            }
                        } else s.map && r--;
                    },
                    this.items.length,
                    0,
                ),
                new t(Tp.from(i.reverse()), o)
            );
        }
    };
no.empty = new no(Tp.empty, 0);
function TD(t, e) {
    let n;
    return (
        t.forEach((r, i) => {
            if (r.selection && e-- == 0) return (n = i), !1;
        }),
        t.slice(n)
    );
}
var mr = class t {
        constructor(e, n, r, i) {
            (this.map = e), (this.step = n), (this.selection = r), (this.mirrorOffset = i);
        }
        merge(e) {
            if (this.step && e.step && !e.selection) {
                let n = e.step.merge(this.step);
                if (n) return new t(n.getMap().invert(), n, this.selection);
            }
        }
    },
    gr = class {
        constructor(e, n, r, i, o) {
            (this.done = e), (this.undone = n), (this.prevRanges = r), (this.prevTime = i), (this.prevComposition = o);
        }
    },
    MD = 20;
function AD(t, e, n, r) {
    let i = n.getMeta(to),
        o;
    if (i) return i.historyState;
    n.getMeta(ND) && (t = new gr(t.done, t.undone, null, 0, -1));
    let s = n.getMeta('appendedTransaction');
    if (n.steps.length == 0) return t;
    if (s && s.getMeta(to))
        return s.getMeta(to).redo
            ? new gr(
                  t.done.addTransform(n, void 0, r, sc(e)),
                  t.undone,
                  ov(n.mapping.maps[n.steps.length - 1]),
                  t.prevTime,
                  t.prevComposition,
              )
            : new gr(t.done, t.undone.addTransform(n, void 0, r, sc(e)), null, t.prevTime, t.prevComposition);
    if (n.getMeta('addToHistory') !== !1 && !(s && s.getMeta('addToHistory') === !1)) {
        let l = n.getMeta('composition'),
            u =
                t.prevTime == 0 ||
                (!s &&
                    t.prevComposition != l &&
                    (t.prevTime < (n.time || 0) - r.newGroupDelay || !CD(n, t.prevRanges))),
            d = s ? Mp(t.prevRanges, n.mapping) : ov(n.mapping.maps[n.steps.length - 1]);
        return new gr(
            t.done.addTransform(n, u ? e.selection.getBookmark() : void 0, r, sc(e)),
            no.empty,
            d,
            n.time,
            l ?? t.prevComposition,
        );
    } else
        return (o = n.getMeta('rebased'))
            ? new gr(
                  t.done.rebased(n, o),
                  t.undone.rebased(n, o),
                  Mp(t.prevRanges, n.mapping),
                  t.prevTime,
                  t.prevComposition,
              )
            : new gr(
                  t.done.addMaps(n.mapping.maps),
                  t.undone.addMaps(n.mapping.maps),
                  Mp(t.prevRanges, n.mapping),
                  t.prevTime,
                  t.prevComposition,
              );
}
function CD(t, e) {
    if (!e) return !1;
    if (!t.docChanged) return !0;
    let n = !1;
    return (
        t.mapping.maps[0].forEach((r, i) => {
            for (let o = 0; o < e.length; o += 2) r <= e[o + 1] && i >= e[o] && (n = !0);
        }),
        n
    );
}
function ov(t) {
    let e = [];
    return t.forEach((n, r, i, o) => e.push(i, o)), e;
}
function Mp(t, e) {
    if (!t) return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
        let i = e.map(t[r], 1),
            o = e.map(t[r + 1], -1);
        i <= o && n.push(i, o);
    }
    return n;
}
function kD(t, e, n) {
    let r = sc(e),
        i = to.get(e).spec.config,
        o = (n ? t.undone : t.done).popEvent(e, r);
    if (!o) return null;
    let s = o.selection.resolve(o.transform.doc),
        l = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), i, r),
        u = new gr(n ? l : o.remaining, n ? o.remaining : l, null, 0, -1);
    return o.transform.setSelection(s).setMeta(to, { redo: n, historyState: u });
}
var Ap = !1,
    sv = null;
function sc(t) {
    let e = t.plugins;
    if (sv != e) {
        (Ap = !1), (sv = e);
        for (let n = 0; n < e.length; n++)
            if (e[n].spec.historyPreserveItems) {
                Ap = !0;
                break;
            }
    }
    return Ap;
}
var to = new ze('history'),
    ND = new ze('closeHistory');
function av(t = {}) {
    return (
        (t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
        new Oe({
            key: to,
            state: {
                init() {
                    return new gr(no.empty, no.empty, null, 0, -1);
                },
                apply(e, n, r) {
                    return AD(n, r, e, t);
                },
            },
            config: t,
            props: {
                handleDOMEvents: {
                    beforeinput(e, n) {
                        let r = n.inputType,
                            i = r == 'historyUndo' ? Cp : r == 'historyRedo' ? kp : null;
                        return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
                    },
                },
            },
        })
    );
}
function ac(t, e) {
    return (n, r) => {
        let i = to.getState(n);
        if (!i || (t ? i.undone : i.done).eventCount == 0) return !1;
        if (r) {
            let o = kD(i, n, t);
            o && r(e ? o.scrollIntoView() : o);
        }
        return !0;
    };
}
var Cp = ac(!1, !0),
    kp = ac(!0, !0),
    _$ = ac(!1, !1),
    S$ = ac(!0, !1);
var lv = Ge.create({
    name: 'history',
    addOptions() {
        return { depth: 100, newGroupDelay: 500 };
    },
    addCommands() {
        return {
            undo:
                () =>
                ({ state: t, dispatch: e }) =>
                    Cp(t, e),
            redo:
                () =>
                ({ state: t, dispatch: e }) =>
                    kp(t, e),
        };
    },
    addProseMirrorPlugins() {
        return [av(this.options)];
    },
    addKeyboardShortcuts() {
        return {
            'Mod-z': () => this.editor.commands.undo(),
            'Shift-Mod-z': () => this.editor.commands.redo(),
            'Mod-y': () => this.editor.commands.redo(),
            'Mod-\u044F': () => this.editor.commands.undo(),
            'Shift-Mod-\u044F': () => this.editor.commands.redo(),
        };
    },
});
var cv = ae.create({
    name: 'horizontalRule',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    group: 'block',
    parseHTML() {
        return [{ tag: 'hr' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['hr', Z(this.options.HTMLAttributes, t)];
    },
    addCommands() {
        return {
            setHorizontalRule:
                () =>
                ({ chain: t, state: e }) => {
                    let { $to: n } = e.selection,
                        r = t();
                    return (
                        n.parentOffset === 0
                            ? r.insertContentAt(Math.max(n.pos - 2, 0), { type: this.name })
                            : r.insertContent({ type: this.name }),
                        r
                            .command(({ tr: i, dispatch: o }) => {
                                var s;
                                if (o) {
                                    let { $to: l } = i.selection,
                                        u = l.end();
                                    if (l.nodeAfter)
                                        l.nodeAfter.isTextblock
                                            ? i.setSelection(ce.create(i.doc, l.pos + 1))
                                            : l.nodeAfter.isBlock
                                              ? i.setSelection(pe.create(i.doc, l.pos))
                                              : i.setSelection(ce.create(i.doc, l.pos));
                                    else {
                                        let d =
                                            (s = l.parent.type.contentMatch.defaultType) === null || s === void 0
                                                ? void 0
                                                : s.create();
                                        d && (i.insert(u, d), i.setSelection(ce.create(i.doc, u + 1)));
                                    }
                                    i.scrollIntoView();
                                }
                                return !0;
                            })
                            .run()
                    );
                },
        };
    },
    addInputRules() {
        return [rc({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })];
    },
});
var OD = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
    RD = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
    ID = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
    LD = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
    uv = tt.create({
        name: 'italic',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        parseHTML() {
            return [
                { tag: 'em' },
                { tag: 'i', getAttrs: (t) => t.style.fontStyle !== 'normal' && null },
                { style: 'font-style=italic' },
            ];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['em', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setItalic:
                    () =>
                    ({ commands: t }) =>
                        t.setMark(this.name),
                toggleItalic:
                    () =>
                    ({ commands: t }) =>
                        t.toggleMark(this.name),
                unsetItalic:
                    () =>
                    ({ commands: t }) =>
                        t.unsetMark(this.name),
            };
        },
        addKeyboardShortcuts() {
            return {
                'Mod-i': () => this.editor.commands.toggleItalic(),
                'Mod-I': () => this.editor.commands.toggleItalic(),
            };
        },
        addInputRules() {
            return [Un({ find: OD, type: this.type }), Un({ find: ID, type: this.type })];
        },
        addPasteRules() {
            return [wn({ find: RD, type: this.type }), wn({ find: LD, type: this.type })];
        },
    });
var Np = ae.create({
    name: 'listItem',
    addOptions() {
        return { HTMLAttributes: {}, bulletListTypeName: 'bulletList', orderedListTypeName: 'orderedList' };
    },
    content: 'paragraph block*',
    defining: !0,
    parseHTML() {
        return [{ tag: 'li' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['li', Z(this.options.HTMLAttributes, t), 0];
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
        };
    },
});
var DD = ae.create({
        name: 'listItem',
        addOptions() {
            return { HTMLAttributes: {}, bulletListTypeName: 'bulletList', orderedListTypeName: 'orderedList' };
        },
        content: 'paragraph block*',
        defining: !0,
        parseHTML() {
            return [{ tag: 'li' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['li', Z(this.options.HTMLAttributes, t), 0];
        },
        addKeyboardShortcuts() {
            return {
                Enter: () => this.editor.commands.splitListItem(this.name),
                Tab: () => this.editor.commands.sinkListItem(this.name),
                'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
            };
        },
    }),
    dv = tt.create({
        name: 'textStyle',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        parseHTML() {
            return [{ tag: 'span', getAttrs: (t) => (t.hasAttribute('style') ? {} : !1) }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['span', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                removeEmptyTextStyle:
                    () =>
                    ({ state: t, commands: e }) => {
                        let n = mi(t, this.type);
                        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
                    },
            };
        },
    }),
    fv = /^(\d+)\.\s$/,
    pv = ae.create({
        name: 'orderedList',
        addOptions() {
            return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 };
        },
        group: 'block list',
        content() {
            return `${this.options.itemTypeName}+`;
        },
        addAttributes() {
            return {
                start: {
                    default: 1,
                    parseHTML: (t) => (t.hasAttribute('start') ? parseInt(t.getAttribute('start') || '', 10) : 1),
                },
            };
        },
        parseHTML() {
            return [{ tag: 'ol' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            let { start: e, ...n } = t;
            return e === 1
                ? ['ol', Z(this.options.HTMLAttributes, n), 0]
                : ['ol', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                toggleOrderedList:
                    () =>
                    ({ commands: t, chain: e }) =>
                        this.options.keepAttributes
                            ? e()
                                  .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
                                  .updateAttributes(DD.name, this.editor.getAttributes(dv.name))
                                  .run()
                            : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-Shift-7': () => this.editor.commands.toggleOrderedList() };
        },
        addInputRules() {
            let t = gi({
                find: fv,
                type: this.type,
                getAttributes: (e) => ({ start: +e[1] }),
                joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            });
            return (
                (this.options.keepMarks || this.options.keepAttributes) &&
                    (t = gi({
                        find: fv,
                        type: this.type,
                        keepMarks: this.options.keepMarks,
                        keepAttributes: this.options.keepAttributes,
                        getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(dv.name) }),
                        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
                        editor: this.editor,
                    })),
                [t]
            );
        },
    });
var lc = ae.create({
    name: 'paragraph',
    priority: 1e3,
    addOptions() {
        return { HTMLAttributes: {} };
    },
    group: 'block',
    content: 'inline*',
    parseHTML() {
        return [{ tag: 'p' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['p', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setParagraph:
                () =>
                ({ commands: t }) =>
                    t.setNode(this.name),
        };
    },
    addKeyboardShortcuts() {
        return { 'Mod-Alt-0': () => this.editor.commands.setParagraph() };
    },
});
var hv = Ge.create({
    name: 'placeholder',
    addOptions() {
        return {
            emptyEditorClass: 'is-editor-empty',
            emptyNodeClass: 'is-empty',
            placeholder: 'Write something \u2026',
            showOnlyWhenEditable: !0,
            considerAnyAsEmpty: !1,
            showOnlyCurrent: !0,
            includeChildren: !1,
        };
    },
    addProseMirrorPlugins() {
        return [
            new Oe({
                key: new ze('placeholder'),
                props: {
                    decorations: ({ doc: t, selection: e }) => {
                        var n;
                        let r = this.editor.isEditable || !this.options.showOnlyWhenEditable,
                            { anchor: i } = e,
                            o = [];
                        if (!r) return null;
                        let { firstChild: s } = t.content,
                            l = s && s.type.isLeaf,
                            u = s && s.isAtom,
                            d = this.options.considerAnyAsEmpty
                                ? !0
                                : s &&
                                  s.type.name ===
                                      ((n = t.type.contentMatch.defaultType) === null || n === void 0
                                          ? void 0
                                          : n.name),
                            f = t.content.childCount <= 1 && s && d && s.nodeSize <= 2 && (!l || !u);
                        return (
                            t.descendants((h, m) => {
                                let b = i >= m && i <= m + h.nodeSize,
                                    y = !h.isLeaf && !h.childCount;
                                if ((b || !this.options.showOnlyCurrent) && y) {
                                    let v = [this.options.emptyNodeClass];
                                    f && v.push(this.options.emptyEditorClass);
                                    let x = Mt.node(m, m + h.nodeSize, {
                                        class: v.join(' '),
                                        'data-placeholder':
                                            typeof this.options.placeholder == 'function'
                                                ? this.options.placeholder({
                                                      editor: this.editor,
                                                      node: h,
                                                      pos: m,
                                                      hasAnchor: b,
                                                  })
                                                : this.options.placeholder,
                                    });
                                    o.push(x);
                                }
                                return this.options.includeChildren;
                            }),
                            lt.create(t, o)
                        );
                    },
                },
            }),
        ];
    },
});
var PD = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
    BD = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
    mv = tt.create({
        name: 'strike',
        addOptions() {
            return { HTMLAttributes: {} };
        },
        parseHTML() {
            return [
                { tag: 's' },
                { tag: 'del' },
                { tag: 'strike' },
                { style: 'text-decoration', consuming: !1, getAttrs: (t) => (t.includes('line-through') ? {} : !1) },
            ];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['s', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setStrike:
                    () =>
                    ({ commands: t }) =>
                        t.setMark(this.name),
                toggleStrike:
                    () =>
                    ({ commands: t }) =>
                        t.toggleMark(this.name),
                unsetStrike:
                    () =>
                    ({ commands: t }) =>
                        t.unsetMark(this.name),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-Shift-s': () => this.editor.commands.toggleStrike() };
        },
        addInputRules() {
            return [Un({ find: PD, type: this.type })];
        },
        addPasteRules() {
            return [wn({ find: BD, type: this.type })];
        },
    });
var gv = tt.create({
    name: 'subscript',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [
            { tag: 'sub' },
            {
                style: 'vertical-align',
                getAttrs(t) {
                    return t !== 'sub' ? !1 : null;
                },
            },
        ];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['sub', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setSubscript:
                () =>
                ({ commands: t }) =>
                    t.setMark(this.name),
            toggleSubscript:
                () =>
                ({ commands: t }) =>
                    t.toggleMark(this.name),
            unsetSubscript:
                () =>
                ({ commands: t }) =>
                    t.unsetMark(this.name),
        };
    },
    addKeyboardShortcuts() {
        return { 'Mod-,': () => this.editor.commands.toggleSubscript() };
    },
});
var bv = tt.create({
    name: 'superscript',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [
            { tag: 'sup' },
            {
                style: 'vertical-align',
                getAttrs(t) {
                    return t !== 'super' ? !1 : null;
                },
            },
        ];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['sup', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setSuperscript:
                () =>
                ({ commands: t }) =>
                    t.setMark(this.name),
            toggleSuperscript:
                () =>
                ({ commands: t }) =>
                    t.toggleMark(this.name),
            unsetSuperscript:
                () =>
                ({ commands: t }) =>
                    t.unsetMark(this.name),
        };
    },
    addKeyboardShortcuts() {
        return { 'Mod-.': () => this.editor.commands.toggleSuperscript() };
    },
});
var Rp, Ip;
if (typeof WeakMap < 'u') {
    let t = new WeakMap();
    (Rp = (e) => t.get(e)), (Ip = (e, n) => (t.set(e, n), n));
} else {
    let t = [],
        n = 0;
    (Rp = (r) => {
        for (let i = 0; i < t.length; i += 2) if (t[i] == r) return t[i + 1];
    }),
        (Ip = (r, i) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = i)));
}
var bt = class {
    constructor(t, e, n, r) {
        (this.width = t), (this.height = e), (this.map = n), (this.problems = r);
    }
    findCell(t) {
        for (let e = 0; e < this.map.length; e++) {
            let n = this.map[e];
            if (n != t) continue;
            let r = e % this.width,
                i = (e / this.width) | 0,
                o = r + 1,
                s = i + 1;
            for (let l = 1; o < this.width && this.map[e + l] == n; l++) o++;
            for (let l = 1; s < this.height && this.map[e + this.width * l] == n; l++) s++;
            return { left: r, top: i, right: o, bottom: s };
        }
        throw new RangeError(`No cell with offset ${t} found`);
    }
    colCount(t) {
        for (let e = 0; e < this.map.length; e++) if (this.map[e] == t) return e % this.width;
        throw new RangeError(`No cell with offset ${t} found`);
    }
    nextCell(t, e, n) {
        let { left: r, right: i, top: o, bottom: s } = this.findCell(t);
        return e == 'horiz'
            ? (n < 0 ? r == 0 : i == this.width)
                ? null
                : this.map[o * this.width + (n < 0 ? r - 1 : i)]
            : (n < 0 ? o == 0 : s == this.height)
              ? null
              : this.map[r + this.width * (n < 0 ? o - 1 : s)];
    }
    rectBetween(t, e) {
        let { left: n, right: r, top: i, bottom: o } = this.findCell(t),
            { left: s, right: l, top: u, bottom: d } = this.findCell(e);
        return { left: Math.min(n, s), top: Math.min(i, u), right: Math.max(r, l), bottom: Math.max(o, d) };
    }
    cellsInRect(t) {
        let e = [],
            n = {};
        for (let r = t.top; r < t.bottom; r++)
            for (let i = t.left; i < t.right; i++) {
                let o = r * this.width + i,
                    s = this.map[o];
                n[s] ||
                    ((n[s] = !0),
                    !(
                        (i == t.left && i && this.map[o - 1] == s) ||
                        (r == t.top && r && this.map[o - this.width] == s)
                    ) && e.push(s));
            }
        return e;
    }
    positionAt(t, e, n) {
        for (let r = 0, i = 0; ; r++) {
            let o = i + n.child(r).nodeSize;
            if (r == t) {
                let s = e + t * this.width,
                    l = (t + 1) * this.width;
                for (; s < l && this.map[s] < i; ) s++;
                return s == l ? o - 1 : this.map[s];
            }
            i = o;
        }
    }
    static get(t) {
        return Rp(t) || Ip(t, FD(t));
    }
};
function FD(t) {
    if (t.type.spec.tableRole != 'table') throw new RangeError('Not a table node: ' + t.type.name);
    let e = HD(t),
        n = t.childCount,
        r = [],
        i = 0,
        o = null,
        s = [];
    for (let d = 0, f = e * n; d < f; d++) r[d] = 0;
    for (let d = 0, f = 0; d < n; d++) {
        let h = t.child(d);
        f++;
        for (let y = 0; ; y++) {
            for (; i < r.length && r[i] != 0; ) i++;
            if (y == h.childCount) break;
            let v = h.child(y),
                { colspan: x, rowspan: T, colwidth: D } = v.attrs;
            for (let I = 0; I < T; I++) {
                if (I + d >= n) {
                    (o || (o = [])).push({ type: 'overlong_rowspan', pos: f, n: T - I });
                    break;
                }
                let S = i + I * e;
                for (let z = 0; z < x; z++) {
                    r[S + z] == 0
                        ? (r[S + z] = f)
                        : (o || (o = [])).push({ type: 'collision', row: d, pos: f, n: x - z });
                    let N = D && D[z];
                    if (N) {
                        let q = ((S + z) % e) * 2,
                            ne = s[q];
                        ne == null || (ne != N && s[q + 1] == 1) ? ((s[q] = N), (s[q + 1] = 1)) : ne == N && s[q + 1]++;
                    }
                }
            }
            (i += x), (f += v.nodeSize);
        }
        let m = (d + 1) * e,
            b = 0;
        for (; i < m; ) r[i++] == 0 && b++;
        b && (o || (o = [])).push({ type: 'missing', row: d, n: b }), f++;
    }
    let l = new bt(e, n, r, o),
        u = !1;
    for (let d = 0; !u && d < s.length; d += 2) s[d] != null && s[d + 1] < n && (u = !0);
    return u && zD(l, s, t), l;
}
function HD(t) {
    let e = -1,
        n = !1;
    for (let r = 0; r < t.childCount; r++) {
        let i = t.child(r),
            o = 0;
        if (n)
            for (let s = 0; s < r; s++) {
                let l = t.child(s);
                for (let u = 0; u < l.childCount; u++) {
                    let d = l.child(u);
                    s + d.attrs.rowspan > r && (o += d.attrs.colspan);
                }
            }
        for (let s = 0; s < i.childCount; s++) {
            let l = i.child(s);
            (o += l.attrs.colspan), l.attrs.rowspan > 1 && (n = !0);
        }
        e == -1 ? (e = o) : e != o && (e = Math.max(e, o));
    }
    return e;
}
function zD(t, e, n) {
    t.problems || (t.problems = []);
    let r = {};
    for (let i = 0; i < t.map.length; i++) {
        let o = t.map[i];
        if (r[o]) continue;
        r[o] = !0;
        let s = n.nodeAt(o);
        if (!s) throw new RangeError(`No cell with offset ${o} found`);
        let l = null,
            u = s.attrs;
        for (let d = 0; d < u.colspan; d++) {
            let f = (i + d) % t.width,
                h = e[f * 2];
            h != null && (!u.colwidth || u.colwidth[d] != h) && ((l || (l = $D(u)))[d] = h);
        }
        l && t.problems.unshift({ type: 'colwidth mismatch', pos: o, colwidth: l });
    }
}
function $D(t) {
    if (t.colwidth) return t.colwidth.slice();
    let e = [];
    for (let n = 0; n < t.colspan; n++) e.push(0);
    return e;
}
function sn(t) {
    let e = t.cached.tableNodeTypes;
    if (!e) {
        e = t.cached.tableNodeTypes = {};
        for (let n in t.nodes) {
            let r = t.nodes[n],
                i = r.spec.tableRole;
            i && (e[i] = r);
        }
    }
    return e;
}
var bi = new ze('selectingCells');
function qo(t) {
    for (let e = t.depth - 1; e > 0; e--)
        if (t.node(e).type.spec.tableRole == 'row') return t.node(0).resolve(t.before(e + 1));
    return null;
}
function UD(t) {
    for (let e = t.depth; e > 0; e--) {
        let n = t.node(e).type.spec.tableRole;
        if (n === 'cell' || n === 'header_cell') return t.node(e);
    }
    return null;
}
function ir(t) {
    let e = t.selection.$head;
    for (let n = e.depth; n > 0; n--) if (e.node(n).type.spec.tableRole == 'row') return !0;
    return !1;
}
function hc(t) {
    let e = t.selection;
    if ('$anchorCell' in e && e.$anchorCell) return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
    if ('node' in e && e.node && e.node.type.spec.tableRole == 'cell') return e.$anchor;
    let n = qo(e.$head) || WD(e.$head);
    if (n) return n;
    throw new RangeError(`No cell found around position ${e.head}`);
}
function WD(t) {
    for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
        let r = e.type.spec.tableRole;
        if (r == 'cell' || r == 'header_cell') return t.doc.resolve(n);
    }
    for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
        let r = e.type.spec.tableRole;
        if (r == 'cell' || r == 'header_cell') return t.doc.resolve(n - e.nodeSize);
    }
}
function Lp(t) {
    return t.parent.type.spec.tableRole == 'row' && !!t.nodeAfter;
}
function KD(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Bp(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function Mv(t, e, n) {
    let r = t.node(-1),
        i = bt.get(r),
        o = t.start(-1),
        s = i.nextCell(t.pos - o, e, n);
    return s == null ? null : t.node(0).resolve(o + s);
}
function ro(t, e, n = 1) {
    let r = { ...t, colspan: t.colspan - n };
    return (
        r.colwidth &&
            ((r.colwidth = r.colwidth.slice()),
            r.colwidth.splice(e, n),
            r.colwidth.some((i) => i > 0) || (r.colwidth = null)),
        r
    );
}
function Av(t, e, n = 1) {
    let r = { ...t, colspan: t.colspan + n };
    if (r.colwidth) {
        r.colwidth = r.colwidth.slice();
        for (let i = 0; i < n; i++) r.colwidth.splice(e, 0, 0);
    }
    return r;
}
function VD(t, e, n) {
    let r = sn(e.type.schema).header_cell;
    for (let i = 0; i < t.height; i++) if (e.nodeAt(t.map[n + i * t.width]).type != r) return !1;
    return !0;
}
var rt = class $r extends fe {
    constructor(e, n = e) {
        let r = e.node(-1),
            i = bt.get(r),
            o = e.start(-1),
            s = i.rectBetween(e.pos - o, n.pos - o),
            l = e.node(0),
            u = i.cellsInRect(s).filter((f) => f != n.pos - o);
        u.unshift(n.pos - o);
        let d = u.map((f) => {
            let h = r.nodeAt(f);
            if (!h) throw RangeError(`No cell with offset ${f} found`);
            let m = o + f + 1;
            return new Ws(l.resolve(m), l.resolve(m + h.content.size));
        });
        super(d[0].$from, d[0].$to, d), (this.$anchorCell = e), (this.$headCell = n);
    }
    map(e, n) {
        let r = e.resolve(n.map(this.$anchorCell.pos)),
            i = e.resolve(n.map(this.$headCell.pos));
        if (Lp(r) && Lp(i) && Bp(r, i)) {
            let o = this.$anchorCell.node(-1) != r.node(-1);
            return o && this.isRowSelection()
                ? $r.rowSelection(r, i)
                : o && this.isColSelection()
                  ? $r.colSelection(r, i)
                  : new $r(r, i);
        }
        return ce.between(r, i);
    }
    content() {
        let e = this.$anchorCell.node(-1),
            n = bt.get(e),
            r = this.$anchorCell.start(-1),
            i = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
            o = {},
            s = [];
        for (let u = i.top; u < i.bottom; u++) {
            let d = [];
            for (let f = u * n.width + i.left, h = i.left; h < i.right; h++, f++) {
                let m = n.map[f];
                if (o[m]) continue;
                o[m] = !0;
                let b = n.findCell(m),
                    y = e.nodeAt(m);
                if (!y) throw RangeError(`No cell with offset ${m} found`);
                let v = i.left - b.left,
                    x = b.right - i.right;
                if (v > 0 || x > 0) {
                    let T = y.attrs;
                    if ((v > 0 && (T = ro(T, 0, v)), x > 0 && (T = ro(T, T.colspan - x, x)), b.left < i.left)) {
                        if (((y = y.type.createAndFill(T)), !y))
                            throw RangeError(`Could not create cell with attrs ${JSON.stringify(T)}`);
                    } else y = y.type.create(T, y.content);
                }
                if (b.top < i.top || b.bottom > i.bottom) {
                    let T = { ...y.attrs, rowspan: Math.min(b.bottom, i.bottom) - Math.max(b.top, i.top) };
                    b.top < i.top ? (y = y.type.createAndFill(T)) : (y = y.type.create(T, y.content));
                }
                d.push(y);
            }
            s.push(e.child(u).copy(K.from(d)));
        }
        let l = this.isColSelection() && this.isRowSelection() ? e : s;
        return new X(K.from(l), 1, 1);
    }
    replace(e, n = X.empty) {
        let r = e.steps.length,
            i = this.ranges;
        for (let s = 0; s < i.length; s++) {
            let { $from: l, $to: u } = i[s],
                d = e.mapping.slice(r);
            e.replace(d.map(l.pos), d.map(u.pos), s ? X.empty : n);
        }
        let o = fe.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
        o && e.setSelection(o);
    }
    replaceWith(e, n) {
        this.replace(e, new X(K.from(n), 0, 0));
    }
    forEachCell(e) {
        let n = this.$anchorCell.node(-1),
            r = bt.get(n),
            i = this.$anchorCell.start(-1),
            o = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i));
        for (let s = 0; s < o.length; s++) e(n.nodeAt(o[s]), i + o[s]);
    }
    isColSelection() {
        let e = this.$anchorCell.index(-1),
            n = this.$headCell.index(-1);
        if (Math.min(e, n) > 0) return !1;
        let r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
            i = n + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(r, i) == this.$headCell.node(-1).childCount;
    }
    static colSelection(e, n = e) {
        let r = e.node(-1),
            i = bt.get(r),
            o = e.start(-1),
            s = i.findCell(e.pos - o),
            l = i.findCell(n.pos - o),
            u = e.node(0);
        return (
            s.top <= l.top
                ? (s.top > 0 && (e = u.resolve(o + i.map[s.left])),
                  l.bottom < i.height && (n = u.resolve(o + i.map[i.width * (i.height - 1) + l.right - 1])))
                : (l.top > 0 && (n = u.resolve(o + i.map[l.left])),
                  s.bottom < i.height && (e = u.resolve(o + i.map[i.width * (i.height - 1) + s.right - 1]))),
            new $r(e, n)
        );
    }
    isRowSelection() {
        let e = this.$anchorCell.node(-1),
            n = bt.get(e),
            r = this.$anchorCell.start(-1),
            i = n.colCount(this.$anchorCell.pos - r),
            o = n.colCount(this.$headCell.pos - r);
        if (Math.min(i, o) > 0) return !1;
        let s = i + this.$anchorCell.nodeAfter.attrs.colspan,
            l = o + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(s, l) == n.width;
    }
    eq(e) {
        return e instanceof $r && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
    }
    static rowSelection(e, n = e) {
        let r = e.node(-1),
            i = bt.get(r),
            o = e.start(-1),
            s = i.findCell(e.pos - o),
            l = i.findCell(n.pos - o),
            u = e.node(0);
        return (
            s.left <= l.left
                ? (s.left > 0 && (e = u.resolve(o + i.map[s.top * i.width])),
                  l.right < i.width && (n = u.resolve(o + i.map[i.width * (l.top + 1) - 1])))
                : (l.left > 0 && (n = u.resolve(o + i.map[l.top * i.width])),
                  s.right < i.width && (e = u.resolve(o + i.map[i.width * (s.top + 1) - 1]))),
            new $r(e, n)
        );
    }
    toJSON() {
        return { type: 'cell', anchor: this.$anchorCell.pos, head: this.$headCell.pos };
    }
    static fromJSON(e, n) {
        return new $r(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r = n) {
        return new $r(e.resolve(n), e.resolve(r));
    }
    getBookmark() {
        return new GD(this.$anchorCell.pos, this.$headCell.pos);
    }
};
rt.prototype.visible = !1;
fe.jsonID('cell', rt);
var GD = class Cv {
    constructor(e, n) {
        (this.anchor = e), (this.head = n);
    }
    map(e) {
        return new Cv(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
        let n = e.resolve(this.anchor),
            r = e.resolve(this.head);
        return n.parent.type.spec.tableRole == 'row' &&
            r.parent.type.spec.tableRole == 'row' &&
            n.index() < n.parent.childCount &&
            r.index() < r.parent.childCount &&
            Bp(n, r)
            ? new rt(n, r)
            : fe.near(r, 1);
    }
};
function qD(t) {
    if (!(t.selection instanceof rt)) return null;
    let e = [];
    return (
        t.selection.forEachCell((n, r) => {
            e.push(Mt.node(r, r + n.nodeSize, { class: 'selectedCell' }));
        }),
        lt.create(t.doc, e)
    );
}
function YD({ $from: t, $to: e }) {
    if (t.pos == e.pos || t.pos < t.pos - 6) return !1;
    let n = t.pos,
        r = e.pos,
        i = t.depth;
    for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++);
    for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--);
    return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function JD({ $from: t, $to: e }) {
    let n, r;
    for (let i = t.depth; i > 0; i--) {
        let o = t.node(i);
        if (o.type.spec.tableRole === 'cell' || o.type.spec.tableRole === 'header_cell') {
            n = o;
            break;
        }
    }
    for (let i = e.depth; i > 0; i--) {
        let o = e.node(i);
        if (o.type.spec.tableRole === 'cell' || o.type.spec.tableRole === 'header_cell') {
            r = o;
            break;
        }
    }
    return n !== r && e.parentOffset === 0;
}
function XD(t, e, n) {
    let r = (e || t).selection,
        i = (e || t).doc,
        o,
        s;
    if (r instanceof pe && (s = r.node.type.spec.tableRole)) {
        if (s == 'cell' || s == 'header_cell') o = rt.create(i, r.from);
        else if (s == 'row') {
            let l = i.resolve(r.from + 1);
            o = rt.rowSelection(l, l);
        } else if (!n) {
            let l = bt.get(r.node),
                u = r.from + 1,
                d = u + l.map[l.width * l.height - 1];
            o = rt.create(i, u + 1, d);
        }
    } else
        r instanceof ce && YD(r)
            ? (o = ce.create(i, r.from))
            : r instanceof ce && JD(r) && (o = ce.create(i, r.$from.start(), r.$from.end()));
    return o && (e || (e = t.tr)).setSelection(o), e;
}
var ZD = new ze('fix-tables');
function kv(t, e, n, r) {
    let i = t.childCount,
        o = e.childCount;
    e: for (let s = 0, l = 0; s < o; s++) {
        let u = e.child(s);
        for (let d = l, f = Math.min(i, s + 3); d < f; d++)
            if (t.child(d) == u) {
                (l = d + 1), (n += u.nodeSize);
                continue e;
            }
        r(u, n),
            l < i && t.child(l).sameMarkup(u)
                ? kv(t.child(l), u, n + 1, r)
                : u.nodesBetween(0, u.content.size, r, n + 1),
            (n += u.nodeSize);
    }
}
function Fp(t, e) {
    let n,
        r = (i, o) => {
            i.type.spec.tableRole == 'table' && (n = jD(t, i, o, n));
        };
    return e ? e.doc != t.doc && kv(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function jD(t, e, n, r) {
    let i = bt.get(e);
    if (!i.problems) return r;
    r || (r = t.tr);
    let o = [];
    for (let u = 0; u < i.height; u++) o.push(0);
    for (let u = 0; u < i.problems.length; u++) {
        let d = i.problems[u];
        if (d.type == 'collision') {
            let f = e.nodeAt(d.pos);
            if (!f) continue;
            let h = f.attrs;
            for (let m = 0; m < h.rowspan; m++) o[d.row + m] += d.n;
            r.setNodeMarkup(r.mapping.map(n + 1 + d.pos), null, ro(h, h.colspan - d.n, d.n));
        } else if (d.type == 'missing') o[d.row] += d.n;
        else if (d.type == 'overlong_rowspan') {
            let f = e.nodeAt(d.pos);
            if (!f) continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + d.pos), null, { ...f.attrs, rowspan: f.attrs.rowspan - d.n });
        } else if (d.type == 'colwidth mismatch') {
            let f = e.nodeAt(d.pos);
            if (!f) continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + d.pos), null, { ...f.attrs, colwidth: d.colwidth });
        }
    }
    let s, l;
    for (let u = 0; u < o.length; u++) o[u] && (s == null && (s = u), (l = u));
    for (let u = 0, d = n + 1; u < i.height; u++) {
        let f = e.child(u),
            h = d + f.nodeSize,
            m = o[u];
        if (m > 0) {
            let b = 'cell';
            f.firstChild && (b = f.firstChild.type.spec.tableRole);
            let y = [];
            for (let x = 0; x < m; x++) {
                let T = sn(t.schema)[b].createAndFill();
                T && y.push(T);
            }
            let v = (u == 0 || s == u - 1) && l == u ? d + 1 : h - 1;
            r.insert(r.mapping.map(v), y);
        }
        d = h;
    }
    return r.setMeta(ZD, { fixTables: !0 });
}
function QD(t) {
    if (!t.size) return null;
    let { content: e, openStart: n, openEnd: r } = t;
    for (; e.childCount == 1 && ((n > 0 && r > 0) || e.child(0).type.spec.tableRole == 'table'); )
        n--, r--, (e = e.child(0).content);
    let i = e.child(0),
        o = i.type.spec.tableRole,
        s = i.type.schema,
        l = [];
    if (o == 'row')
        for (let u = 0; u < e.childCount; u++) {
            let d = e.child(u).content,
                f = u ? 0 : Math.max(0, n - 1),
                h = u < e.childCount - 1 ? 0 : Math.max(0, r - 1);
            (f || h) && (d = Dp(sn(s).row, new X(d, f, h)).content), l.push(d);
        }
    else if (o == 'cell' || o == 'header_cell') l.push(n || r ? Dp(sn(s).row, new X(e, n, r)).content : e);
    else return null;
    return eP(s, l);
}
function eP(t, e) {
    let n = [];
    for (let i = 0; i < e.length; i++) {
        let o = e[i];
        for (let s = o.childCount - 1; s >= 0; s--) {
            let { rowspan: l, colspan: u } = o.child(s).attrs;
            for (let d = i; d < i + l; d++) n[d] = (n[d] || 0) + u;
        }
    }
    let r = 0;
    for (let i = 0; i < n.length; i++) r = Math.max(r, n[i]);
    for (let i = 0; i < n.length; i++)
        if ((i >= e.length && e.push(K.empty), n[i] < r)) {
            let o = sn(t).cell.createAndFill(),
                s = [];
            for (let l = n[i]; l < r; l++) s.push(o);
            e[i] = e[i].append(K.from(s));
        }
    return { height: e.length, width: r, rows: e };
}
function Dp(t, e) {
    let n = t.createAndFill();
    return new si(n).replace(0, n.content.size, e).doc;
}
function tP({ width: t, height: e, rows: n }, r, i) {
    if (t != r) {
        let o = [],
            s = [];
        for (let l = 0; l < n.length; l++) {
            let u = n[l],
                d = [];
            for (let f = o[l] || 0, h = 0; f < r; h++) {
                let m = u.child(h % u.childCount);
                f + m.attrs.colspan > r &&
                    (m = m.type.createChecked(ro(m.attrs, m.attrs.colspan, f + m.attrs.colspan - r), m.content)),
                    d.push(m),
                    (f += m.attrs.colspan);
                for (let b = 1; b < m.attrs.rowspan; b++) o[l + b] = (o[l + b] || 0) + m.attrs.colspan;
            }
            s.push(K.from(d));
        }
        (n = s), (t = r);
    }
    if (e != i) {
        let o = [];
        for (let s = 0, l = 0; s < i; s++, l++) {
            let u = [],
                d = n[l % e];
            for (let f = 0; f < d.childCount; f++) {
                let h = d.child(f);
                s + h.attrs.rowspan > i &&
                    (h = h.type.create({ ...h.attrs, rowspan: Math.max(1, i - h.attrs.rowspan) }, h.content)),
                    u.push(h);
            }
            o.push(K.from(u));
        }
        (n = o), (e = i);
    }
    return { width: t, height: e, rows: n };
}
function nP(t, e, n, r, i, o, s) {
    let l = t.doc.type.schema,
        u = sn(l),
        d,
        f;
    if (i > e.width)
        for (let h = 0, m = 0; h < e.height; h++) {
            let b = n.child(h);
            m += b.nodeSize;
            let y = [],
                v;
            b.lastChild == null || b.lastChild.type == u.cell
                ? (v = d || (d = u.cell.createAndFill()))
                : (v = f || (f = u.header_cell.createAndFill()));
            for (let x = e.width; x < i; x++) y.push(v);
            t.insert(t.mapping.slice(s).map(m - 1 + r), y);
        }
    if (o > e.height) {
        let h = [];
        for (let y = 0, v = (e.height - 1) * e.width; y < Math.max(e.width, i); y++) {
            let x = y >= e.width ? !1 : n.nodeAt(e.map[v + y]).type == u.header_cell;
            h.push(x ? f || (f = u.header_cell.createAndFill()) : d || (d = u.cell.createAndFill()));
        }
        let m = u.row.create(null, K.from(h)),
            b = [];
        for (let y = e.height; y < o; y++) b.push(m);
        t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), b);
    }
    return !!(d || f);
}
function yv(t, e, n, r, i, o, s, l) {
    if (s == 0 || s == e.height) return !1;
    let u = !1;
    for (let d = i; d < o; d++) {
        let f = s * e.width + d,
            h = e.map[f];
        if (e.map[f - e.width] == h) {
            u = !0;
            let m = n.nodeAt(h),
                { top: b, left: y } = e.findCell(h);
            t.setNodeMarkup(t.mapping.slice(l).map(h + r), null, { ...m.attrs, rowspan: s - b }),
                t.insert(
                    t.mapping.slice(l).map(e.positionAt(s, y, n)),
                    m.type.createAndFill({ ...m.attrs, rowspan: b + m.attrs.rowspan - s }),
                ),
                (d += m.attrs.colspan - 1);
        }
    }
    return u;
}
function Ev(t, e, n, r, i, o, s, l) {
    if (s == 0 || s == e.width) return !1;
    let u = !1;
    for (let d = i; d < o; d++) {
        let f = d * e.width + s,
            h = e.map[f];
        if (e.map[f - 1] == h) {
            u = !0;
            let m = n.nodeAt(h),
                b = e.colCount(h),
                y = t.mapping.slice(l).map(h + r);
            t.setNodeMarkup(y, null, ro(m.attrs, s - b, m.attrs.colspan - (s - b))),
                t.insert(y + m.nodeSize, m.type.createAndFill(ro(m.attrs, 0, s - b))),
                (d += m.attrs.rowspan - 1);
        }
    }
    return u;
}
function vv(t, e, n, r, i) {
    let o = n ? t.doc.nodeAt(n - 1) : t.doc;
    if (!o) throw new Error('No table found');
    let s = bt.get(o),
        { top: l, left: u } = r,
        d = u + i.width,
        f = l + i.height,
        h = t.tr,
        m = 0;
    function b() {
        if (((o = n ? h.doc.nodeAt(n - 1) : h.doc), !o)) throw new Error('No table found');
        (s = bt.get(o)), (m = h.mapping.maps.length);
    }
    nP(h, s, o, n, d, f, m) && b(),
        yv(h, s, o, n, u, d, l, m) && b(),
        yv(h, s, o, n, u, d, f, m) && b(),
        Ev(h, s, o, n, l, f, u, m) && b(),
        Ev(h, s, o, n, l, f, d, m) && b();
    for (let y = l; y < f; y++) {
        let v = s.positionAt(y, u, o),
            x = s.positionAt(y, d, o);
        h.replace(h.mapping.slice(m).map(v + n), h.mapping.slice(m).map(x + n), new X(i.rows[y - l], 0, 0));
    }
    b(),
        h.setSelection(
            new rt(h.doc.resolve(n + s.positionAt(l, u, o)), h.doc.resolve(n + s.positionAt(f - 1, d - 1, o))),
        ),
        e(h);
}
var rP = Qs({
    ArrowLeft: cc('horiz', -1),
    ArrowRight: cc('horiz', 1),
    ArrowUp: cc('vert', -1),
    ArrowDown: cc('vert', 1),
    'Shift-ArrowLeft': uc('horiz', -1),
    'Shift-ArrowRight': uc('horiz', 1),
    'Shift-ArrowUp': uc('vert', -1),
    'Shift-ArrowDown': uc('vert', 1),
    Backspace: dc,
    'Mod-Backspace': dc,
    Delete: dc,
    'Mod-Delete': dc,
});
function fc(t, e, n) {
    return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function cc(t, e) {
    return (n, r, i) => {
        if (!i) return !1;
        let o = n.selection;
        if (o instanceof rt) return fc(n, r, fe.near(o.$headCell, e));
        if (t != 'horiz' && !o.empty) return !1;
        let s = Nv(i, t, e);
        if (s == null) return !1;
        if (t == 'horiz') return fc(n, r, fe.near(n.doc.resolve(o.head + e), e));
        {
            let l = n.doc.resolve(s),
                u = Mv(l, t, e),
                d;
            return (
                u
                    ? (d = fe.near(u, 1))
                    : e < 0
                      ? (d = fe.near(n.doc.resolve(l.before(-1)), -1))
                      : (d = fe.near(n.doc.resolve(l.after(-1)), 1)),
                fc(n, r, d)
            );
        }
    };
}
function uc(t, e) {
    return (n, r, i) => {
        if (!i) return !1;
        let o = n.selection,
            s;
        if (o instanceof rt) s = o;
        else {
            let u = Nv(i, t, e);
            if (u == null) return !1;
            s = new rt(n.doc.resolve(u));
        }
        let l = Mv(s.$headCell, t, e);
        return l ? fc(n, r, new rt(s.$anchorCell, l)) : !1;
    };
}
function dc(t, e) {
    let n = t.selection;
    if (!(n instanceof rt)) return !1;
    if (e) {
        let r = t.tr,
            i = sn(t.schema).cell.createAndFill().content;
        n.forEachCell((o, s) => {
            o.content.eq(i) || r.replace(r.mapping.map(s + 1), r.mapping.map(s + o.nodeSize - 1), new X(i, 0, 0));
        }),
            r.docChanged && e(r);
    }
    return !0;
}
function iP(t, e) {
    let n = t.state.doc,
        r = qo(n.resolve(e));
    return r ? (t.dispatch(t.state.tr.setSelection(new rt(r))), !0) : !1;
}
function oP(t, e, n) {
    if (!ir(t.state)) return !1;
    let r = QD(n),
        i = t.state.selection;
    if (i instanceof rt) {
        r || (r = { width: 1, height: 1, rows: [K.from(Dp(sn(t.state.schema).cell, n))] });
        let o = i.$anchorCell.node(-1),
            s = i.$anchorCell.start(-1),
            l = bt.get(o).rectBetween(i.$anchorCell.pos - s, i.$headCell.pos - s);
        return (r = tP(r, l.right - l.left, l.bottom - l.top)), vv(t.state, t.dispatch, s, l, r), !0;
    } else if (r) {
        let o = hc(t.state),
            s = o.start(-1);
        return vv(t.state, t.dispatch, s, bt.get(o.node(-1)).findCell(o.pos - s), r), !0;
    } else return !1;
}
function sP(t, e) {
    var n;
    if (e.ctrlKey || e.metaKey) return;
    let r = wv(t, e.target),
        i;
    if (e.shiftKey && t.state.selection instanceof rt) o(t.state.selection.$anchorCell, e), e.preventDefault();
    else if (
        e.shiftKey &&
        r &&
        (i = qo(t.state.selection.$anchor)) != null &&
        ((n = Op(t, e)) == null ? void 0 : n.pos) != i.pos
    )
        o(i, e), e.preventDefault();
    else if (!r) return;
    function o(u, d) {
        let f = Op(t, d),
            h = bi.getState(t.state) == null;
        if (!f || !Bp(u, f))
            if (h) f = u;
            else return;
        let m = new rt(u, f);
        if (h || !t.state.selection.eq(m)) {
            let b = t.state.tr.setSelection(m);
            h && b.setMeta(bi, u.pos), t.dispatch(b);
        }
    }
    function s() {
        t.root.removeEventListener('mouseup', s),
            t.root.removeEventListener('dragstart', s),
            t.root.removeEventListener('mousemove', l),
            bi.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(bi, -1));
    }
    function l(u) {
        let d = u,
            f = bi.getState(t.state),
            h;
        if (f != null) h = t.state.doc.resolve(f);
        else if (wv(t, d.target) != r && ((h = Op(t, e)), !h)) return s();
        h && o(h, d);
    }
    t.root.addEventListener('mouseup', s),
        t.root.addEventListener('dragstart', s),
        t.root.addEventListener('mousemove', l);
}
function Nv(t, e, n) {
    if (!(t.state.selection instanceof ce)) return null;
    let { $head: r } = t.state.selection;
    for (let i = r.depth - 1; i >= 0; i--) {
        let o = r.node(i);
        if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount)) return null;
        if (o.type.spec.tableRole == 'cell' || o.type.spec.tableRole == 'header_cell') {
            let l = r.before(i),
                u = e == 'vert' ? (n > 0 ? 'down' : 'up') : n > 0 ? 'right' : 'left';
            return t.endOfTextblock(u) ? l : null;
        }
    }
    return null;
}
function wv(t, e) {
    for (; e && e != t.dom; e = e.parentNode) if (e.nodeName == 'TD' || e.nodeName == 'TH') return e;
    return null;
}
function Op(t, e) {
    let n = t.posAtCoords({ left: e.clientX, top: e.clientY });
    return n && n ? qo(t.state.doc.resolve(n.pos)) : null;
}
var aP = class {
    constructor(t, e) {
        (this.node = t),
            (this.cellMinWidth = e),
            (this.dom = document.createElement('div')),
            (this.dom.className = 'tableWrapper'),
            (this.table = this.dom.appendChild(document.createElement('table'))),
            (this.colgroup = this.table.appendChild(document.createElement('colgroup'))),
            Pp(t, this.colgroup, this.table, e),
            (this.contentDOM = this.table.appendChild(document.createElement('tbody')));
    }
    update(t) {
        return t.type != this.node.type
            ? !1
            : ((this.node = t), Pp(t, this.colgroup, this.table, this.cellMinWidth), !0);
    }
    ignoreMutation(t) {
        return t.type == 'attributes' && (t.target == this.table || this.colgroup.contains(t.target));
    }
};
function Pp(t, e, n, r, i, o) {
    var s;
    let l = 0,
        u = !0,
        d = e.firstChild,
        f = t.firstChild;
    if (f) {
        for (let h = 0, m = 0; h < f.childCount; h++) {
            let { colspan: b, colwidth: y } = f.child(h).attrs;
            for (let v = 0; v < b; v++, m++) {
                let x = i == m ? o : y && y[v],
                    T = x ? x + 'px' : '';
                (l += x || r),
                    x || (u = !1),
                    d
                        ? (d.style.width != T && (d.style.width = T), (d = d.nextSibling))
                        : (e.appendChild(document.createElement('col')).style.width = T);
            }
        }
        for (; d; ) {
            let h = d.nextSibling;
            (s = d.parentNode) == null || s.removeChild(d), (d = h);
        }
        u
            ? ((n.style.width = l + 'px'), (n.style.minWidth = ''))
            : ((n.style.width = ''), (n.style.minWidth = l + 'px'));
    }
}
var Wn = new ze('tableColumnResizing');
function Ov({ handleWidth: t = 5, cellMinWidth: e = 25, View: n = aP, lastColumnResizable: r = !0 } = {}) {
    let i = new Oe({
        key: Wn,
        state: {
            init(o, s) {
                return (i.spec.props.nodeViews[sn(s.schema).table.name] = (l, u) => new n(l, e, u)), new lP(-1, !1);
            },
            apply(o, s) {
                return s.apply(o);
            },
        },
        props: {
            attributes: (o) => {
                let s = Wn.getState(o);
                return s && s.activeHandle > -1 ? { class: 'resize-cursor' } : {};
            },
            handleDOMEvents: {
                mousemove: (o, s) => {
                    cP(o, s, t, e, r);
                },
                mouseleave: (o) => {
                    uP(o);
                },
                mousedown: (o, s) => {
                    dP(o, s, e);
                },
            },
            decorations: (o) => {
                let s = Wn.getState(o);
                if (s && s.activeHandle > -1) return bP(o, s.activeHandle);
            },
            nodeViews: {},
        },
    });
    return i;
}
var lP = class pc {
    constructor(e, n) {
        (this.activeHandle = e), (this.dragging = n);
    }
    apply(e) {
        let n = this,
            r = e.getMeta(Wn);
        if (r && r.setHandle != null) return new pc(r.setHandle, !1);
        if (r && r.setDragging !== void 0) return new pc(n.activeHandle, r.setDragging);
        if (n.activeHandle > -1 && e.docChanged) {
            let i = e.mapping.map(n.activeHandle, -1);
            return Lp(e.doc.resolve(i)) || (i = -1), new pc(i, n.dragging);
        }
        return n;
    }
};
function cP(t, e, n, r, i) {
    let o = Wn.getState(t.state);
    if (o && !o.dragging) {
        let s = pP(e.target),
            l = -1;
        if (s) {
            let { left: u, right: d } = s.getBoundingClientRect();
            e.clientX - u <= n ? (l = xv(t, e, 'left', n)) : d - e.clientX <= n && (l = xv(t, e, 'right', n));
        }
        if (l != o.activeHandle) {
            if (!i && l !== -1) {
                let u = t.state.doc.resolve(l),
                    d = u.node(-1),
                    f = bt.get(d),
                    h = u.start(-1);
                if (f.colCount(u.pos - h) + u.nodeAfter.attrs.colspan - 1 == f.width - 1) return;
            }
            Rv(t, l);
        }
    }
}
function uP(t) {
    let e = Wn.getState(t.state);
    e && e.activeHandle > -1 && !e.dragging && Rv(t, -1);
}
function dP(t, e, n) {
    var r;
    let i = (r = t.dom.ownerDocument.defaultView) != null ? r : window,
        o = Wn.getState(t.state);
    if (!o || o.activeHandle == -1 || o.dragging) return !1;
    let s = t.state.doc.nodeAt(o.activeHandle),
        l = fP(t, o.activeHandle, s.attrs);
    t.dispatch(t.state.tr.setMeta(Wn, { setDragging: { startX: e.clientX, startWidth: l } }));
    function u(f) {
        i.removeEventListener('mouseup', u), i.removeEventListener('mousemove', d);
        let h = Wn.getState(t.state);
        h?.dragging &&
            (hP(t, h.activeHandle, _v(h.dragging, f, n)), t.dispatch(t.state.tr.setMeta(Wn, { setDragging: null })));
    }
    function d(f) {
        if (!f.which) return u(f);
        let h = Wn.getState(t.state);
        if (h && h.dragging) {
            let m = _v(h.dragging, f, n);
            mP(t, h.activeHandle, m, n);
        }
    }
    return i.addEventListener('mouseup', u), i.addEventListener('mousemove', d), e.preventDefault(), !0;
}
function fP(t, e, { colspan: n, colwidth: r }) {
    let i = r && r[r.length - 1];
    if (i) return i;
    let o = t.domAtPos(e),
        l = o.node.childNodes[o.offset].offsetWidth,
        u = n;
    if (r) for (let d = 0; d < n; d++) r[d] && ((l -= r[d]), u--);
    return l / u;
}
function pP(t) {
    for (; t && t.nodeName != 'TD' && t.nodeName != 'TH'; )
        t = t.classList && t.classList.contains('ProseMirror') ? null : t.parentNode;
    return t;
}
function xv(t, e, n, r) {
    let i = n == 'right' ? -r : r,
        o = t.posAtCoords({ left: e.clientX + i, top: e.clientY });
    if (!o) return -1;
    let { pos: s } = o,
        l = qo(t.state.doc.resolve(s));
    if (!l) return -1;
    if (n == 'right') return l.pos;
    let u = bt.get(l.node(-1)),
        d = l.start(-1),
        f = u.map.indexOf(l.pos - d);
    return f % u.width == 0 ? -1 : d + u.map[f - 1];
}
function _v(t, e, n) {
    let r = e.clientX - t.startX;
    return Math.max(n, t.startWidth + r);
}
function Rv(t, e) {
    t.dispatch(t.state.tr.setMeta(Wn, { setHandle: e }));
}
function hP(t, e, n) {
    let r = t.state.doc.resolve(e),
        i = r.node(-1),
        o = bt.get(i),
        s = r.start(-1),
        l = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1,
        u = t.state.tr;
    for (let d = 0; d < o.height; d++) {
        let f = d * o.width + l;
        if (d && o.map[f] == o.map[f - o.width]) continue;
        let h = o.map[f],
            m = i.nodeAt(h).attrs,
            b = m.colspan == 1 ? 0 : l - o.colCount(h);
        if (m.colwidth && m.colwidth[b] == n) continue;
        let y = m.colwidth ? m.colwidth.slice() : gP(m.colspan);
        (y[b] = n), u.setNodeMarkup(s + h, null, { ...m, colwidth: y });
    }
    u.docChanged && t.dispatch(u);
}
function mP(t, e, n, r) {
    let i = t.state.doc.resolve(e),
        o = i.node(-1),
        s = i.start(-1),
        l = bt.get(o).colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1,
        u = t.domAtPos(i.start(-1)).node;
    for (; u && u.nodeName != 'TABLE'; ) u = u.parentNode;
    u && Pp(o, u.firstChild, u, r, l, n);
}
function gP(t) {
    return Array(t).fill(0);
}
function bP(t, e) {
    let n = [],
        r = t.doc.resolve(e),
        i = r.node(-1);
    if (!i) return lt.empty;
    let o = bt.get(i),
        s = r.start(-1),
        l = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan;
    for (let u = 0; u < o.height; u++) {
        let d = l + u * o.width - 1;
        if ((l == o.width || o.map[d] != o.map[d + 1]) && (u == 0 || o.map[d] != o.map[d - o.width])) {
            let f = o.map[d],
                h = s + f + i.nodeAt(f).nodeSize - 1,
                m = document.createElement('div');
            (m.className = 'column-resize-handle'), n.push(Mt.widget(h, m));
        }
    }
    return lt.create(t.doc, n);
}
function br(t) {
    let e = t.selection,
        n = hc(t),
        r = n.node(-1),
        i = n.start(-1),
        o = bt.get(r);
    return {
        ...(e instanceof rt ? o.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i) : o.findCell(n.pos - i)),
        tableStart: i,
        map: o,
        table: r,
    };
}
function Iv(t, { map: e, tableStart: n, table: r }, i) {
    let o = i > 0 ? -1 : 0;
    VD(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0);
    for (let s = 0; s < e.height; s++) {
        let l = s * e.width + i;
        if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
            let u = e.map[l],
                d = r.nodeAt(u);
            t.setNodeMarkup(t.mapping.map(n + u), null, Av(d.attrs, i - e.colCount(u))), (s += d.attrs.rowspan - 1);
        } else {
            let u = o == null ? sn(r.type.schema).cell : r.nodeAt(e.map[l + o]).type,
                d = e.positionAt(s, i, r);
            t.insert(t.mapping.map(n + d), u.createAndFill());
        }
    }
    return t;
}
function Lv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t);
        e(Iv(t.tr, n, n.left));
    }
    return !0;
}
function Dv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t);
        e(Iv(t.tr, n, n.right));
    }
    return !0;
}
function yP(t, { map: e, table: n, tableStart: r }, i) {
    let o = t.mapping.maps.length;
    for (let s = 0; s < e.height; ) {
        let l = s * e.width + i,
            u = e.map[l],
            d = n.nodeAt(u),
            f = d.attrs;
        if ((i > 0 && e.map[l - 1] == u) || (i < e.width - 1 && e.map[l + 1] == u))
            t.setNodeMarkup(t.mapping.slice(o).map(r + u), null, ro(f, i - e.colCount(u)));
        else {
            let h = t.mapping.slice(o).map(r + u);
            t.delete(h, h + d.nodeSize);
        }
        s += f.rowspan;
    }
}
function Pv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t),
            r = t.tr;
        if (n.left == 0 && n.right == n.map.width) return !1;
        for (let i = n.right - 1; yP(r, n, i), i != n.left; i--) {
            let o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!o) throw RangeError('No table found');
            (n.table = o), (n.map = bt.get(o));
        }
        e(r);
    }
    return !0;
}
function EP(t, e, n) {
    var r;
    let i = sn(e.type.schema).header_cell;
    for (let o = 0; o < t.width; o++)
        if (((r = e.nodeAt(t.map[o + n * t.width])) == null ? void 0 : r.type) != i) return !1;
    return !0;
}
function Bv(t, { map: e, tableStart: n, table: r }, i) {
    var o;
    let s = n;
    for (let d = 0; d < i; d++) s += r.child(d).nodeSize;
    let l = [],
        u = i > 0 ? -1 : 0;
    EP(e, r, i + u) && (u = i == 0 || i == e.height ? null : 0);
    for (let d = 0, f = e.width * i; d < e.width; d++, f++)
        if (i > 0 && i < e.height && e.map[f] == e.map[f - e.width]) {
            let h = e.map[f],
                m = r.nodeAt(h).attrs;
            t.setNodeMarkup(n + h, null, { ...m, rowspan: m.rowspan + 1 }), (d += m.colspan - 1);
        } else {
            let h =
                    u == null
                        ? sn(r.type.schema).cell
                        : (o = r.nodeAt(e.map[f + u * e.width])) == null
                          ? void 0
                          : o.type,
                m = h?.createAndFill();
            m && l.push(m);
        }
    return t.insert(s, sn(r.type.schema).row.create(null, l)), t;
}
function Fv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t);
        e(Bv(t.tr, n, n.top));
    }
    return !0;
}
function Hv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t);
        e(Bv(t.tr, n, n.bottom));
    }
    return !0;
}
function vP(t, { map: e, table: n, tableStart: r }, i) {
    let o = 0;
    for (let d = 0; d < i; d++) o += n.child(d).nodeSize;
    let s = o + n.child(i).nodeSize,
        l = t.mapping.maps.length;
    t.delete(o + r, s + r);
    let u = new Set();
    for (let d = 0, f = i * e.width; d < e.width; d++, f++) {
        let h = e.map[f];
        if (!u.has(h)) {
            if ((u.add(h), i > 0 && h == e.map[f - e.width])) {
                let m = n.nodeAt(h).attrs;
                t.setNodeMarkup(t.mapping.slice(l).map(h + r), null, { ...m, rowspan: m.rowspan - 1 }),
                    (d += m.colspan - 1);
            } else if (i < e.height && h == e.map[f + e.width]) {
                let m = n.nodeAt(h),
                    b = m.attrs,
                    y = m.type.create({ ...b, rowspan: m.attrs.rowspan - 1 }, m.content),
                    v = e.positionAt(i + 1, d, n);
                t.insert(t.mapping.slice(l).map(r + v), y), (d += b.colspan - 1);
            }
        }
    }
}
function zv(t, e) {
    if (!ir(t)) return !1;
    if (e) {
        let n = br(t),
            r = t.tr;
        if (n.top == 0 && n.bottom == n.map.height) return !1;
        for (let i = n.bottom - 1; vP(r, n, i), i != n.top; i--) {
            let o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!o) throw RangeError('No table found');
            (n.table = o), (n.map = bt.get(n.table));
        }
        e(r);
    }
    return !0;
}
function Sv(t) {
    let e = t.content;
    return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function wP({ width: t, height: e, map: n }, r) {
    let i = r.top * t + r.left,
        o = i,
        s = (r.bottom - 1) * t + r.left,
        l = i + (r.right - r.left - 1);
    for (let u = r.top; u < r.bottom; u++) {
        if ((r.left > 0 && n[o] == n[o - 1]) || (r.right < t && n[l] == n[l + 1])) return !0;
        (o += t), (l += t);
    }
    for (let u = r.left; u < r.right; u++) {
        if ((r.top > 0 && n[i] == n[i - t]) || (r.bottom < e && n[s] == n[s + t])) return !0;
        i++, s++;
    }
    return !1;
}
function Hp(t, e) {
    let n = t.selection;
    if (!(n instanceof rt) || n.$anchorCell.pos == n.$headCell.pos) return !1;
    let r = br(t),
        { map: i } = r;
    if (wP(i, r)) return !1;
    if (e) {
        let o = t.tr,
            s = {},
            l = K.empty,
            u,
            d;
        for (let f = r.top; f < r.bottom; f++)
            for (let h = r.left; h < r.right; h++) {
                let m = i.map[f * i.width + h],
                    b = r.table.nodeAt(m);
                if (!(s[m] || !b))
                    if (((s[m] = !0), u == null)) (u = m), (d = b);
                    else {
                        Sv(b) || (l = l.append(b.content));
                        let y = o.mapping.map(m + r.tableStart);
                        o.delete(y, y + b.nodeSize);
                    }
            }
        if (u == null || d == null) return !0;
        if (
            (o.setNodeMarkup(u + r.tableStart, null, {
                ...Av(d.attrs, d.attrs.colspan, r.right - r.left - d.attrs.colspan),
                rowspan: r.bottom - r.top,
            }),
            l.size)
        ) {
            let f = u + 1 + d.content.size,
                h = Sv(d) ? u + 1 : f;
            o.replaceWith(h + r.tableStart, f + r.tableStart, l);
        }
        o.setSelection(new rt(o.doc.resolve(u + r.tableStart))), e(o);
    }
    return !0;
}
function zp(t, e) {
    let n = sn(t.schema);
    return xP(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function xP(t) {
    return (e, n) => {
        var r;
        let i = e.selection,
            o,
            s;
        if (i instanceof rt) {
            if (i.$anchorCell.pos != i.$headCell.pos) return !1;
            (o = i.$anchorCell.nodeAfter), (s = i.$anchorCell.pos);
        } else {
            if (((o = UD(i.$from)), !o)) return !1;
            s = (r = qo(i.$from)) == null ? void 0 : r.pos;
        }
        if (o == null || s == null || (o.attrs.colspan == 1 && o.attrs.rowspan == 1)) return !1;
        if (n) {
            let l = o.attrs,
                u = [],
                d = l.colwidth;
            l.rowspan > 1 && (l = { ...l, rowspan: 1 }), l.colspan > 1 && (l = { ...l, colspan: 1 });
            let f = br(e),
                h = e.tr;
            for (let b = 0; b < f.right - f.left; b++) u.push(d ? { ...l, colwidth: d && d[b] ? [d[b]] : null } : l);
            let m;
            for (let b = f.top; b < f.bottom; b++) {
                let y = f.map.positionAt(b, f.left, f.table);
                b == f.top && (y += o.nodeSize);
                for (let v = f.left, x = 0; v < f.right; v++, x++)
                    (v == f.left && b == f.top) ||
                        h.insert(
                            (m = h.mapping.map(y + f.tableStart, 1)),
                            t({ node: o, row: b, col: v }).createAndFill(u[x]),
                        );
            }
            h.setNodeMarkup(s, t({ node: o, row: f.top, col: f.left }), u[0]),
                i instanceof rt &&
                    h.setSelection(new rt(h.doc.resolve(i.$anchorCell.pos), m ? h.doc.resolve(m) : void 0)),
                n(h);
        }
        return !0;
    };
}
function $v(t, e) {
    return function (n, r) {
        if (!ir(n)) return !1;
        let i = hc(n);
        if (i.nodeAfter.attrs[t] === e) return !1;
        if (r) {
            let o = n.tr;
            n.selection instanceof rt
                ? n.selection.forEachCell((s, l) => {
                      s.attrs[t] !== e && o.setNodeMarkup(l, null, { ...s.attrs, [t]: e });
                  })
                : o.setNodeMarkup(i.pos, null, { ...i.nodeAfter.attrs, [t]: e }),
                r(o);
        }
        return !0;
    };
}
function _P(t) {
    return function (e, n) {
        if (!ir(e)) return !1;
        if (n) {
            let r = sn(e.schema),
                i = br(e),
                o = e.tr,
                s = i.map.cellsInRect(
                    t == 'column'
                        ? { left: i.left, top: 0, right: i.right, bottom: i.map.height }
                        : t == 'row'
                          ? { left: 0, top: i.top, right: i.map.width, bottom: i.bottom }
                          : i,
                ),
                l = s.map((u) => i.table.nodeAt(u));
            for (let u = 0; u < s.length; u++)
                l[u].type == r.header_cell && o.setNodeMarkup(i.tableStart + s[u], r.cell, l[u].attrs);
            if (o.steps.length == 0)
                for (let u = 0; u < s.length; u++) o.setNodeMarkup(i.tableStart + s[u], r.header_cell, l[u].attrs);
            n(o);
        }
        return !0;
    };
}
function Tv(t, e, n) {
    let r = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: t == 'row' ? e.map.width : 1,
        bottom: t == 'column' ? e.map.height : 1,
    });
    for (let i = 0; i < r.length; i++) {
        let o = e.table.nodeAt(r[i]);
        if (o && o.type !== n.header_cell) return !1;
    }
    return !0;
}
function Yo(t, e) {
    return (
        (e = e || { useDeprecatedLogic: !1 }),
        e.useDeprecatedLogic
            ? _P(t)
            : function (n, r) {
                  if (!ir(n)) return !1;
                  if (r) {
                      let i = sn(n.schema),
                          o = br(n),
                          s = n.tr,
                          l = Tv('row', o, i),
                          u = Tv('column', o, i),
                          f = (t === 'column' ? l : t === 'row' ? u : !1) ? 1 : 0,
                          h =
                              t == 'column'
                                  ? { left: 0, top: f, right: 1, bottom: o.map.height }
                                  : t == 'row'
                                    ? { left: f, top: 0, right: o.map.width, bottom: 1 }
                                    : o,
                          m =
                              t == 'column'
                                  ? u
                                      ? i.cell
                                      : i.header_cell
                                  : t == 'row'
                                    ? l
                                        ? i.cell
                                        : i.header_cell
                                    : i.cell;
                      o.map.cellsInRect(h).forEach((b) => {
                          let y = b + o.tableStart,
                              v = s.doc.nodeAt(y);
                          v && s.setNodeMarkup(y, m, v.attrs);
                      }),
                          r(s);
                  }
                  return !0;
              }
    );
}
var pU = Yo('row', { useDeprecatedLogic: !0 }),
    hU = Yo('column', { useDeprecatedLogic: !0 }),
    Uv = Yo('cell', { useDeprecatedLogic: !0 });
function SP(t, e) {
    if (e < 0) {
        let n = t.nodeBefore;
        if (n) return t.pos - n.nodeSize;
        for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
            let o = t.node(-1).child(r),
                s = o.lastChild;
            if (s) return i - 1 - s.nodeSize;
            i -= o.nodeSize;
        }
    } else {
        if (t.index() < t.parent.childCount - 1) return t.pos + t.nodeAfter.nodeSize;
        let n = t.node(-1);
        for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
            let o = n.child(r);
            if (o.childCount) return i + 1;
            i += o.nodeSize;
        }
    }
    return null;
}
function $p(t) {
    return function (e, n) {
        if (!ir(e)) return !1;
        let r = SP(hc(e), t);
        if (r == null) return !1;
        if (n) {
            let i = e.doc.resolve(r);
            n(e.tr.setSelection(ce.between(i, KD(i))).scrollIntoView());
        }
        return !0;
    };
}
function Wv(t, e) {
    let n = t.selection.$anchor;
    for (let r = n.depth; r > 0; r--)
        if (n.node(r).type.spec.tableRole == 'table')
            return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0;
    return !1;
}
function Kv({ allowTableNodeSelection: t = !1 } = {}) {
    return new Oe({
        key: bi,
        state: {
            init() {
                return null;
            },
            apply(e, n) {
                let r = e.getMeta(bi);
                if (r != null) return r == -1 ? null : r;
                if (n == null || !e.docChanged) return n;
                let { deleted: i, pos: o } = e.mapping.mapResult(n);
                return i ? null : o;
            },
        },
        props: {
            decorations: qD,
            handleDOMEvents: { mousedown: sP },
            createSelectionBetween(e) {
                return bi.getState(e.state) != null ? e.state.selection : null;
            },
            handleTripleClick: iP,
            handleKeyDown: rP,
            handlePaste: oP,
        },
        appendTransaction(e, n, r) {
            return XD(r, Fp(r, n), t);
        },
    });
}
function Vv(t, e, n, r, i, o) {
    let s = 0,
        l = !0,
        u = e.firstChild,
        d = t.firstChild;
    for (let f = 0, h = 0; f < d.childCount; f += 1) {
        let { colspan: m, colwidth: b } = d.child(f).attrs;
        for (let y = 0; y < m; y += 1, h += 1) {
            let v = i === h ? o : b && b[y],
                x = v ? `${v}px` : '';
            (s += v || r),
                v || (l = !1),
                u
                    ? (u.style.width !== x && (u.style.width = x), (u = u.nextSibling))
                    : (e.appendChild(document.createElement('col')).style.width = x);
        }
    }
    for (; u; ) {
        let f = u.nextSibling;
        u.parentNode.removeChild(u), (u = f);
    }
    l ? ((n.style.width = `${s}px`), (n.style.minWidth = '')) : ((n.style.width = ''), (n.style.minWidth = `${s}px`));
}
var Up = class {
    constructor(e, n) {
        (this.node = e),
            (this.cellMinWidth = n),
            (this.dom = document.createElement('div')),
            (this.dom.className = 'tableWrapper'),
            (this.table = this.dom.appendChild(document.createElement('table'))),
            (this.colgroup = this.table.appendChild(document.createElement('colgroup'))),
            Vv(e, this.colgroup, this.table, n),
            (this.contentDOM = this.table.appendChild(document.createElement('tbody')));
    }
    update(e) {
        return e.type !== this.node.type
            ? !1
            : ((this.node = e), Vv(e, this.colgroup, this.table, this.cellMinWidth), !0);
    }
    ignoreMutation(e) {
        return e.type === 'attributes' && (e.target === this.table || this.colgroup.contains(e.target));
    }
};
function TP(t, e, n, r) {
    let i = 0,
        o = !0,
        s = [],
        l = t.firstChild;
    if (!l) return {};
    for (let h = 0, m = 0; h < l.childCount; h += 1) {
        let { colspan: b, colwidth: y } = l.child(h).attrs;
        for (let v = 0; v < b; v += 1, m += 1) {
            let x = n === m ? r : y && y[v],
                T = x ? `${x}px` : '';
            (i += x || e), x || (o = !1), s.push(['col', T ? { style: `width: ${T}` } : {}]);
        }
    }
    let u = o ? `${i}px` : '',
        d = o ? '' : `${i}px`;
    return { colgroup: ['colgroup', {}, ...s], tableWidth: u, tableMinWidth: d };
}
function Gv(t, e) {
    return e ? t.createChecked(null, e) : t.createAndFill();
}
function MP(t) {
    if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
    let e = {};
    return (
        Object.keys(t.nodes).forEach((n) => {
            let r = t.nodes[n];
            r.spec.tableRole && (e[r.spec.tableRole] = r);
        }),
        (t.cached.tableNodeTypes = e),
        e
    );
}
function AP(t, e, n, r, i) {
    let o = MP(t),
        s = [],
        l = [];
    for (let d = 0; d < n; d += 1) {
        let f = Gv(o.cell, i);
        if ((f && l.push(f), r)) {
            let h = Gv(o.header_cell, i);
            h && s.push(h);
        }
    }
    let u = [];
    for (let d = 0; d < e; d += 1) u.push(o.row.createChecked(null, r && d === 0 ? s : l));
    return o.table.createChecked(null, u);
}
function CP(t) {
    return t instanceof rt;
}
var mc = ({ editor: t }) => {
        let { selection: e } = t.state;
        if (!CP(e)) return !1;
        let n = 0,
            r = wp(e.ranges[0].$from, (o) => o.type.name === 'table');
        return (
            r?.node.descendants((o) => {
                if (o.type.name === 'table') return !1;
                ['tableCell', 'tableHeader'].includes(o.type.name) && (n += 1);
            }),
            n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
        );
    },
    qv = ae.create({
        name: 'table',
        addOptions() {
            return {
                HTMLAttributes: {},
                resizable: !1,
                handleWidth: 5,
                cellMinWidth: 25,
                View: Up,
                lastColumnResizable: !0,
                allowTableNodeSelection: !1,
            };
        },
        content: 'tableRow+',
        tableRole: 'table',
        isolating: !0,
        group: 'block',
        parseHTML() {
            return [{ tag: 'table' }];
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            let { colgroup: n, tableWidth: r, tableMinWidth: i } = TP(t, this.options.cellMinWidth);
            return [
                'table',
                Z(this.options.HTMLAttributes, e, { style: r ? `width: ${r}` : `minWidth: ${i}` }),
                n,
                ['tbody', 0],
            ];
        },
        addCommands() {
            return {
                insertTable:
                    ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) =>
                    ({ tr: r, dispatch: i, editor: o }) => {
                        let s = AP(o.schema, t, e, n);
                        if (i) {
                            let l = r.selection.anchor + 1;
                            r.replaceSelectionWith(s)
                                .scrollIntoView()
                                .setSelection(ce.near(r.doc.resolve(l)));
                        }
                        return !0;
                    },
                addColumnBefore:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Lv(t, e),
                addColumnAfter:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Dv(t, e),
                deleteColumn:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Pv(t, e),
                addRowBefore:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Fv(t, e),
                addRowAfter:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Hv(t, e),
                deleteRow:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        zv(t, e),
                deleteTable:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Wv(t, e),
                mergeCells:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Hp(t, e),
                splitCell:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        zp(t, e),
                toggleHeaderColumn:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Yo('column')(t, e),
                toggleHeaderRow:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Yo('row')(t, e),
                toggleHeaderCell:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Uv(t, e),
                mergeOrSplit:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        Hp(t, e) ? !0 : zp(t, e),
                setCellAttribute:
                    (t, e) =>
                    ({ state: n, dispatch: r }) =>
                        $v(t, e)(n, r),
                goToNextCell:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        $p(1)(t, e),
                goToPreviousCell:
                    () =>
                    ({ state: t, dispatch: e }) =>
                        $p(-1)(t, e),
                fixTables:
                    () =>
                    ({ state: t, dispatch: e }) => (e && Fp(t), !0),
                setCellSelection:
                    (t) =>
                    ({ tr: e, dispatch: n }) => {
                        if (n) {
                            let r = rt.create(e.doc, t.anchorCell, t.headCell);
                            e.setSelection(r);
                        }
                        return !0;
                    },
            };
        },
        addKeyboardShortcuts() {
            return {
                Tab: () =>
                    this.editor.commands.goToNextCell()
                        ? !0
                        : this.editor.can().addRowAfter()
                          ? this.editor.chain().addRowAfter().goToNextCell().run()
                          : !1,
                'Shift-Tab': () => this.editor.commands.goToPreviousCell(),
                Backspace: mc,
                'Mod-Backspace': mc,
                Delete: mc,
                'Mod-Delete': mc,
            };
        },
        addProseMirrorPlugins() {
            return [
                ...(this.options.resizable && this.editor.isEditable
                    ? [
                          Ov({
                              handleWidth: this.options.handleWidth,
                              cellMinWidth: this.options.cellMinWidth,
                              View: this.options.View,
                              lastColumnResizable: this.options.lastColumnResizable,
                          }),
                      ]
                    : []),
                Kv({ allowTableNodeSelection: this.options.allowTableNodeSelection }),
            ];
        },
        extendNodeSchema(t) {
            let e = { name: t.name, options: t.options, storage: t.storage };
            return { tableRole: Se(ie(t, 'tableRole', e)) };
        },
    });
var Yv = ae.create({
    name: 'tableCell',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    content: 'block+',
    addAttributes() {
        return {
            colspan: { default: 1 },
            rowspan: { default: 1 },
            colwidth: {
                default: null,
                parseHTML: (t) => {
                    let e = t.getAttribute('colwidth');
                    return e ? [parseInt(e, 10)] : null;
                },
            },
        };
    },
    tableRole: 'cell',
    isolating: !0,
    parseHTML() {
        return [{ tag: 'td' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['td', Z(this.options.HTMLAttributes, t), 0];
    },
});
var Jv = ae.create({
    name: 'tableHeader',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    content: 'block+',
    addAttributes() {
        return {
            colspan: { default: 1 },
            rowspan: { default: 1 },
            colwidth: {
                default: null,
                parseHTML: (t) => {
                    let e = t.getAttribute('colwidth');
                    return e ? [parseInt(e, 10)] : null;
                },
            },
        };
    },
    tableRole: 'header_cell',
    isolating: !0,
    parseHTML() {
        return [{ tag: 'th' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['th', Z(this.options.HTMLAttributes, t), 0];
    },
});
var Xv = ae.create({
    name: 'tableRow',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    content: '(tableCell | tableHeader)*',
    tableRole: 'row',
    parseHTML() {
        return [{ tag: 'tr' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['tr', Z(this.options.HTMLAttributes, t), 0];
    },
});
var Zv = ae.create({ name: 'text', group: 'inline' });
var jv = tt.create({
    name: 'underline',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [
            { tag: 'u' },
            { style: 'text-decoration', consuming: !1, getAttrs: (t) => (t.includes('underline') ? {} : !1) },
        ];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['u', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setUnderline:
                () =>
                ({ commands: t }) =>
                    t.setMark(this.name),
            toggleUnderline:
                () =>
                ({ commands: t }) =>
                    t.toggleMark(this.name),
            unsetUnderline:
                () =>
                ({ commands: t }) =>
                    t.unsetMark(this.name),
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-u': () => this.editor.commands.toggleUnderline(),
            'Mod-U': () => this.editor.commands.toggleUnderline(),
        };
    },
});
var kP = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/,
    NP = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g,
    Qv = tt.create({
        name: 'highlight',
        addOptions() {
            return { multicolor: !1, HTMLAttributes: {} };
        },
        addAttributes() {
            return this.options.multicolor
                ? {
                      color: {
                          default: null,
                          parseHTML: (t) => t.getAttribute('data-color') || t.style.backgroundColor,
                          renderHTML: (t) =>
                              t.color
                                  ? { 'data-color': t.color, style: `background-color: ${t.color}; color: inherit` }
                                  : {},
                      },
                  }
                : {};
        },
        parseHTML() {
            return [{ tag: 'mark' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['mark', Z(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
            return {
                setHighlight:
                    (t) =>
                    ({ commands: e }) =>
                        e.setMark(this.name, t),
                toggleHighlight:
                    (t) =>
                    ({ commands: e }) =>
                        e.toggleMark(this.name, t),
                unsetHighlight:
                    () =>
                    ({ commands: t }) =>
                        t.unsetMark(this.name),
            };
        },
        addKeyboardShortcuts() {
            return { 'Mod-Shift-h': () => this.editor.commands.toggleHighlight() };
        },
        addInputRules() {
            return [Un({ find: kP, type: this.type })];
        },
        addPasteRules() {
            return [wn({ find: NP, type: this.type })];
        },
    });
var yt = 'top',
    Lt = 'bottom',
    Ct = 'right',
    wt = 'left',
    gc = 'auto',
    yi = [yt, Lt, Ct, wt],
    Ur = 'start',
    io = 'end',
    ew = 'clippingParents',
    bc = 'viewport',
    Jo = 'popper',
    tw = 'reference',
    Wp = yi.reduce(function (t, e) {
        return t.concat([e + '-' + Ur, e + '-' + io]);
    }, []),
    yc = [].concat(yi, [gc]).reduce(function (t, e) {
        return t.concat([e, e + '-' + Ur, e + '-' + io]);
    }, []),
    OP = 'beforeRead',
    RP = 'read',
    IP = 'afterRead',
    LP = 'beforeMain',
    DP = 'main',
    PP = 'afterMain',
    BP = 'beforeWrite',
    FP = 'write',
    HP = 'afterWrite',
    nw = [OP, RP, IP, LP, DP, PP, BP, FP, HP];
function Ut(t) {
    return t ? (t.nodeName || '').toLowerCase() : null;
}
function dt(t) {
    if (t == null) return window;
    if (t.toString() !== '[object Window]') {
        var e = t.ownerDocument;
        return (e && e.defaultView) || window;
    }
    return t;
}
function Kn(t) {
    var e = dt(t).Element;
    return t instanceof e || t instanceof Element;
}
function Dt(t) {
    var e = dt(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement;
}
function Xo(t) {
    if (typeof ShadowRoot > 'u') return !1;
    var e = dt(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot;
}
function zP(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function (n) {
        var r = e.styles[n] || {},
            i = e.attributes[n] || {},
            o = e.elements[n];
        !Dt(o) ||
            !Ut(o) ||
            (Object.assign(o.style, r),
            Object.keys(i).forEach(function (s) {
                var l = i[s];
                l === !1 ? o.removeAttribute(s) : o.setAttribute(s, l === !0 ? '' : l);
            }));
    });
}
function $P(t) {
    var e = t.state,
        n = {
            popper: { position: e.options.strategy, left: '0', top: '0', margin: '0' },
            arrow: { position: 'absolute' },
            reference: {},
        };
    return (
        Object.assign(e.elements.popper.style, n.popper),
        (e.styles = n),
        e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function () {
            Object.keys(e.elements).forEach(function (r) {
                var i = e.elements[r],
                    o = e.attributes[r] || {},
                    s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
                    l = s.reduce(function (u, d) {
                        return (u[d] = ''), u;
                    }, {});
                !Dt(i) ||
                    !Ut(i) ||
                    (Object.assign(i.style, l),
                    Object.keys(o).forEach(function (u) {
                        i.removeAttribute(u);
                    }));
            });
        }
    );
}
var na = { name: 'applyStyles', enabled: !0, phase: 'write', fn: zP, effect: $P, requires: ['computeStyles'] };
function Wt(t) {
    return t.split('-')[0];
}
var or = Math.max,
    oo = Math.min,
    Wr = Math.round;
function Zo() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands)
        ? t.brands
              .map(function (e) {
                  return e.brand + '/' + e.version;
              })
              .join(' ')
        : navigator.userAgent;
}
function ra() {
    return !/^((?!chrome|android).)*safari/i.test(Zo());
}
function Vn(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    var r = t.getBoundingClientRect(),
        i = 1,
        o = 1;
    e &&
        Dt(t) &&
        ((i = (t.offsetWidth > 0 && Wr(r.width) / t.offsetWidth) || 1),
        (o = (t.offsetHeight > 0 && Wr(r.height) / t.offsetHeight) || 1));
    var s = Kn(t) ? dt(t) : window,
        l = s.visualViewport,
        u = !ra() && n,
        d = (r.left + (u && l ? l.offsetLeft : 0)) / i,
        f = (r.top + (u && l ? l.offsetTop : 0)) / o,
        h = r.width / i,
        m = r.height / o;
    return { width: h, height: m, top: f, right: d + h, bottom: f + m, left: d, x: d, y: f };
}
function so(t) {
    var e = Vn(t),
        n = t.offsetWidth,
        r = t.offsetHeight;
    return (
        Math.abs(e.width - n) <= 1 && (n = e.width),
        Math.abs(e.height - r) <= 1 && (r = e.height),
        { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
    );
}
function ia(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (n && Xo(n)) {
        var r = e;
        do {
            if (r && t.isSameNode(r)) return !0;
            r = r.parentNode || r.host;
        } while (r);
    }
    return !1;
}
function mn(t) {
    return dt(t).getComputedStyle(t);
}
function Kp(t) {
    return ['table', 'td', 'th'].indexOf(Ut(t)) >= 0;
}
function Xt(t) {
    return ((Kn(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function Kr(t) {
    return Ut(t) === 'html' ? t : t.assignedSlot || t.parentNode || (Xo(t) ? t.host : null) || Xt(t);
}
function rw(t) {
    return !Dt(t) || mn(t).position === 'fixed' ? null : t.offsetParent;
}
function UP(t) {
    var e = /firefox/i.test(Zo()),
        n = /Trident/i.test(Zo());
    if (n && Dt(t)) {
        var r = mn(t);
        if (r.position === 'fixed') return null;
    }
    var i = Kr(t);
    for (Xo(i) && (i = i.host); Dt(i) && ['html', 'body'].indexOf(Ut(i)) < 0; ) {
        var o = mn(i);
        if (
            o.transform !== 'none' ||
            o.perspective !== 'none' ||
            o.contain === 'paint' ||
            ['transform', 'perspective'].indexOf(o.willChange) !== -1 ||
            (e && o.willChange === 'filter') ||
            (e && o.filter && o.filter !== 'none')
        )
            return i;
        i = i.parentNode;
    }
    return null;
}
function sr(t) {
    for (var e = dt(t), n = rw(t); n && Kp(n) && mn(n).position === 'static'; ) n = rw(n);
    return n && (Ut(n) === 'html' || (Ut(n) === 'body' && mn(n).position === 'static')) ? e : n || UP(t) || e;
}
function ao(t) {
    return ['top', 'bottom'].indexOf(t) >= 0 ? 'x' : 'y';
}
function lo(t, e, n) {
    return or(t, oo(e, n));
}
function iw(t, e, n) {
    var r = lo(t, e, n);
    return r > n ? n : r;
}
function oa() {
    return { top: 0, right: 0, bottom: 0, left: 0 };
}
function sa(t) {
    return Object.assign({}, oa(), t);
}
function aa(t, e) {
    return e.reduce(function (n, r) {
        return (n[r] = t), n;
    }, {});
}
var WP = function (e, n) {
    return (
        (e = typeof e == 'function' ? e(Object.assign({}, n.rects, { placement: n.placement })) : e),
        sa(typeof e != 'number' ? e : aa(e, yi))
    );
};
function KP(t) {
    var e,
        n = t.state,
        r = t.name,
        i = t.options,
        o = n.elements.arrow,
        s = n.modifiersData.popperOffsets,
        l = Wt(n.placement),
        u = ao(l),
        d = [wt, Ct].indexOf(l) >= 0,
        f = d ? 'height' : 'width';
    if (!(!o || !s)) {
        var h = WP(i.padding, n),
            m = so(o),
            b = u === 'y' ? yt : wt,
            y = u === 'y' ? Lt : Ct,
            v = n.rects.reference[f] + n.rects.reference[u] - s[u] - n.rects.popper[f],
            x = s[u] - n.rects.reference[u],
            T = sr(o),
            D = T ? (u === 'y' ? T.clientHeight || 0 : T.clientWidth || 0) : 0,
            I = v / 2 - x / 2,
            S = h[b],
            z = D - m[f] - h[y],
            N = D / 2 - m[f] / 2 + I,
            q = lo(S, N, z),
            ne = u;
        n.modifiersData[r] = ((e = {}), (e[ne] = q), (e.centerOffset = q - N), e);
    }
}
function VP(t) {
    var e = t.state,
        n = t.options,
        r = n.element,
        i = r === void 0 ? '[data-popper-arrow]' : r;
    i != null &&
        ((typeof i == 'string' && ((i = e.elements.popper.querySelector(i)), !i)) ||
            (ia(e.elements.popper, i) && (e.elements.arrow = i)));
}
var ow = {
    name: 'arrow',
    enabled: !0,
    phase: 'main',
    fn: KP,
    effect: VP,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow'],
};
function Gn(t) {
    return t.split('-')[1];
}
var GP = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' };
function qP(t, e) {
    var n = t.x,
        r = t.y,
        i = e.devicePixelRatio || 1;
    return { x: Wr(n * i) / i || 0, y: Wr(r * i) / i || 0 };
}
function sw(t) {
    var e,
        n = t.popper,
        r = t.popperRect,
        i = t.placement,
        o = t.variation,
        s = t.offsets,
        l = t.position,
        u = t.gpuAcceleration,
        d = t.adaptive,
        f = t.roundOffsets,
        h = t.isFixed,
        m = s.x,
        b = m === void 0 ? 0 : m,
        y = s.y,
        v = y === void 0 ? 0 : y,
        x = typeof f == 'function' ? f({ x: b, y: v }) : { x: b, y: v };
    (b = x.x), (v = x.y);
    var T = s.hasOwnProperty('x'),
        D = s.hasOwnProperty('y'),
        I = wt,
        S = yt,
        z = window;
    if (d) {
        var N = sr(n),
            q = 'clientHeight',
            ne = 'clientWidth';
        if (
            (N === dt(n) &&
                ((N = Xt(n)),
                mn(N).position !== 'static' && l === 'absolute' && ((q = 'scrollHeight'), (ne = 'scrollWidth'))),
            (N = N),
            i === yt || ((i === wt || i === Ct) && o === io))
        ) {
            S = Lt;
            var $ = h && N === z && z.visualViewport ? z.visualViewport.height : N[q];
            (v -= $ - r.height), (v *= u ? 1 : -1);
        }
        if (i === wt || ((i === yt || i === Lt) && o === io)) {
            I = Ct;
            var oe = h && N === z && z.visualViewport ? z.visualViewport.width : N[ne];
            (b -= oe - r.width), (b *= u ? 1 : -1);
        }
    }
    var me = Object.assign({ position: l }, d && GP),
        Te = f === !0 ? qP({ x: b, y: v }, dt(n)) : { x: b, y: v };
    if (((b = Te.x), (v = Te.y), u)) {
        var ge;
        return Object.assign(
            {},
            me,
            ((ge = {}),
            (ge[S] = D ? '0' : ''),
            (ge[I] = T ? '0' : ''),
            (ge.transform =
                (z.devicePixelRatio || 1) <= 1
                    ? 'translate(' + b + 'px, ' + v + 'px)'
                    : 'translate3d(' + b + 'px, ' + v + 'px, 0)'),
            ge),
        );
    }
    return Object.assign(
        {},
        me,
        ((e = {}), (e[S] = D ? v + 'px' : ''), (e[I] = T ? b + 'px' : ''), (e.transform = ''), e),
    );
}
function YP(t) {
    var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        i = r === void 0 ? !0 : r,
        o = n.adaptive,
        s = o === void 0 ? !0 : o,
        l = n.roundOffsets,
        u = l === void 0 ? !0 : l,
        d = {
            placement: Wt(e.placement),
            variation: Gn(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i,
            isFixed: e.options.strategy === 'fixed',
        };
    e.modifiersData.popperOffsets != null &&
        (e.styles.popper = Object.assign(
            {},
            e.styles.popper,
            sw(
                Object.assign({}, d, {
                    offsets: e.modifiersData.popperOffsets,
                    position: e.options.strategy,
                    adaptive: s,
                    roundOffsets: u,
                }),
            ),
        )),
        e.modifiersData.arrow != null &&
            (e.styles.arrow = Object.assign(
                {},
                e.styles.arrow,
                sw(
                    Object.assign({}, d, {
                        offsets: e.modifiersData.arrow,
                        position: 'absolute',
                        adaptive: !1,
                        roundOffsets: u,
                    }),
                ),
            )),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, { 'data-popper-placement': e.placement }));
}
var aw = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: YP, data: {} };
var Ec = { passive: !0 };
function JP(t) {
    var e = t.state,
        n = t.instance,
        r = t.options,
        i = r.scroll,
        o = i === void 0 ? !0 : i,
        s = r.resize,
        l = s === void 0 ? !0 : s,
        u = dt(e.elements.popper),
        d = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return (
        o &&
            d.forEach(function (f) {
                f.addEventListener('scroll', n.update, Ec);
            }),
        l && u.addEventListener('resize', n.update, Ec),
        function () {
            o &&
                d.forEach(function (f) {
                    f.removeEventListener('scroll', n.update, Ec);
                }),
                l && u.removeEventListener('resize', n.update, Ec);
        }
    );
}
var lw = { name: 'eventListeners', enabled: !0, phase: 'write', fn: function () {}, effect: JP, data: {} };
var XP = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
function jo(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
        return XP[e];
    });
}
var ZP = { start: 'end', end: 'start' };
function vc(t) {
    return t.replace(/start|end/g, function (e) {
        return ZP[e];
    });
}
function co(t) {
    var e = dt(t),
        n = e.pageXOffset,
        r = e.pageYOffset;
    return { scrollLeft: n, scrollTop: r };
}
function uo(t) {
    return Vn(Xt(t)).left + co(t).scrollLeft;
}
function Vp(t, e) {
    var n = dt(t),
        r = Xt(t),
        i = n.visualViewport,
        o = r.clientWidth,
        s = r.clientHeight,
        l = 0,
        u = 0;
    if (i) {
        (o = i.width), (s = i.height);
        var d = ra();
        (d || (!d && e === 'fixed')) && ((l = i.offsetLeft), (u = i.offsetTop));
    }
    return { width: o, height: s, x: l + uo(t), y: u };
}
function Gp(t) {
    var e,
        n = Xt(t),
        r = co(t),
        i = (e = t.ownerDocument) == null ? void 0 : e.body,
        o = or(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        s = or(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        l = -r.scrollLeft + uo(t),
        u = -r.scrollTop;
    return (
        mn(i || n).direction === 'rtl' && (l += or(n.clientWidth, i ? i.clientWidth : 0) - o),
        { width: o, height: s, x: l, y: u }
    );
}
function fo(t) {
    var e = mn(t),
        n = e.overflow,
        r = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function wc(t) {
    return ['html', 'body', '#document'].indexOf(Ut(t)) >= 0 ? t.ownerDocument.body : Dt(t) && fo(t) ? t : wc(Kr(t));
}
function Ei(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = wc(t),
        i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
        o = dt(r),
        s = i ? [o].concat(o.visualViewport || [], fo(r) ? r : []) : r,
        l = e.concat(s);
    return i ? l : l.concat(Ei(Kr(s)));
}
function Qo(t) {
    return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function jP(t, e) {
    var n = Vn(t, !1, e === 'fixed');
    return (
        (n.top = n.top + t.clientTop),
        (n.left = n.left + t.clientLeft),
        (n.bottom = n.top + t.clientHeight),
        (n.right = n.left + t.clientWidth),
        (n.width = t.clientWidth),
        (n.height = t.clientHeight),
        (n.x = n.left),
        (n.y = n.top),
        n
    );
}
function cw(t, e, n) {
    return e === bc ? Qo(Vp(t, n)) : Kn(e) ? jP(e, n) : Qo(Gp(Xt(t)));
}
function QP(t) {
    var e = Ei(Kr(t)),
        n = ['absolute', 'fixed'].indexOf(mn(t).position) >= 0,
        r = n && Dt(t) ? sr(t) : t;
    return Kn(r)
        ? e.filter(function (i) {
              return Kn(i) && ia(i, r) && Ut(i) !== 'body';
          })
        : [];
}
function qp(t, e, n, r) {
    var i = e === 'clippingParents' ? QP(t) : [].concat(e),
        o = [].concat(i, [n]),
        s = o[0],
        l = o.reduce(
            function (u, d) {
                var f = cw(t, d, r);
                return (
                    (u.top = or(f.top, u.top)),
                    (u.right = oo(f.right, u.right)),
                    (u.bottom = oo(f.bottom, u.bottom)),
                    (u.left = or(f.left, u.left)),
                    u
                );
            },
            cw(t, s, r),
        );
    return (l.width = l.right - l.left), (l.height = l.bottom - l.top), (l.x = l.left), (l.y = l.top), l;
}
function la(t) {
    var e = t.reference,
        n = t.element,
        r = t.placement,
        i = r ? Wt(r) : null,
        o = r ? Gn(r) : null,
        s = e.x + e.width / 2 - n.width / 2,
        l = e.y + e.height / 2 - n.height / 2,
        u;
    switch (i) {
        case yt:
            u = { x: s, y: e.y - n.height };
            break;
        case Lt:
            u = { x: s, y: e.y + e.height };
            break;
        case Ct:
            u = { x: e.x + e.width, y: l };
            break;
        case wt:
            u = { x: e.x - n.width, y: l };
            break;
        default:
            u = { x: e.x, y: e.y };
    }
    var d = i ? ao(i) : null;
    if (d != null) {
        var f = d === 'y' ? 'height' : 'width';
        switch (o) {
            case Ur:
                u[d] = u[d] - (e[f] / 2 - n[f] / 2);
                break;
            case io:
                u[d] = u[d] + (e[f] / 2 - n[f] / 2);
                break;
            default:
        }
    }
    return u;
}
function ar(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = r === void 0 ? t.placement : r,
        o = n.strategy,
        s = o === void 0 ? t.strategy : o,
        l = n.boundary,
        u = l === void 0 ? ew : l,
        d = n.rootBoundary,
        f = d === void 0 ? bc : d,
        h = n.elementContext,
        m = h === void 0 ? Jo : h,
        b = n.altBoundary,
        y = b === void 0 ? !1 : b,
        v = n.padding,
        x = v === void 0 ? 0 : v,
        T = sa(typeof x != 'number' ? x : aa(x, yi)),
        D = m === Jo ? tw : Jo,
        I = t.rects.popper,
        S = t.elements[y ? D : m],
        z = qp(Kn(S) ? S : S.contextElement || Xt(t.elements.popper), u, f, s),
        N = Vn(t.elements.reference),
        q = la({ reference: N, element: I, strategy: 'absolute', placement: i }),
        ne = Qo(Object.assign({}, I, q)),
        $ = m === Jo ? ne : N,
        oe = {
            top: z.top - $.top + T.top,
            bottom: $.bottom - z.bottom + T.bottom,
            left: z.left - $.left + T.left,
            right: $.right - z.right + T.right,
        },
        me = t.modifiersData.offset;
    if (m === Jo && me) {
        var Te = me[i];
        Object.keys(oe).forEach(function (ge) {
            var Me = [Ct, Lt].indexOf(ge) >= 0 ? 1 : -1,
                Ee = [yt, Lt].indexOf(ge) >= 0 ? 'y' : 'x';
            oe[ge] += Te[Ee] * Me;
        });
    }
    return oe;
}
function Yp(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = n.boundary,
        o = n.rootBoundary,
        s = n.padding,
        l = n.flipVariations,
        u = n.allowedAutoPlacements,
        d = u === void 0 ? yc : u,
        f = Gn(r),
        h = f
            ? l
                ? Wp
                : Wp.filter(function (y) {
                      return Gn(y) === f;
                  })
            : yi,
        m = h.filter(function (y) {
            return d.indexOf(y) >= 0;
        });
    m.length === 0 && (m = h);
    var b = m.reduce(function (y, v) {
        return (y[v] = ar(t, { placement: v, boundary: i, rootBoundary: o, padding: s })[Wt(v)]), y;
    }, {});
    return Object.keys(b).sort(function (y, v) {
        return b[y] - b[v];
    });
}
function eB(t) {
    if (Wt(t) === gc) return [];
    var e = jo(t);
    return [vc(t), e, vc(e)];
}
function tB(t) {
    var e = t.state,
        n = t.options,
        r = t.name;
    if (!e.modifiersData[r]._skip) {
        for (
            var i = n.mainAxis,
                o = i === void 0 ? !0 : i,
                s = n.altAxis,
                l = s === void 0 ? !0 : s,
                u = n.fallbackPlacements,
                d = n.padding,
                f = n.boundary,
                h = n.rootBoundary,
                m = n.altBoundary,
                b = n.flipVariations,
                y = b === void 0 ? !0 : b,
                v = n.allowedAutoPlacements,
                x = e.options.placement,
                T = Wt(x),
                D = T === x,
                I = u || (D || !y ? [jo(x)] : eB(x)),
                S = [x].concat(I).reduce(function (We, He) {
                    return We.concat(
                        Wt(He) === gc
                            ? Yp(e, {
                                  placement: He,
                                  boundary: f,
                                  rootBoundary: h,
                                  padding: d,
                                  flipVariations: y,
                                  allowedAutoPlacements: v,
                              })
                            : He,
                    );
                }, []),
                z = e.rects.reference,
                N = e.rects.popper,
                q = new Map(),
                ne = !0,
                $ = S[0],
                oe = 0;
            oe < S.length;
            oe++
        ) {
            var me = S[oe],
                Te = Wt(me),
                ge = Gn(me) === Ur,
                Me = [yt, Lt].indexOf(Te) >= 0,
                Ee = Me ? 'width' : 'height',
                P = ar(e, { placement: me, boundary: f, rootBoundary: h, altBoundary: m, padding: d }),
                O = Me ? (ge ? Ct : wt) : ge ? Lt : yt;
            z[Ee] > N[Ee] && (O = jo(O));
            var R = jo(O),
                V = [];
            if (
                (o && V.push(P[Te] <= 0),
                l && V.push(P[O] <= 0, P[R] <= 0),
                V.every(function (We) {
                    return We;
                }))
            ) {
                ($ = me), (ne = !1);
                break;
            }
            q.set(me, V);
        }
        if (ne)
            for (
                var Q = y ? 3 : 1,
                    he = function (He) {
                        var Xe = S.find(function (xt) {
                            var Pt = q.get(xt);
                            if (Pt)
                                return Pt.slice(0, He).every(function (De) {
                                    return De;
                                });
                        });
                        if (Xe) return ($ = Xe), 'break';
                    },
                    xe = Q;
                xe > 0;
                xe--
            ) {
                var Ue = he(xe);
                if (Ue === 'break') break;
            }
        e.placement !== $ && ((e.modifiersData[r]._skip = !0), (e.placement = $), (e.reset = !0));
    }
}
var uw = { name: 'flip', enabled: !0, phase: 'main', fn: tB, requiresIfExists: ['offset'], data: { _skip: !1 } };
function dw(t, e, n) {
    return (
        n === void 0 && (n = { x: 0, y: 0 }),
        {
            top: t.top - e.height - n.y,
            right: t.right - e.width + n.x,
            bottom: t.bottom - e.height + n.y,
            left: t.left - e.width - n.x,
        }
    );
}
function fw(t) {
    return [yt, Ct, Lt, wt].some(function (e) {
        return t[e] >= 0;
    });
}
function nB(t) {
    var e = t.state,
        n = t.name,
        r = e.rects.reference,
        i = e.rects.popper,
        o = e.modifiersData.preventOverflow,
        s = ar(e, { elementContext: 'reference' }),
        l = ar(e, { altBoundary: !0 }),
        u = dw(s, r),
        d = dw(l, i, o),
        f = fw(u),
        h = fw(d);
    (e.modifiersData[n] = {
        referenceClippingOffsets: u,
        popperEscapeOffsets: d,
        isReferenceHidden: f,
        hasPopperEscaped: h,
    }),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, {
            'data-popper-reference-hidden': f,
            'data-popper-escaped': h,
        }));
}
var pw = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn: nB };
function rB(t, e, n) {
    var r = Wt(t),
        i = [wt, yt].indexOf(r) >= 0 ? -1 : 1,
        o = typeof n == 'function' ? n(Object.assign({}, e, { placement: t })) : n,
        s = o[0],
        l = o[1];
    return (s = s || 0), (l = (l || 0) * i), [wt, Ct].indexOf(r) >= 0 ? { x: l, y: s } : { x: s, y: l };
}
function iB(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.offset,
        o = i === void 0 ? [0, 0] : i,
        s = yc.reduce(function (f, h) {
            return (f[h] = rB(h, e.rects, o)), f;
        }, {}),
        l = s[e.placement],
        u = l.x,
        d = l.y;
    e.modifiersData.popperOffsets != null &&
        ((e.modifiersData.popperOffsets.x += u), (e.modifiersData.popperOffsets.y += d)),
        (e.modifiersData[r] = s);
}
var hw = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: iB };
function oB(t) {
    var e = t.state,
        n = t.name;
    e.modifiersData[n] = la({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: 'absolute',
        placement: e.placement,
    });
}
var mw = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: oB, data: {} };
function Jp(t) {
    return t === 'x' ? 'y' : 'x';
}
function sB(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.mainAxis,
        o = i === void 0 ? !0 : i,
        s = n.altAxis,
        l = s === void 0 ? !1 : s,
        u = n.boundary,
        d = n.rootBoundary,
        f = n.altBoundary,
        h = n.padding,
        m = n.tether,
        b = m === void 0 ? !0 : m,
        y = n.tetherOffset,
        v = y === void 0 ? 0 : y,
        x = ar(e, { boundary: u, rootBoundary: d, padding: h, altBoundary: f }),
        T = Wt(e.placement),
        D = Gn(e.placement),
        I = !D,
        S = ao(T),
        z = Jp(S),
        N = e.modifiersData.popperOffsets,
        q = e.rects.reference,
        ne = e.rects.popper,
        $ = typeof v == 'function' ? v(Object.assign({}, e.rects, { placement: e.placement })) : v,
        oe = typeof $ == 'number' ? { mainAxis: $, altAxis: $ } : Object.assign({ mainAxis: 0, altAxis: 0 }, $),
        me = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
        Te = { x: 0, y: 0 };
    if (N) {
        if (o) {
            var ge,
                Me = S === 'y' ? yt : wt,
                Ee = S === 'y' ? Lt : Ct,
                P = S === 'y' ? 'height' : 'width',
                O = N[S],
                R = O + x[Me],
                V = O - x[Ee],
                Q = b ? -ne[P] / 2 : 0,
                he = D === Ur ? q[P] : ne[P],
                xe = D === Ur ? -ne[P] : -q[P],
                Ue = e.elements.arrow,
                We = b && Ue ? so(Ue) : { width: 0, height: 0 },
                He = e.modifiersData['arrow#persistent'] ? e.modifiersData['arrow#persistent'].padding : oa(),
                Xe = He[Me],
                xt = He[Ee],
                Pt = lo(0, q[P], We[P]),
                De = I ? q[P] / 2 - Q - Pt - Xe - oe.mainAxis : he - Pt - Xe - oe.mainAxis,
                _t = I ? -q[P] / 2 + Q + Pt + xt + oe.mainAxis : xe + Pt + xt + oe.mainAxis,
                Zt = e.elements.arrow && sr(e.elements.arrow),
                st = Zt ? (S === 'y' ? Zt.clientTop || 0 : Zt.clientLeft || 0) : 0,
                jt = (ge = me?.[S]) != null ? ge : 0,
                St = O + De - jt - st,
                Nt = O + _t - jt,
                ft = lo(b ? oo(R, St) : R, O, b ? or(V, Nt) : V);
            (N[S] = ft), (Te[S] = ft - O);
        }
        if (l) {
            var be,
                Kt = S === 'x' ? yt : wt,
                ee = S === 'x' ? Lt : Ct,
                Ce = N[z],
                Ke = z === 'y' ? 'height' : 'width',
                Re = Ce + x[Kt],
                mt = Ce - x[ee],
                Ot = [yt, wt].indexOf(T) !== -1,
                J = (be = me?.[z]) != null ? be : 0,
                re = Ot ? Re : Ce - q[Ke] - ne[Ke] - J + oe.altAxis,
                H = Ot ? Ce + q[Ke] + ne[Ke] - J - oe.altAxis : mt,
                Y = b && Ot ? iw(re, Ce, H) : lo(b ? re : Re, Ce, b ? H : mt);
            (N[z] = Y), (Te[z] = Y - Ce);
        }
        e.modifiersData[r] = Te;
    }
}
var gw = { name: 'preventOverflow', enabled: !0, phase: 'main', fn: sB, requiresIfExists: ['offset'] };
function Xp(t) {
    return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function Zp(t) {
    return t === dt(t) || !Dt(t) ? co(t) : Xp(t);
}
function aB(t) {
    var e = t.getBoundingClientRect(),
        n = Wr(e.width) / t.offsetWidth || 1,
        r = Wr(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1;
}
function jp(t, e, n) {
    n === void 0 && (n = !1);
    var r = Dt(e),
        i = Dt(e) && aB(e),
        o = Xt(e),
        s = Vn(t, i, n),
        l = { scrollLeft: 0, scrollTop: 0 },
        u = { x: 0, y: 0 };
    return (
        (r || (!r && !n)) &&
            ((Ut(e) !== 'body' || fo(o)) && (l = Zp(e)),
            Dt(e) ? ((u = Vn(e, !0)), (u.x += e.clientLeft), (u.y += e.clientTop)) : o && (u.x = uo(o))),
        { x: s.left + l.scrollLeft - u.x, y: s.top + l.scrollTop - u.y, width: s.width, height: s.height }
    );
}
function lB(t) {
    var e = new Map(),
        n = new Set(),
        r = [];
    t.forEach(function (o) {
        e.set(o.name, o);
    });
    function i(o) {
        n.add(o.name);
        var s = [].concat(o.requires || [], o.requiresIfExists || []);
        s.forEach(function (l) {
            if (!n.has(l)) {
                var u = e.get(l);
                u && i(u);
            }
        }),
            r.push(o);
    }
    return (
        t.forEach(function (o) {
            n.has(o.name) || i(o);
        }),
        r
    );
}
function Qp(t) {
    var e = lB(t);
    return nw.reduce(function (n, r) {
        return n.concat(
            e.filter(function (i) {
                return i.phase === r;
            }),
        );
    }, []);
}
function eh(t) {
    var e;
    return function () {
        return (
            e ||
                (e = new Promise(function (n) {
                    Promise.resolve().then(function () {
                        (e = void 0), n(t());
                    });
                })),
            e
        );
    };
}
function th(t) {
    var e = t.reduce(function (n, r) {
        var i = n[r.name];
        return (
            (n[r.name] = i
                ? Object.assign({}, i, r, {
                      options: Object.assign({}, i.options, r.options),
                      data: Object.assign({}, i.data, r.data),
                  })
                : r),
            n
        );
    }, {});
    return Object.keys(e).map(function (n) {
        return e[n];
    });
}
var bw = { placement: 'bottom', modifiers: [], strategy: 'absolute' };
function yw() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return !e.some(function (r) {
        return !(r && typeof r.getBoundingClientRect == 'function');
    });
}
function Ew(t) {
    t === void 0 && (t = {});
    var e = t,
        n = e.defaultModifiers,
        r = n === void 0 ? [] : n,
        i = e.defaultOptions,
        o = i === void 0 ? bw : i;
    return function (l, u, d) {
        d === void 0 && (d = o);
        var f = {
                placement: 'bottom',
                orderedModifiers: [],
                options: Object.assign({}, bw, o),
                modifiersData: {},
                elements: { reference: l, popper: u },
                attributes: {},
                styles: {},
            },
            h = [],
            m = !1,
            b = {
                state: f,
                setOptions: function (T) {
                    var D = typeof T == 'function' ? T(f.options) : T;
                    v(),
                        (f.options = Object.assign({}, o, f.options, D)),
                        (f.scrollParents = {
                            reference: Kn(l) ? Ei(l) : l.contextElement ? Ei(l.contextElement) : [],
                            popper: Ei(u),
                        });
                    var I = Qp(th([].concat(r, f.options.modifiers)));
                    return (
                        (f.orderedModifiers = I.filter(function (S) {
                            return S.enabled;
                        })),
                        y(),
                        b.update()
                    );
                },
                forceUpdate: function () {
                    if (!m) {
                        var T = f.elements,
                            D = T.reference,
                            I = T.popper;
                        if (yw(D, I)) {
                            (f.rects = { reference: jp(D, sr(I), f.options.strategy === 'fixed'), popper: so(I) }),
                                (f.reset = !1),
                                (f.placement = f.options.placement),
                                f.orderedModifiers.forEach(function (oe) {
                                    return (f.modifiersData[oe.name] = Object.assign({}, oe.data));
                                });
                            for (var S = 0; S < f.orderedModifiers.length; S++) {
                                if (f.reset === !0) {
                                    (f.reset = !1), (S = -1);
                                    continue;
                                }
                                var z = f.orderedModifiers[S],
                                    N = z.fn,
                                    q = z.options,
                                    ne = q === void 0 ? {} : q,
                                    $ = z.name;
                                typeof N == 'function' && (f = N({ state: f, options: ne, name: $, instance: b }) || f);
                            }
                        }
                    }
                },
                update: eh(function () {
                    return new Promise(function (x) {
                        b.forceUpdate(), x(f);
                    });
                }),
                destroy: function () {
                    v(), (m = !0);
                },
            };
        if (!yw(l, u)) return b;
        b.setOptions(d).then(function (x) {
            !m && d.onFirstUpdate && d.onFirstUpdate(x);
        });
        function y() {
            f.orderedModifiers.forEach(function (x) {
                var T = x.name,
                    D = x.options,
                    I = D === void 0 ? {} : D,
                    S = x.effect;
                if (typeof S == 'function') {
                    var z = S({ state: f, name: T, instance: b, options: I }),
                        N = function () {};
                    h.push(z || N);
                }
            });
        }
        function v() {
            h.forEach(function (x) {
                return x();
            }),
                (h = []);
        }
        return b;
    };
}
var cB = [lw, mw, aw, na, hw, uw, gw, ow, pw],
    nh = Ew({ defaultModifiers: cB });
var uB = 'tippy-box',
    kw = 'tippy-content',
    dB = 'tippy-backdrop',
    Nw = 'tippy-arrow',
    Ow = 'tippy-svg-arrow',
    po = { passive: !0, capture: !0 },
    Rw = function () {
        return document.body;
    };
function rh(t, e, n) {
    if (Array.isArray(t)) {
        var r = t[e];
        return r ?? (Array.isArray(n) ? n[e] : n);
    }
    return t;
}
function ch(t, e) {
    var n = {}.toString.call(t);
    return n.indexOf('[object') === 0 && n.indexOf(e + ']') > -1;
}
function Iw(t, e) {
    return typeof t == 'function' ? t.apply(void 0, e) : t;
}
function vw(t, e) {
    if (e === 0) return t;
    var n;
    return function (r) {
        clearTimeout(n),
            (n = setTimeout(function () {
                t(r);
            }, e));
    };
}
function fB(t) {
    return t.split(/\s+/).filter(Boolean);
}
function es(t) {
    return [].concat(t);
}
function ww(t, e) {
    t.indexOf(e) === -1 && t.push(e);
}
function pB(t) {
    return t.filter(function (e, n) {
        return t.indexOf(e) === n;
    });
}
function hB(t) {
    return t.split('-')[0];
}
function _c(t) {
    return [].slice.call(t);
}
function xw(t) {
    return Object.keys(t).reduce(function (e, n) {
        return t[n] !== void 0 && (e[n] = t[n]), e;
    }, {});
}
function ca() {
    return document.createElement('div');
}
function Sc(t) {
    return ['Element', 'Fragment'].some(function (e) {
        return ch(t, e);
    });
}
function mB(t) {
    return ch(t, 'NodeList');
}
function gB(t) {
    return ch(t, 'MouseEvent');
}
function bB(t) {
    return !!(t && t._tippy && t._tippy.reference === t);
}
function yB(t) {
    return Sc(t) ? [t] : mB(t) ? _c(t) : Array.isArray(t) ? t : _c(document.querySelectorAll(t));
}
function ih(t, e) {
    t.forEach(function (n) {
        n && (n.style.transitionDuration = e + 'ms');
    });
}
function _w(t, e) {
    t.forEach(function (n) {
        n && n.setAttribute('data-state', e);
    });
}
function EB(t) {
    var e,
        n = es(t),
        r = n[0];
    return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function vB(t, e) {
    var n = e.clientX,
        r = e.clientY;
    return t.every(function (i) {
        var o = i.popperRect,
            s = i.popperState,
            l = i.props,
            u = l.interactiveBorder,
            d = hB(s.placement),
            f = s.modifiersData.offset;
        if (!f) return !0;
        var h = d === 'bottom' ? f.top.y : 0,
            m = d === 'top' ? f.bottom.y : 0,
            b = d === 'right' ? f.left.x : 0,
            y = d === 'left' ? f.right.x : 0,
            v = o.top - r + h > u,
            x = r - o.bottom - m > u,
            T = o.left - n + b > u,
            D = n - o.right - y > u;
        return v || x || T || D;
    });
}
function oh(t, e, n) {
    var r = e + 'EventListener';
    ['transitionend', 'webkitTransitionEnd'].forEach(function (i) {
        t[r](i, n);
    });
}
function Sw(t, e) {
    for (var n = e; n; ) {
        var r;
        if (t.contains(n)) return !0;
        n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
    }
    return !1;
}
var yr = { isTouch: !1 },
    Tw = 0;
function wB() {
    yr.isTouch || ((yr.isTouch = !0), window.performance && document.addEventListener('mousemove', Lw));
}
function Lw() {
    var t = performance.now();
    t - Tw < 20 && ((yr.isTouch = !1), document.removeEventListener('mousemove', Lw)), (Tw = t);
}
function xB() {
    var t = document.activeElement;
    if (bB(t)) {
        var e = t._tippy;
        t.blur && !e.state.isVisible && t.blur();
    }
}
function _B() {
    document.addEventListener('touchstart', wB, po), window.addEventListener('blur', xB);
}
var SB = typeof window < 'u' && typeof document < 'u',
    TB = SB ? !!window.msCrypto : !1;
var MB = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 },
    AB = {
        allowHTML: !1,
        animation: 'fade',
        arrow: !0,
        content: '',
        inertia: !1,
        maxWidth: 350,
        role: 'tooltip',
        theme: '',
        zIndex: 9999,
    },
    lr = Object.assign(
        {
            appendTo: Rw,
            aria: { content: 'auto', expanded: 'auto' },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: !0,
            ignoreAttributes: !1,
            interactive: !1,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: '',
            offset: [0, 10],
            onAfterUpdate: function () {},
            onBeforeUpdate: function () {},
            onCreate: function () {},
            onDestroy: function () {},
            onHidden: function () {},
            onHide: function () {},
            onMount: function () {},
            onShow: function () {},
            onShown: function () {},
            onTrigger: function () {},
            onUntrigger: function () {},
            onClickOutside: function () {},
            placement: 'top',
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: !1,
            touch: !0,
            trigger: 'mouseenter focus',
            triggerTarget: null,
        },
        MB,
        AB,
    ),
    CB = Object.keys(lr),
    kB = function (e) {
        var n = Object.keys(e);
        n.forEach(function (r) {
            lr[r] = e[r];
        });
    };
function Dw(t) {
    var e = t.plugins || [],
        n = e.reduce(function (r, i) {
            var o = i.name,
                s = i.defaultValue;
            if (o) {
                var l;
                r[o] = t[o] !== void 0 ? t[o] : (l = lr[o]) != null ? l : s;
            }
            return r;
        }, {});
    return Object.assign({}, t, n);
}
function NB(t, e) {
    var n = e ? Object.keys(Dw(Object.assign({}, lr, { plugins: e }))) : CB,
        r = n.reduce(function (i, o) {
            var s = (t.getAttribute('data-tippy-' + o) || '').trim();
            if (!s) return i;
            if (o === 'content') i[o] = s;
            else
                try {
                    i[o] = JSON.parse(s);
                } catch {
                    i[o] = s;
                }
            return i;
        }, {});
    return r;
}
function Mw(t, e) {
    var n = Object.assign({}, e, { content: Iw(e.content, [t]) }, e.ignoreAttributes ? {} : NB(t, e.plugins));
    return (
        (n.aria = Object.assign({}, lr.aria, n.aria)),
        (n.aria = {
            expanded: n.aria.expanded === 'auto' ? e.interactive : n.aria.expanded,
            content: n.aria.content === 'auto' ? (e.interactive ? null : 'describedby') : n.aria.content,
        }),
        n
    );
}
var OB = function () {
    return 'innerHTML';
};
function ah(t, e) {
    t[OB()] = e;
}
function Aw(t) {
    var e = ca();
    return t === !0 ? (e.className = Nw) : ((e.className = Ow), Sc(t) ? e.appendChild(t) : ah(e, t)), e;
}
function Cw(t, e) {
    Sc(e.content)
        ? (ah(t, ''), t.appendChild(e.content))
        : typeof e.content != 'function' && (e.allowHTML ? ah(t, e.content) : (t.textContent = e.content));
}
function lh(t) {
    var e = t.firstElementChild,
        n = _c(e.children);
    return {
        box: e,
        content: n.find(function (r) {
            return r.classList.contains(kw);
        }),
        arrow: n.find(function (r) {
            return r.classList.contains(Nw) || r.classList.contains(Ow);
        }),
        backdrop: n.find(function (r) {
            return r.classList.contains(dB);
        }),
    };
}
function Pw(t) {
    var e = ca(),
        n = ca();
    (n.className = uB), n.setAttribute('data-state', 'hidden'), n.setAttribute('tabindex', '-1');
    var r = ca();
    (r.className = kw),
        r.setAttribute('data-state', 'hidden'),
        Cw(r, t.props),
        e.appendChild(n),
        n.appendChild(r),
        i(t.props, t.props);
    function i(o, s) {
        var l = lh(e),
            u = l.box,
            d = l.content,
            f = l.arrow;
        s.theme ? u.setAttribute('data-theme', s.theme) : u.removeAttribute('data-theme'),
            typeof s.animation == 'string'
                ? u.setAttribute('data-animation', s.animation)
                : u.removeAttribute('data-animation'),
            s.inertia ? u.setAttribute('data-inertia', '') : u.removeAttribute('data-inertia'),
            (u.style.maxWidth = typeof s.maxWidth == 'number' ? s.maxWidth + 'px' : s.maxWidth),
            s.role ? u.setAttribute('role', s.role) : u.removeAttribute('role'),
            (o.content !== s.content || o.allowHTML !== s.allowHTML) && Cw(d, t.props),
            s.arrow
                ? f
                    ? o.arrow !== s.arrow && (u.removeChild(f), u.appendChild(Aw(s.arrow)))
                    : u.appendChild(Aw(s.arrow))
                : f && u.removeChild(f);
    }
    return { popper: e, onUpdate: i };
}
Pw.$$tippy = !0;
var RB = 1,
    xc = [],
    sh = [];
function IB(t, e) {
    var n = Mw(t, Object.assign({}, lr, Dw(xw(e)))),
        r,
        i,
        o,
        s = !1,
        l = !1,
        u = !1,
        d = !1,
        f,
        h,
        m,
        b = [],
        y = vw(St, n.interactiveDebounce),
        v,
        x = RB++,
        T = null,
        D = pB(n.plugins),
        I = { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 },
        S = {
            id: x,
            reference: t,
            popper: ca(),
            popperInstance: T,
            props: n,
            state: I,
            plugins: D,
            clearDelayTimeouts: re,
            setProps: H,
            setContent: Y,
            show: ue,
            hide: Ae,
            hideWithInteractivity: ct,
            enable: Ot,
            disable: J,
            unmount: Vt,
            destroy: Mi,
        };
    if (!n.render) return S;
    var z = n.render(S),
        N = z.popper,
        q = z.onUpdate;
    N.setAttribute('data-tippy-root', ''), (N.id = 'tippy-' + S.id), (S.popper = N), (t._tippy = S), (N._tippy = S);
    var ne = D.map(function (B) {
            return B.fn(S);
        }),
        $ = t.hasAttribute('aria-expanded');
    return (
        Zt(),
        Q(),
        O(),
        R('onCreate', [S]),
        n.showOnCreate && Re(),
        N.addEventListener('mouseenter', function () {
            S.props.interactive && S.state.isVisible && S.clearDelayTimeouts();
        }),
        N.addEventListener('mouseleave', function () {
            S.props.interactive && S.props.trigger.indexOf('mouseenter') >= 0 && Me().addEventListener('mousemove', y);
        }),
        S
    );
    function oe() {
        var B = S.props.touch;
        return Array.isArray(B) ? B : [B, 0];
    }
    function me() {
        return oe()[0] === 'hold';
    }
    function Te() {
        var B;
        return !!((B = S.props.render) != null && B.$$tippy);
    }
    function ge() {
        return v || t;
    }
    function Me() {
        var B = ge().parentNode;
        return B ? EB(B) : document;
    }
    function Ee() {
        return lh(N);
    }
    function P(B) {
        return (S.state.isMounted && !S.state.isVisible) || yr.isTouch || (f && f.type === 'focus')
            ? 0
            : rh(S.props.delay, B ? 0 : 1, lr.delay);
    }
    function O(B) {
        B === void 0 && (B = !1),
            (N.style.pointerEvents = S.props.interactive && !B ? '' : 'none'),
            (N.style.zIndex = '' + S.props.zIndex);
    }
    function R(B, le, _e) {
        if (
            (_e === void 0 && (_e = !0),
            ne.forEach(function (qe) {
                qe[B] && qe[B].apply(qe, le);
            }),
            _e)
        ) {
            var Ze;
            (Ze = S.props)[B].apply(Ze, le);
        }
    }
    function V() {
        var B = S.props.aria;
        if (B.content) {
            var le = 'aria-' + B.content,
                _e = N.id,
                Ze = es(S.props.triggerTarget || t);
            Ze.forEach(function (qe) {
                var Bt = qe.getAttribute(le);
                if (S.state.isVisible) qe.setAttribute(le, Bt ? Bt + ' ' + _e : _e);
                else {
                    var an = Bt && Bt.replace(_e, '').trim();
                    an ? qe.setAttribute(le, an) : qe.removeAttribute(le);
                }
            });
        }
    }
    function Q() {
        if (!($ || !S.props.aria.expanded)) {
            var B = es(S.props.triggerTarget || t);
            B.forEach(function (le) {
                S.props.interactive
                    ? le.setAttribute('aria-expanded', S.state.isVisible && le === ge() ? 'true' : 'false')
                    : le.removeAttribute('aria-expanded');
            });
        }
    }
    function he() {
        Me().removeEventListener('mousemove', y),
            (xc = xc.filter(function (B) {
                return B !== y;
            }));
    }
    function xe(B) {
        if (!(yr.isTouch && (u || B.type === 'mousedown'))) {
            var le = (B.composedPath && B.composedPath()[0]) || B.target;
            if (!(S.props.interactive && Sw(N, le))) {
                if (
                    es(S.props.triggerTarget || t).some(function (_e) {
                        return Sw(_e, le);
                    })
                ) {
                    if (yr.isTouch || (S.state.isVisible && S.props.trigger.indexOf('click') >= 0)) return;
                } else R('onClickOutside', [S, B]);
                S.props.hideOnClick === !0 &&
                    (S.clearDelayTimeouts(),
                    S.hide(),
                    (l = !0),
                    setTimeout(function () {
                        l = !1;
                    }),
                    S.state.isMounted || Xe());
            }
        }
    }
    function Ue() {
        u = !0;
    }
    function We() {
        u = !1;
    }
    function He() {
        var B = Me();
        B.addEventListener('mousedown', xe, !0),
            B.addEventListener('touchend', xe, po),
            B.addEventListener('touchstart', We, po),
            B.addEventListener('touchmove', Ue, po);
    }
    function Xe() {
        var B = Me();
        B.removeEventListener('mousedown', xe, !0),
            B.removeEventListener('touchend', xe, po),
            B.removeEventListener('touchstart', We, po),
            B.removeEventListener('touchmove', Ue, po);
    }
    function xt(B, le) {
        De(B, function () {
            !S.state.isVisible && N.parentNode && N.parentNode.contains(N) && le();
        });
    }
    function Pt(B, le) {
        De(B, le);
    }
    function De(B, le) {
        var _e = Ee().box;
        function Ze(qe) {
            qe.target === _e && (oh(_e, 'remove', Ze), le());
        }
        if (B === 0) return le();
        oh(_e, 'remove', h), oh(_e, 'add', Ze), (h = Ze);
    }
    function _t(B, le, _e) {
        _e === void 0 && (_e = !1);
        var Ze = es(S.props.triggerTarget || t);
        Ze.forEach(function (qe) {
            qe.addEventListener(B, le, _e), b.push({ node: qe, eventType: B, handler: le, options: _e });
        });
    }
    function Zt() {
        me() && (_t('touchstart', jt, { passive: !0 }), _t('touchend', Nt, { passive: !0 })),
            fB(S.props.trigger).forEach(function (B) {
                if (B !== 'manual')
                    switch ((_t(B, jt), B)) {
                        case 'mouseenter':
                            _t('mouseleave', Nt);
                            break;
                        case 'focus':
                            _t(TB ? 'focusout' : 'blur', ft);
                            break;
                        case 'focusin':
                            _t('focusout', ft);
                            break;
                    }
            });
    }
    function st() {
        b.forEach(function (B) {
            var le = B.node,
                _e = B.eventType,
                Ze = B.handler,
                qe = B.options;
            le.removeEventListener(_e, Ze, qe);
        }),
            (b = []);
    }
    function jt(B) {
        var le,
            _e = !1;
        if (!(!S.state.isEnabled || be(B) || l)) {
            var Ze = ((le = f) == null ? void 0 : le.type) === 'focus';
            (f = B),
                (v = B.currentTarget),
                Q(),
                !S.state.isVisible &&
                    gB(B) &&
                    xc.forEach(function (qe) {
                        return qe(B);
                    }),
                B.type === 'click' &&
                (S.props.trigger.indexOf('mouseenter') < 0 || s) &&
                S.props.hideOnClick !== !1 &&
                S.state.isVisible
                    ? (_e = !0)
                    : Re(B),
                B.type === 'click' && (s = !_e),
                _e && !Ze && mt(B);
        }
    }
    function St(B) {
        var le = B.target,
            _e = ge().contains(le) || N.contains(le);
        if (!(B.type === 'mousemove' && _e)) {
            var Ze = Ke()
                .concat(N)
                .map(function (qe) {
                    var Bt,
                        an = qe._tippy,
                        qr = (Bt = an.popperInstance) == null ? void 0 : Bt.state;
                    return qr ? { popperRect: qe.getBoundingClientRect(), popperState: qr, props: n } : null;
                })
                .filter(Boolean);
            vB(Ze, B) && (he(), mt(B));
        }
    }
    function Nt(B) {
        var le = be(B) || (S.props.trigger.indexOf('click') >= 0 && s);
        if (!le) {
            if (S.props.interactive) {
                S.hideWithInteractivity(B);
                return;
            }
            mt(B);
        }
    }
    function ft(B) {
        (S.props.trigger.indexOf('focusin') < 0 && B.target !== ge()) ||
            (S.props.interactive && B.relatedTarget && N.contains(B.relatedTarget)) ||
            mt(B);
    }
    function be(B) {
        return yr.isTouch ? me() !== B.type.indexOf('touch') >= 0 : !1;
    }
    function Kt() {
        ee();
        var B = S.props,
            le = B.popperOptions,
            _e = B.placement,
            Ze = B.offset,
            qe = B.getReferenceClientRect,
            Bt = B.moveTransition,
            an = Te() ? lh(N).arrow : null,
            qr = qe ? { getBoundingClientRect: qe, contextElement: qe.contextElement || ge() } : t,
            Ta = {
                name: '$$tippy',
                enabled: !0,
                phase: 'beforeWrite',
                requires: ['computeStyles'],
                fn: function (Ai) {
                    var Yr = Ai.state;
                    if (Te()) {
                        var Iu = Ee(),
                            ms = Iu.box;
                        ['placement', 'reference-hidden', 'escaped'].forEach(function (Jr) {
                            Jr === 'placement'
                                ? ms.setAttribute('data-placement', Yr.placement)
                                : Yr.attributes.popper['data-popper-' + Jr]
                                  ? ms.setAttribute('data-' + Jr, '')
                                  : ms.removeAttribute('data-' + Jr);
                        }),
                            (Yr.attributes.popper = {});
                    }
                },
            },
            xr = [
                { name: 'offset', options: { offset: Ze } },
                { name: 'preventOverflow', options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } },
                { name: 'flip', options: { padding: 5 } },
                { name: 'computeStyles', options: { adaptive: !Bt } },
                Ta,
            ];
        Te() && an && xr.push({ name: 'arrow', options: { element: an, padding: 3 } }),
            xr.push.apply(xr, le?.modifiers || []),
            (S.popperInstance = nh(qr, N, Object.assign({}, le, { placement: _e, onFirstUpdate: m, modifiers: xr })));
    }
    function ee() {
        S.popperInstance && (S.popperInstance.destroy(), (S.popperInstance = null));
    }
    function Ce() {
        var B = S.props.appendTo,
            le,
            _e = ge();
        (S.props.interactive && B === Rw) || B === 'parent' ? (le = _e.parentNode) : (le = Iw(B, [_e])),
            le.contains(N) || le.appendChild(N),
            (S.state.isMounted = !0),
            Kt();
    }
    function Ke() {
        return _c(N.querySelectorAll('[data-tippy-root]'));
    }
    function Re(B) {
        S.clearDelayTimeouts(), B && R('onTrigger', [S, B]), He();
        var le = P(!0),
            _e = oe(),
            Ze = _e[0],
            qe = _e[1];
        yr.isTouch && Ze === 'hold' && qe && (le = qe),
            le
                ? (r = setTimeout(function () {
                      S.show();
                  }, le))
                : S.show();
    }
    function mt(B) {
        if ((S.clearDelayTimeouts(), R('onUntrigger', [S, B]), !S.state.isVisible)) {
            Xe();
            return;
        }
        if (
            !(
                S.props.trigger.indexOf('mouseenter') >= 0 &&
                S.props.trigger.indexOf('click') >= 0 &&
                ['mouseleave', 'mousemove'].indexOf(B.type) >= 0 &&
                s
            )
        ) {
            var le = P(!1);
            le
                ? (i = setTimeout(function () {
                      S.state.isVisible && S.hide();
                  }, le))
                : (o = requestAnimationFrame(function () {
                      S.hide();
                  }));
        }
    }
    function Ot() {
        S.state.isEnabled = !0;
    }
    function J() {
        S.hide(), (S.state.isEnabled = !1);
    }
    function re() {
        clearTimeout(r), clearTimeout(i), cancelAnimationFrame(o);
    }
    function H(B) {
        if (!S.state.isDestroyed) {
            R('onBeforeUpdate', [S, B]), st();
            var le = S.props,
                _e = Mw(t, Object.assign({}, le, xw(B), { ignoreAttributes: !0 }));
            (S.props = _e),
                Zt(),
                le.interactiveDebounce !== _e.interactiveDebounce && (he(), (y = vw(St, _e.interactiveDebounce))),
                le.triggerTarget && !_e.triggerTarget
                    ? es(le.triggerTarget).forEach(function (Ze) {
                          Ze.removeAttribute('aria-expanded');
                      })
                    : _e.triggerTarget && t.removeAttribute('aria-expanded'),
                Q(),
                O(),
                q && q(le, _e),
                S.popperInstance &&
                    (Kt(),
                    Ke().forEach(function (Ze) {
                        requestAnimationFrame(Ze._tippy.popperInstance.forceUpdate);
                    })),
                R('onAfterUpdate', [S, B]);
        }
    }
    function Y(B) {
        S.setProps({ content: B });
    }
    function ue() {
        var B = S.state.isVisible,
            le = S.state.isDestroyed,
            _e = !S.state.isEnabled,
            Ze = yr.isTouch && !S.props.touch,
            qe = rh(S.props.duration, 0, lr.duration);
        if (
            !(B || le || _e || Ze) &&
            !ge().hasAttribute('disabled') &&
            (R('onShow', [S], !1), S.props.onShow(S) !== !1)
        ) {
            if (
                ((S.state.isVisible = !0),
                Te() && (N.style.visibility = 'visible'),
                O(),
                He(),
                S.state.isMounted || (N.style.transition = 'none'),
                Te())
            ) {
                var Bt = Ee(),
                    an = Bt.box,
                    qr = Bt.content;
                ih([an, qr], 0);
            }
            (m = function () {
                var xr;
                if (!(!S.state.isVisible || d)) {
                    if (
                        ((d = !0),
                        N.offsetHeight,
                        (N.style.transition = S.props.moveTransition),
                        Te() && S.props.animation)
                    ) {
                        var hs = Ee(),
                            Ai = hs.box,
                            Yr = hs.content;
                        ih([Ai, Yr], qe), _w([Ai, Yr], 'visible');
                    }
                    V(),
                        Q(),
                        ww(sh, S),
                        (xr = S.popperInstance) == null || xr.forceUpdate(),
                        R('onMount', [S]),
                        S.props.animation &&
                            Te() &&
                            Pt(qe, function () {
                                (S.state.isShown = !0), R('onShown', [S]);
                            });
                }
            }),
                Ce();
        }
    }
    function Ae() {
        var B = !S.state.isVisible,
            le = S.state.isDestroyed,
            _e = !S.state.isEnabled,
            Ze = rh(S.props.duration, 1, lr.duration);
        if (!(B || le || _e) && (R('onHide', [S], !1), S.props.onHide(S) !== !1)) {
            if (
                ((S.state.isVisible = !1),
                (S.state.isShown = !1),
                (d = !1),
                (s = !1),
                Te() && (N.style.visibility = 'hidden'),
                he(),
                Xe(),
                O(!0),
                Te())
            ) {
                var qe = Ee(),
                    Bt = qe.box,
                    an = qe.content;
                S.props.animation && (ih([Bt, an], Ze), _w([Bt, an], 'hidden'));
            }
            V(), Q(), S.props.animation ? Te() && xt(Ze, S.unmount) : S.unmount();
        }
    }
    function ct(B) {
        Me().addEventListener('mousemove', y), ww(xc, y), y(B);
    }
    function Vt() {
        S.state.isVisible && S.hide(),
            S.state.isMounted &&
                (ee(),
                Ke().forEach(function (B) {
                    B._tippy.unmount();
                }),
                N.parentNode && N.parentNode.removeChild(N),
                (sh = sh.filter(function (B) {
                    return B !== S;
                })),
                (S.state.isMounted = !1),
                R('onHidden', [S]));
    }
    function Mi() {
        S.state.isDestroyed ||
            (S.clearDelayTimeouts(),
            S.unmount(),
            st(),
            delete t._tippy,
            (S.state.isDestroyed = !0),
            R('onDestroy', [S]));
    }
}
function ua(t, e) {
    e === void 0 && (e = {});
    var n = lr.plugins.concat(e.plugins || []);
    _B();
    var r = Object.assign({}, e, { plugins: n }),
        i = yB(t);
    if (0) var o, s;
    var l = i.reduce(function (u, d) {
        var f = d && IB(d, r);
        return f && u.push(f), u;
    }, []);
    return Sc(t) ? l[0] : l;
}
ua.defaultProps = lr;
ua.setDefaultProps = kB;
ua.currentInput = yr;
var R5 = Object.assign({}, na, {
    effect: function (e) {
        var n = e.state,
            r = {
                popper: { position: n.options.strategy, left: '0', top: '0', margin: '0' },
                arrow: { position: 'absolute' },
                reference: {},
            };
        Object.assign(n.elements.popper.style, r.popper),
            (n.styles = r),
            n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
    },
});
ua.setDefaultProps({ render: Pw });
var ts = ua;
var uh = class {
        constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: o = 250, shouldShow: s }) {
            (this.preventHide = !1),
                (this.shouldShow = ({ view: l, state: u, from: d, to: f }) => {
                    let { doc: h, selection: m } = u,
                        { empty: b } = m,
                        y = !h.textBetween(d, f).length && Ql(u.selection),
                        v = this.element.contains(document.activeElement);
                    return !(!(l.hasFocus() || v) || b || y || !this.editor.isEditable);
                }),
                (this.mousedownHandler = () => {
                    this.preventHide = !0;
                }),
                (this.dragstartHandler = () => {
                    this.hide();
                }),
                (this.focusHandler = () => {
                    setTimeout(() => this.update(this.editor.view));
                }),
                (this.blurHandler = ({ event: l }) => {
                    var u;
                    if (this.preventHide) {
                        this.preventHide = !1;
                        return;
                    }
                    (l?.relatedTarget &&
                        !((u = this.element.parentNode) === null || u === void 0) &&
                        u.contains(l.relatedTarget)) ||
                        this.hide();
                }),
                (this.tippyBlurHandler = (l) => {
                    this.blurHandler({ event: l });
                }),
                (this.handleDebouncedUpdate = (l, u) => {
                    let d = !u?.selection.eq(l.state.selection),
                        f = !u?.doc.eq(l.state.doc);
                    (!d && !f) ||
                        (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer),
                        (this.updateDebounceTimer = window.setTimeout(() => {
                            this.updateHandler(l, d, f, u);
                        }, this.updateDelay)));
                }),
                (this.updateHandler = (l, u, d, f) => {
                    var h, m, b;
                    let { state: y, composing: v } = l,
                        { selection: x } = y;
                    if (v || (!u && !d)) return;
                    this.createTooltip();
                    let { ranges: D } = x,
                        I = Math.min(...D.map((N) => N.$from.pos)),
                        S = Math.max(...D.map((N) => N.$to.pos));
                    if (
                        !((h = this.shouldShow) === null || h === void 0
                            ? void 0
                            : h.call(this, { editor: this.editor, view: l, state: y, oldState: f, from: I, to: S }))
                    ) {
                        this.hide();
                        return;
                    }
                    (m = this.tippy) === null ||
                        m === void 0 ||
                        m.setProps({
                            getReferenceClientRect:
                                ((b = this.tippyOptions) === null || b === void 0
                                    ? void 0
                                    : b.getReferenceClientRect) ||
                                (() => {
                                    if ($E(y.selection)) {
                                        let N = l.nodeDOM(I),
                                            q = N.dataset.nodeViewWrapper
                                                ? N
                                                : N.querySelector('[data-node-view-wrapper]');
                                        if ((q && (N = q.firstChild), N)) return N.getBoundingClientRect();
                                    }
                                    return nc(l, I, S);
                                }),
                        }),
                        this.show();
                }),
                (this.editor = e),
                (this.element = n),
                (this.view = r),
                (this.updateDelay = o),
                s && (this.shouldShow = s),
                this.element.addEventListener('mousedown', this.mousedownHandler, { capture: !0 }),
                this.view.dom.addEventListener('dragstart', this.dragstartHandler),
                this.editor.on('focus', this.focusHandler),
                this.editor.on('blur', this.blurHandler),
                (this.tippyOptions = i),
                this.element.remove(),
                (this.element.style.visibility = 'visible');
        }
        createTooltip() {
            let { element: e } = this.editor.options,
                n = !!e.parentElement;
            this.tippy ||
                !n ||
                ((this.tippy = ts(e, {
                    duration: 0,
                    getReferenceClientRect: null,
                    content: this.element,
                    interactive: !0,
                    trigger: 'manual',
                    placement: 'top',
                    hideOnClick: 'toggle',
                    ...this.tippyOptions,
                })),
                this.tippy.popper.firstChild &&
                    this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler));
        }
        update(e, n) {
            let { state: r } = e,
                i = r.selection.$from.pos !== r.selection.$to.pos;
            if (this.updateDelay > 0 && i) {
                this.handleDebouncedUpdate(e, n);
                return;
            }
            let o = !n?.selection.eq(e.state.selection),
                s = !n?.doc.eq(e.state.doc);
            this.updateHandler(e, o, s, n);
        }
        show() {
            var e;
            (e = this.tippy) === null || e === void 0 || e.show();
        }
        hide() {
            var e;
            (e = this.tippy) === null || e === void 0 || e.hide();
        }
        destroy() {
            var e, n;
            !((e = this.tippy) === null || e === void 0) &&
                e.popper.firstChild &&
                this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler),
                (n = this.tippy) === null || n === void 0 || n.destroy(),
                this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: !0 }),
                this.view.dom.removeEventListener('dragstart', this.dragstartHandler),
                this.editor.off('focus', this.focusHandler),
                this.editor.off('blur', this.blurHandler);
        }
    },
    LB = (t) =>
        new Oe({
            key: typeof t.pluginKey == 'string' ? new ze(t.pluginKey) : t.pluginKey,
            view: (e) => new uh({ view: e, ...t }),
        }),
    Bw = Ge.create({
        name: 'bubbleMenu',
        addOptions() {
            return { element: null, tippyOptions: {}, pluginKey: 'bubbleMenu', updateDelay: void 0, shouldShow: null };
        },
        addProseMirrorPlugins() {
            return this.options.element
                ? [
                      LB({
                          pluginKey: this.options.pluginKey,
                          editor: this.editor,
                          element: this.options.element,
                          tippyOptions: this.options.tippyOptions,
                          updateDelay: this.options.updateDelay,
                          shouldShow: this.options.shouldShow,
                      }),
                  ]
                : [];
        },
    });
var dh = class {
        constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, shouldShow: o }) {
            (this.preventHide = !1),
                (this.shouldShow = ({ view: s, state: l }) => {
                    let { selection: u } = l,
                        { $anchor: d, empty: f } = u,
                        h = d.depth === 1,
                        m = d.parent.isTextblock && !d.parent.type.spec.code && !d.parent.textContent;
                    return !(!s.hasFocus() || !f || !h || !m || !this.editor.isEditable);
                }),
                (this.mousedownHandler = () => {
                    this.preventHide = !0;
                }),
                (this.focusHandler = () => {
                    setTimeout(() => this.update(this.editor.view));
                }),
                (this.blurHandler = ({ event: s }) => {
                    var l;
                    if (this.preventHide) {
                        this.preventHide = !1;
                        return;
                    }
                    (s?.relatedTarget &&
                        !((l = this.element.parentNode) === null || l === void 0) &&
                        l.contains(s.relatedTarget)) ||
                        this.hide();
                }),
                (this.tippyBlurHandler = (s) => {
                    this.blurHandler({ event: s });
                }),
                (this.editor = e),
                (this.element = n),
                (this.view = r),
                o && (this.shouldShow = o),
                this.element.addEventListener('mousedown', this.mousedownHandler, { capture: !0 }),
                this.editor.on('focus', this.focusHandler),
                this.editor.on('blur', this.blurHandler),
                (this.tippyOptions = i),
                this.element.remove(),
                (this.element.style.visibility = 'visible');
        }
        createTooltip() {
            let { element: e } = this.editor.options,
                n = !!e.parentElement;
            this.tippy ||
                !n ||
                ((this.tippy = ts(e, {
                    duration: 0,
                    getReferenceClientRect: null,
                    content: this.element,
                    interactive: !0,
                    trigger: 'manual',
                    placement: 'right',
                    hideOnClick: 'toggle',
                    ...this.tippyOptions,
                })),
                this.tippy.popper.firstChild &&
                    this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler));
        }
        update(e, n) {
            var r, i, o;
            let { state: s } = e,
                { doc: l, selection: u } = s,
                { from: d, to: f } = u;
            if (n && n.doc.eq(l) && n.selection.eq(u)) return;
            if (
                (this.createTooltip(),
                !((r = this.shouldShow) === null || r === void 0
                    ? void 0
                    : r.call(this, { editor: this.editor, view: e, state: s, oldState: n })))
            ) {
                this.hide();
                return;
            }
            (i = this.tippy) === null ||
                i === void 0 ||
                i.setProps({
                    getReferenceClientRect:
                        ((o = this.tippyOptions) === null || o === void 0 ? void 0 : o.getReferenceClientRect) ||
                        (() => nc(e, d, f)),
                }),
                this.show();
        }
        show() {
            var e;
            (e = this.tippy) === null || e === void 0 || e.show();
        }
        hide() {
            var e;
            (e = this.tippy) === null || e === void 0 || e.hide();
        }
        destroy() {
            var e, n;
            !((e = this.tippy) === null || e === void 0) &&
                e.popper.firstChild &&
                this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler),
                (n = this.tippy) === null || n === void 0 || n.destroy(),
                this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: !0 }),
                this.editor.off('focus', this.focusHandler),
                this.editor.off('blur', this.blurHandler);
        }
    },
    DB = (t) =>
        new Oe({
            key: typeof t.pluginKey == 'string' ? new ze(t.pluginKey) : t.pluginKey,
            view: (e) => new dh({ view: e, ...t }),
        }),
    Fw = Ge.create({
        name: 'floatingMenu',
        addOptions() {
            return { element: null, tippyOptions: {}, pluginKey: 'floatingMenu', shouldShow: null };
        },
        addProseMirrorPlugins() {
            return this.options.element
                ? [
                      DB({
                          pluginKey: this.options.pluginKey,
                          editor: this.editor,
                          element: this.options.element,
                          tippyOptions: this.options.tippyOptions,
                          shouldShow: this.options.shouldShow,
                      }),
                  ]
                : [];
        },
    });
var fh = ae.create({
    name: 'checkedList',
    priority: 50,
    addOptions() {
        return { itemTypeName: 'listItem', HTMLAttributes: { class: 'checked-list' } };
    },
    group: 'block list',
    content() {
        return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
        return [{ tag: 'ul', getAttrs: (t) => t.classList.contains('checked-list'), priority: 1e3 }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['ul', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            toggleCheckedList:
                () =>
                ({ commands: t }) =>
                    t.toggleList(this.name, this.options.itemTypeName),
        };
    },
});
var ph = ae.create({
    name: 'lead',
    group: 'block',
    content: 'block+',
    addOptions() {
        return { HTMLAttributes: { class: 'lead' } };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('lead') }];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
        return ['div', Z(this.options.HTMLAttributes, e), 0];
    },
    addCommands() {
        return {
            toggleLead:
                () =>
                ({ commands: t }) =>
                    t.toggleWrap(this.name),
        };
    },
});
var PB =
        'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2',
    BB =
        '\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2',
    is = (t, e) => {
        for (let n in e) t[n] = e[n];
        return t;
    },
    yh = 'numeric',
    Eh = 'ascii',
    vh = 'alpha',
    kc = 'asciinumeric',
    Tc = 'alphanumeric',
    wh = 'domain',
    qw = 'emoji',
    FB = 'scheme',
    HB = 'slashscheme',
    Hw = 'whitespace';
function zB(t, e) {
    return t in e || (e[t] = []), e[t];
}
function ho(t, e, n) {
    e[yh] && ((e[kc] = !0), (e[Tc] = !0)),
        e[Eh] && ((e[kc] = !0), (e[vh] = !0)),
        e[kc] && (e[Tc] = !0),
        e[vh] && (e[Tc] = !0),
        e[Tc] && (e[wh] = !0),
        e[qw] && (e[wh] = !0);
    for (let r in e) {
        let i = zB(r, n);
        i.indexOf(t) < 0 && i.push(t);
    }
}
function $B(t, e) {
    let n = {};
    for (let r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
    return n;
}
function xn(t) {
    t === void 0 && (t = null), (this.j = {}), (this.jr = []), (this.jd = null), (this.t = t);
}
xn.groups = {};
xn.prototype = {
    accepts() {
        return !!this.t;
    },
    go(t) {
        let e = this,
            n = e.j[t];
        if (n) return n;
        for (let r = 0; r < e.jr.length; r++) {
            let i = e.jr[r][0],
                o = e.jr[r][1];
            if (o && i.test(t)) return o;
        }
        return e.jd;
    },
    has(t, e) {
        return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
    },
    ta(t, e, n, r) {
        for (let i = 0; i < t.length; i++) this.tt(t[i], e, n, r);
    },
    tr(t, e, n, r) {
        r = r || xn.groups;
        let i;
        return e && e.j ? (i = e) : ((i = new xn(e)), n && r && ho(e, n, r)), this.jr.push([t, i]), i;
    },
    ts(t, e, n, r) {
        let i = this,
            o = t.length;
        if (!o) return i;
        for (let s = 0; s < o - 1; s++) i = i.tt(t[s]);
        return i.tt(t[o - 1], e, n, r);
    },
    tt(t, e, n, r) {
        r = r || xn.groups;
        let i = this;
        if (e && e.j) return (i.j[t] = e), e;
        let o = e,
            s,
            l = i.go(t);
        if (
            (l
                ? ((s = new xn()), is(s.j, l.j), s.jr.push.apply(s.jr, l.jr), (s.jd = l.jd), (s.t = l.t))
                : (s = new xn()),
            o)
        ) {
            if (r)
                if (s.t && typeof s.t == 'string') {
                    let u = is($B(s.t, r), n);
                    ho(o, u, r);
                } else n && ho(o, n, r);
            s.t = o;
        }
        return (i.j[t] = s), s;
    },
};
var Be = (t, e, n, r, i) => t.ta(e, n, r, i),
    qn = (t, e, n, r, i) => t.tr(e, n, r, i),
    zw = (t, e, n, r, i) => t.ts(e, n, r, i),
    j = (t, e, n, r, i) => t.tt(e, n, r, i),
    Vr = 'WORD',
    xh = 'UWORD',
    ha = 'LOCALHOST',
    _h = 'TLD',
    Sh = 'UTLD',
    Nc = 'SCHEME',
    rs = 'SLASH_SCHEME',
    Th = 'NUM',
    Yw = 'WS',
    Mh = 'NL',
    da = 'OPENBRACE',
    fa = 'CLOSEBRACE',
    Oc = 'OPENBRACKET',
    Rc = 'CLOSEBRACKET',
    Ic = 'OPENPAREN',
    Lc = 'CLOSEPAREN',
    Dc = 'OPENANGLEBRACKET',
    Pc = 'CLOSEANGLEBRACKET',
    Bc = 'FULLWIDTHLEFTPAREN',
    Fc = 'FULLWIDTHRIGHTPAREN',
    Hc = 'LEFTCORNERBRACKET',
    zc = 'RIGHTCORNERBRACKET',
    $c = 'LEFTWHITECORNERBRACKET',
    Uc = 'RIGHTWHITECORNERBRACKET',
    Wc = 'FULLWIDTHLESSTHAN',
    Kc = 'FULLWIDTHGREATERTHAN',
    Vc = 'AMPERSAND',
    Gc = 'APOSTROPHE',
    qc = 'ASTERISK',
    wi = 'AT',
    Yc = 'BACKSLASH',
    Jc = 'BACKTICK',
    Xc = 'CARET',
    xi = 'COLON',
    Ah = 'COMMA',
    Zc = 'DOLLAR',
    Er = 'DOT',
    jc = 'EQUALS',
    Ch = 'EXCLAMATION',
    vr = 'HYPHEN',
    Qc = 'PERCENT',
    eu = 'PIPE',
    tu = 'PLUS',
    nu = 'POUND',
    ru = 'QUERY',
    kh = 'QUOTE',
    Nh = 'SEMI',
    wr = 'SLASH',
    pa = 'TILDE',
    iu = 'UNDERSCORE',
    Jw = 'EMOJI',
    ou = 'SYM',
    Xw = Object.freeze({
        __proto__: null,
        WORD: Vr,
        UWORD: xh,
        LOCALHOST: ha,
        TLD: _h,
        UTLD: Sh,
        SCHEME: Nc,
        SLASH_SCHEME: rs,
        NUM: Th,
        WS: Yw,
        NL: Mh,
        OPENBRACE: da,
        CLOSEBRACE: fa,
        OPENBRACKET: Oc,
        CLOSEBRACKET: Rc,
        OPENPAREN: Ic,
        CLOSEPAREN: Lc,
        OPENANGLEBRACKET: Dc,
        CLOSEANGLEBRACKET: Pc,
        FULLWIDTHLEFTPAREN: Bc,
        FULLWIDTHRIGHTPAREN: Fc,
        LEFTCORNERBRACKET: Hc,
        RIGHTCORNERBRACKET: zc,
        LEFTWHITECORNERBRACKET: $c,
        RIGHTWHITECORNERBRACKET: Uc,
        FULLWIDTHLESSTHAN: Wc,
        FULLWIDTHGREATERTHAN: Kc,
        AMPERSAND: Vc,
        APOSTROPHE: Gc,
        ASTERISK: qc,
        AT: wi,
        BACKSLASH: Yc,
        BACKTICK: Jc,
        CARET: Xc,
        COLON: xi,
        COMMA: Ah,
        DOLLAR: Zc,
        DOT: Er,
        EQUALS: jc,
        EXCLAMATION: Ch,
        HYPHEN: vr,
        PERCENT: Qc,
        PIPE: eu,
        PLUS: tu,
        POUND: nu,
        QUERY: ru,
        QUOTE: kh,
        SEMI: Nh,
        SLASH: wr,
        TILDE: pa,
        UNDERSCORE: iu,
        EMOJI: Jw,
        SYM: ou,
    }),
    ns = /[a-z]/,
    hh = /\p{L}/u,
    mh = /\p{Emoji}/u;
var gh = /\d/,
    $w = /\s/;
var Uw = `
`,
    UB = '\uFE0F',
    WB = '\u200D',
    Mc = null,
    Ac = null;
function KB(t) {
    t === void 0 && (t = []);
    let e = {};
    xn.groups = e;
    let n = new xn();
    Mc == null && (Mc = Ww(PB)),
        Ac == null && (Ac = Ww(BB)),
        j(n, "'", Gc),
        j(n, '{', da),
        j(n, '}', fa),
        j(n, '[', Oc),
        j(n, ']', Rc),
        j(n, '(', Ic),
        j(n, ')', Lc),
        j(n, '<', Dc),
        j(n, '>', Pc),
        j(n, '\uFF08', Bc),
        j(n, '\uFF09', Fc),
        j(n, '\u300C', Hc),
        j(n, '\u300D', zc),
        j(n, '\u300E', $c),
        j(n, '\u300F', Uc),
        j(n, '\uFF1C', Wc),
        j(n, '\uFF1E', Kc),
        j(n, '&', Vc),
        j(n, '*', qc),
        j(n, '@', wi),
        j(n, '`', Jc),
        j(n, '^', Xc),
        j(n, ':', xi),
        j(n, ',', Ah),
        j(n, '$', Zc),
        j(n, '.', Er),
        j(n, '=', jc),
        j(n, '!', Ch),
        j(n, '-', vr),
        j(n, '%', Qc),
        j(n, '|', eu),
        j(n, '+', tu),
        j(n, '#', nu),
        j(n, '?', ru),
        j(n, '"', kh),
        j(n, '/', wr),
        j(n, ';', Nh),
        j(n, '~', pa),
        j(n, '_', iu),
        j(n, '\\', Yc);
    let r = qn(n, gh, Th, { [yh]: !0 });
    qn(r, gh, r);
    let i = qn(n, ns, Vr, { [Eh]: !0 });
    qn(i, ns, i);
    let o = qn(n, hh, xh, { [vh]: !0 });
    qn(o, ns), qn(o, hh, o);
    let s = qn(n, $w, Yw, { [Hw]: !0 });
    j(n, Uw, Mh, { [Hw]: !0 }), j(s, Uw), qn(s, $w, s);
    let l = qn(n, mh, Jw, { [qw]: !0 });
    qn(l, mh, l), j(l, UB, l);
    let u = j(l, WB);
    qn(u, mh, l);
    let d = [[ns, i]],
        f = [
            [ns, null],
            [hh, o],
        ];
    for (let h = 0; h < Mc.length; h++) vi(n, Mc[h], _h, Vr, d);
    for (let h = 0; h < Ac.length; h++) vi(n, Ac[h], Sh, xh, f);
    ho(_h, { tld: !0, ascii: !0 }, e),
        ho(Sh, { utld: !0, alpha: !0 }, e),
        vi(n, 'file', Nc, Vr, d),
        vi(n, 'mailto', Nc, Vr, d),
        vi(n, 'http', rs, Vr, d),
        vi(n, 'https', rs, Vr, d),
        vi(n, 'ftp', rs, Vr, d),
        vi(n, 'ftps', rs, Vr, d),
        ho(Nc, { scheme: !0, ascii: !0 }, e),
        ho(rs, { slashscheme: !0, ascii: !0 }, e),
        (t = t.sort((h, m) => (h[0] > m[0] ? 1 : -1)));
    for (let h = 0; h < t.length; h++) {
        let m = t[h][0],
            y = t[h][1] ? { [FB]: !0 } : { [HB]: !0 };
        m.indexOf('-') >= 0 ? (y[wh] = !0) : ns.test(m) ? (gh.test(m) ? (y[kc] = !0) : (y[Eh] = !0)) : (y[yh] = !0),
            zw(n, m, m, y);
    }
    return zw(n, 'localhost', ha, { ascii: !0 }), (n.jd = new xn(ou)), { start: n, tokens: is({ groups: e }, Xw) };
}
function VB(t, e) {
    let n = GB(e.replace(/[A-Z]/g, (l) => l.toLowerCase())),
        r = n.length,
        i = [],
        o = 0,
        s = 0;
    for (; s < r; ) {
        let l = t,
            u = null,
            d = 0,
            f = null,
            h = -1,
            m = -1;
        for (; s < r && (u = l.go(n[s])); )
            (l = u),
                l.accepts() ? ((h = 0), (m = 0), (f = l)) : h >= 0 && ((h += n[s].length), m++),
                (d += n[s].length),
                (o += n[s].length),
                s++;
        (o -= h), (s -= m), (d -= h), i.push({ t: f.t, v: e.slice(o - d, o), s: o - d, e: o });
    }
    return i;
}
function GB(t) {
    let e = [],
        n = t.length,
        r = 0;
    for (; r < n; ) {
        let i = t.charCodeAt(r),
            o,
            s =
                i < 55296 || i > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343
                    ? t[r]
                    : t.slice(r, r + 2);
        e.push(s), (r += s.length);
    }
    return e;
}
function vi(t, e, n, r, i) {
    let o,
        s = e.length;
    for (let l = 0; l < s - 1; l++) {
        let u = e[l];
        t.j[u] ? (o = t.j[u]) : ((o = new xn(r)), (o.jr = i.slice()), (t.j[u] = o)), (t = o);
    }
    return (o = new xn(n)), (o.jr = i.slice()), (t.j[e[s - 1]] = o), o;
}
function Ww(t) {
    let e = [],
        n = [],
        r = 0,
        i = '0123456789';
    for (; r < t.length; ) {
        let o = 0;
        for (; i.indexOf(t[r + o]) >= 0; ) o++;
        if (o > 0) {
            e.push(n.join(''));
            for (let s = parseInt(t.substring(r, r + o), 10); s > 0; s--) n.pop();
            r += o;
        } else n.push(t[r]), r++;
    }
    return e;
}
var ma = {
    defaultProtocol: 'http',
    events: null,
    format: Kw,
    formatHref: Kw,
    nl2br: !1,
    tagName: 'a',
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null,
};
function Oh(t, e) {
    e === void 0 && (e = null);
    let n = is({}, ma);
    t && (n = is(n, t instanceof Oh ? t.o : t));
    let r = n.ignoreTags,
        i = [];
    for (let o = 0; o < r.length; o++) i.push(r[o].toUpperCase());
    (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = i);
}
Oh.prototype = {
    o: ma,
    ignoreTags: [],
    defaultRender(t) {
        return t;
    },
    check(t) {
        return this.get('validate', t.toString(), t);
    },
    get(t, e, n) {
        let r = e != null,
            i = this.o[t];
        return (
            i &&
            (typeof i == 'object'
                ? ((i = n.t in i ? i[n.t] : ma[t]), typeof i == 'function' && r && (i = i(e, n)))
                : typeof i == 'function' && r && (i = i(e, n.t, n)),
            i)
        );
    },
    getObj(t, e, n) {
        let r = this.o[t];
        return typeof r == 'function' && e != null && (r = r(e, n.t, n)), r;
    },
    render(t) {
        let e = t.render(this);
        return (this.get('render', null, t) || this.defaultRender)(e, t.t, t);
    },
};
function Kw(t) {
    return t;
}
function Zw(t, e) {
    (this.t = 'token'), (this.v = t), (this.tk = e);
}
Zw.prototype = {
    isLink: !1,
    toString() {
        return this.v;
    },
    toHref(t) {
        return this.toString();
    },
    toFormattedString(t) {
        let e = this.toString(),
            n = t.get('truncate', e, this),
            r = t.get('format', e, this);
        return n && r.length > n ? r.substring(0, n) + '\u2026' : r;
    },
    toFormattedHref(t) {
        return t.get('formatHref', this.toHref(t.get('defaultProtocol')), this);
    },
    startIndex() {
        return this.tk[0].s;
    },
    endIndex() {
        return this.tk[this.tk.length - 1].e;
    },
    toObject(t) {
        return (
            t === void 0 && (t = ma.defaultProtocol),
            {
                type: this.t,
                value: this.toString(),
                isLink: this.isLink,
                href: this.toHref(t),
                start: this.startIndex(),
                end: this.endIndex(),
            }
        );
    },
    toFormattedObject(t) {
        return {
            type: this.t,
            value: this.toFormattedString(t),
            isLink: this.isLink,
            href: this.toFormattedHref(t),
            start: this.startIndex(),
            end: this.endIndex(),
        };
    },
    validate(t) {
        return t.get('validate', this.toString(), this);
    },
    render(t) {
        let e = this,
            n = this.toHref(t.get('defaultProtocol')),
            r = t.get('formatHref', n, this),
            i = t.get('tagName', n, e),
            o = this.toFormattedString(t),
            s = {},
            l = t.get('className', n, e),
            u = t.get('target', n, e),
            d = t.get('rel', n, e),
            f = t.getObj('attributes', n, e),
            h = t.getObj('events', n, e);
        return (
            (s.href = r),
            l && (s.class = l),
            u && (s.target = u),
            d && (s.rel = d),
            f && is(s, f),
            { tagName: i, attributes: s, content: o, eventListeners: h }
        );
    },
};
function su(t, e) {
    class n extends Zw {
        constructor(i, o) {
            super(i, o), (this.t = t);
        }
    }
    for (let r in e) n.prototype[r] = e[r];
    return (n.t = t), n;
}
var Vw = su('email', {
        isLink: !0,
        toHref() {
            return 'mailto:' + this.toString();
        },
    }),
    Gw = su('text'),
    qB = su('nl'),
    Cc = su('url', {
        isLink: !0,
        toHref(t) {
            return t === void 0 && (t = ma.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
        },
        hasProtocol() {
            let t = this.tk;
            return t.length >= 2 && t[0].t !== ha && t[1].t === xi;
        },
    });
var Yn = (t) => new xn(t);
function YB(t) {
    let { groups: e } = t,
        n = e.domain.concat([Vc, qc, wi, Yc, Jc, Xc, Zc, jc, vr, Th, Qc, eu, tu, nu, wr, ou, pa, iu]),
        r = [Gc, xi, Ah, Er, Ch, ru, kh, Nh, Dc, Pc, da, fa, Rc, Oc, Ic, Lc, Bc, Fc, Hc, zc, $c, Uc, Wc, Kc],
        i = [Vc, Gc, qc, Yc, Jc, Xc, Zc, jc, vr, da, fa, Qc, eu, tu, nu, ru, wr, ou, pa, iu],
        o = Yn(),
        s = j(o, pa);
    Be(s, i, s), Be(s, e.domain, s);
    let l = Yn(),
        u = Yn(),
        d = Yn();
    Be(o, e.domain, l), Be(o, e.scheme, u), Be(o, e.slashscheme, d), Be(l, i, s), Be(l, e.domain, l);
    let f = j(l, wi);
    j(s, wi, f), j(u, wi, f), j(d, wi, f);
    let h = j(s, Er);
    Be(h, i, s), Be(h, e.domain, s);
    let m = Yn();
    Be(f, e.domain, m), Be(m, e.domain, m);
    let b = j(m, Er);
    Be(b, e.domain, m);
    let y = Yn(Vw);
    Be(b, e.tld, y), Be(b, e.utld, y), j(f, ha, y);
    let v = j(m, vr);
    Be(v, e.domain, m), Be(y, e.domain, m), j(y, Er, b), j(y, vr, v);
    let x = j(y, xi);
    Be(x, e.numeric, Vw);
    let T = j(l, vr),
        D = j(l, Er);
    Be(T, e.domain, l), Be(D, i, s), Be(D, e.domain, l);
    let I = Yn(Cc);
    Be(D, e.tld, I), Be(D, e.utld, I), Be(I, e.domain, l), Be(I, i, s), j(I, Er, D), j(I, vr, T), j(I, wi, f);
    let S = j(I, xi),
        z = Yn(Cc);
    Be(S, e.numeric, z);
    let N = Yn(Cc),
        q = Yn();
    Be(N, n, N), Be(N, r, q), Be(q, n, N), Be(q, r, q), j(I, wr, N), j(z, wr, N);
    let ne = j(u, xi),
        $ = j(d, xi),
        oe = j($, wr),
        me = j(oe, wr);
    Be(u, e.domain, l),
        j(u, Er, D),
        j(u, vr, T),
        Be(d, e.domain, l),
        j(d, Er, D),
        j(d, vr, T),
        Be(ne, e.domain, N),
        j(ne, wr, N),
        Be(me, e.domain, N),
        Be(me, n, N),
        j(me, wr, N);
    let Te = [
        [da, fa],
        [Oc, Rc],
        [Ic, Lc],
        [Dc, Pc],
        [Bc, Fc],
        [Hc, zc],
        [$c, Uc],
        [Wc, Kc],
    ];
    for (let ge = 0; ge < Te.length; ge++) {
        let [Me, Ee] = Te[ge],
            P = j(N, Me);
        j(q, Me, P), j(P, Ee, N);
        let O = Yn(Cc);
        Be(P, n, O);
        let R = Yn();
        Be(P, r), Be(O, n, O), Be(O, r, R), Be(R, n, O), Be(R, r, R), j(O, Ee, N), j(R, Ee, N);
    }
    return j(o, ha, I), j(o, Mh, qB), { start: o, tokens: Xw };
}
function JB(t, e, n) {
    let r = n.length,
        i = 0,
        o = [],
        s = [];
    for (; i < r; ) {
        let l = t,
            u = null,
            d = null,
            f = 0,
            h = null,
            m = -1;
        for (; i < r && !(u = l.go(n[i].t)); ) s.push(n[i++]);
        for (; i < r && (d = u || l.go(n[i].t)); )
            (u = null), (l = d), l.accepts() ? ((m = 0), (h = l)) : m >= 0 && m++, i++, f++;
        if (m < 0) (i -= f), i < r && (s.push(n[i]), i++);
        else {
            s.length > 0 && (o.push(bh(Gw, e, s)), (s = [])), (i -= m), (f -= m);
            let b = h.t,
                y = n.slice(i - f, i);
            o.push(bh(b, e, y));
        }
    }
    return s.length > 0 && o.push(bh(Gw, e, s)), o;
}
function bh(t, e, n) {
    let r = n[0].s,
        i = n[n.length - 1].e,
        o = e.slice(r, i);
    return new t(o, n);
}
var XB = (typeof console < 'u' && console && console.warn) || (() => {}),
    ZB =
        'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.',
    ht = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: !1 };
function jw() {
    (xn.groups = {}),
        (ht.scanner = null),
        (ht.parser = null),
        (ht.tokenQueue = []),
        (ht.pluginQueue = []),
        (ht.customSchemes = []),
        (ht.initialized = !1);
}
function Rh(t, e) {
    if (
        (e === void 0 && (e = !1),
        ht.initialized && XB(`linkifyjs: already initialized - will not register custom scheme "${t}" ${ZB}`),
        !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    )
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    ht.customSchemes.push([t, e]);
}
function jB() {
    ht.scanner = KB(ht.customSchemes);
    for (let t = 0; t < ht.tokenQueue.length; t++) ht.tokenQueue[t][1]({ scanner: ht.scanner });
    ht.parser = YB(ht.scanner.tokens);
    for (let t = 0; t < ht.pluginQueue.length; t++) ht.pluginQueue[t][1]({ scanner: ht.scanner, parser: ht.parser });
    ht.initialized = !0;
}
function Ih(t) {
    return ht.initialized || jB(), JB(ht.parser.start, t, VB(ht.scanner.start, t));
}
function Lh(t, e, n) {
    if ((e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == 'object')) {
        if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        (n = e), (e = null);
    }
    let r = new Oh(n),
        i = Ih(t),
        o = [];
    for (let s = 0; s < i.length; s++) {
        let l = i[s];
        l.isLink && (!e || l.t === e) && r.check(l) && o.push(l.toFormattedObject(r));
    }
    return o;
}
function QB(t) {
    return t.length === 1
        ? t[0].isLink
        : t.length === 3 && t[1].isLink
          ? ['()', '[]'].includes(t[0].value + t[2].value)
          : !1;
}
function e2(t) {
    return new Oe({
        key: new ze('autolink'),
        appendTransaction: (e, n, r) => {
            let i = e.some((d) => d.docChanged) && !n.doc.eq(r.doc),
                o = e.some((d) => d.getMeta('preventAutolink'));
            if (!i || o) return;
            let { tr: s } = r,
                l = FE(n.doc, [...e]);
            if (
                (zE(l).forEach(({ newRange: d }) => {
                    let f = HE(r.doc, d, (b) => b.isTextblock),
                        h,
                        m;
                    if (
                        (f.length > 1
                            ? ((h = f[0]), (m = r.doc.textBetween(h.pos, h.pos + h.node.nodeSize, void 0, ' ')))
                            : f.length &&
                              r.doc.textBetween(d.from, d.to, ' ', ' ').endsWith(' ') &&
                              ((h = f[0]), (m = r.doc.textBetween(h.pos, d.to, void 0, ' '))),
                        h && m)
                    ) {
                        let b = m.split(' ').filter((T) => T !== '');
                        if (b.length <= 0) return !1;
                        let y = b[b.length - 1],
                            v = h.pos + m.lastIndexOf(y);
                        if (!y) return !1;
                        let x = Ih(y).map((T) => T.toObject());
                        if (!QB(x)) return !1;
                        x.filter((T) => T.isLink)
                            .map((T) => ({ ...T, from: v + T.start + 1, to: v + T.end + 1 }))
                            .filter((T) =>
                                r.schema.marks.code ? !r.doc.rangeHasMark(T.from, T.to, r.schema.marks.code) : !0,
                            )
                            .filter((T) => (t.validate ? t.validate(T.value) : !0))
                            .forEach((T) => {
                                tc(T.from, T.to, r.doc).some((D) => D.mark.type === t.type) ||
                                    s.addMark(T.from, T.to, t.type.create({ href: T.href }));
                            });
                    }
                }),
                !!s.steps.length)
            )
                return s;
        },
    });
}
function t2(t) {
    return new Oe({
        key: new ze('handleClickLink'),
        props: {
            handleClick: (e, n, r) => {
                var i, o;
                if ((t.whenNotEditable && e.editable) || r.button !== 0) return !1;
                let s = r.target,
                    l = [];
                for (; s.nodeName !== 'DIV'; ) l.push(s), (s = s.parentNode);
                if (!l.find((m) => m.nodeName === 'A')) return !1;
                let u = xp(e.state, t.type.name),
                    d = r.target,
                    f = (i = d?.href) !== null && i !== void 0 ? i : u.href,
                    h = (o = d?.target) !== null && o !== void 0 ? o : u.target;
                return d && f ? (window.open(f, h), !0) : !1;
            },
        },
    });
}
function n2(t) {
    return new Oe({
        key: new ze('handlePasteLink'),
        props: {
            handlePaste: (e, n, r) => {
                let { state: i } = e,
                    { selection: o } = i,
                    { empty: s } = o;
                if (s) return !1;
                let l = '';
                r.content.forEach((d) => {
                    l += d.textContent;
                });
                let u = Lh(l).find((d) => d.isLink && d.value === l);
                return !l || !u ? !1 : (t.editor.commands.setMark(t.type, { href: u.href }), !0);
            },
        },
    });
}
var Qw = tt.create({
    name: 'link',
    priority: 1e3,
    keepOnSplit: !1,
    onCreate() {
        this.options.protocols.forEach((t) => {
            if (typeof t == 'string') {
                Rh(t);
                return;
            }
            Rh(t.scheme, t.optionalSlashes);
        });
    },
    onDestroy() {
        jw();
    },
    inclusive() {
        return this.options.autolink;
    },
    addOptions() {
        return {
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            HTMLAttributes: { target: '_blank', rel: 'noopener noreferrer nofollow', class: null },
            validate: void 0,
        };
    },
    addAttributes() {
        return {
            href: { default: null },
            target: { default: this.options.HTMLAttributes.target },
            rel: { default: this.options.HTMLAttributes.rel },
            class: { default: this.options.HTMLAttributes.class },
        };
    },
    parseHTML() {
        return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        var e;
        return !((e = t.href) === null || e === void 0) && e.startsWith('javascript:')
            ? ['a', Z(this.options.HTMLAttributes, { ...t, href: '' }), 0]
            : ['a', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setLink:
                (t) =>
                ({ chain: e }) =>
                    e().setMark(this.name, t).setMeta('preventAutolink', !0).run(),
            toggleLink:
                (t) =>
                ({ chain: e }) =>
                    e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta('preventAutolink', !0).run(),
            unsetLink:
                () =>
                ({ chain: t }) =>
                    t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta('preventAutolink', !0).run(),
        };
    },
    addPasteRules() {
        return [
            wn({
                find: (t) => {
                    let e = [];
                    if (t) {
                        let n = Lh(t).filter((r) => r.isLink);
                        n.length && n.forEach((r) => e.push({ text: r.value, data: { href: r.href }, index: r.start }));
                    }
                    return e;
                },
                type: this.type,
                getAttributes: (t) => {
                    var e;
                    return { href: (e = t.data) === null || e === void 0 ? void 0 : e.href };
                },
            }),
        ];
    },
    addProseMirrorPlugins() {
        let t = [];
        return (
            this.options.autolink && t.push(e2({ type: this.type, validate: this.options.validate })),
            this.options.openOnClick &&
                t.push(t2({ type: this.type, whenNotEditable: this.options.openOnClick === 'whenNotEditable' })),
            this.options.linkOnPaste && t.push(n2({ editor: this.editor, type: this.type })),
            t
        );
    },
});
var Dh = Qw.extend({
    addOptions() {
        return { openOnClick: !0, linkOnPaste: !0, autolink: !0, protocols: [], HTMLAttributes: {}, validate: void 0 };
    },
    addAttributes() {
        return {
            href: { default: null },
            id: { default: null },
            target: { default: this.options.HTMLAttributes.target },
            hreflang: { default: null },
            rel: { default: null },
            referrerpolicy: { default: null },
            class: { default: null },
            as_button: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-as-button'),
                renderHTML: (t) => ({ 'data-as-button': t.as_button }),
            },
            button_theme: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-as-button-theme'),
                renderHTML: (t) => ({ 'data-as-button-theme': t.button_theme }),
            },
        };
    },
});
var r2 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
    ex = ae.create({
        name: 'image',
        addOptions() {
            return { inline: !1, allowBase64: !1, HTMLAttributes: {} };
        },
        inline() {
            return this.options.inline;
        },
        group() {
            return this.options.inline ? 'inline' : 'block';
        },
        draggable: !0,
        addAttributes() {
            return { src: { default: null }, alt: { default: null }, title: { default: null } };
        },
        parseHTML() {
            return [{ tag: this.options.allowBase64 ? 'img[src]' : 'img[src]:not([src^="data:"])' }];
        },
        renderHTML({ HTMLAttributes: t }) {
            return ['img', Z(this.options.HTMLAttributes, t)];
        },
        addCommands() {
            return {
                setImage:
                    (t) =>
                    ({ commands: e }) =>
                        e.insertContent({ type: this.name, attrs: t }),
            };
        },
        addInputRules() {
            return [
                rc({
                    find: r2,
                    type: this.type,
                    getAttributes: (t) => {
                        let [, , e, n, r] = t;
                        return { src: n, alt: e, title: r };
                    },
                }),
            ];
        },
    });
var Ph = ex.extend({
    addAttributes() {
        return {
            src: { default: null },
            alt: { default: null },
            class: { default: null },
            title: { default: null },
            width: { default: null },
            height: { default: null },
            id: { default: null },
            lazy: {
                default: null,
                parseHTML: (t) => (t.getAttribute('loading') === 'lazy' ? t.getAttribute('data-lazy') : null),
                renderHTML: (t) => {
                    if (t.lazy) return { 'data-lazy': t.lazy, loading: 'lazy' };
                },
            },
        };
    },
});
var i2 = lc.extend({
    addAttributes() {
        return { class: { default: null } };
    },
});
var Bh = tt.create({
    name: 'small',
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [{ tag: 'small' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['small', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            setSmall:
                () =>
                ({ commands: t }) =>
                    t.setMark(this.name),
            toggleSmall:
                () =>
                ({ commands: t }) =>
                    t.toggleMark(this.name),
            unsetSmall:
                () =>
                ({ commands: t }) =>
                    t.unsetMark(this.name),
        };
    },
});
function tx(t, e = null) {
    return e ? t.createChecked(null, e) : t.createAndFill();
}
function nx(t) {
    if (t.cached.gridNodeTypes) return t.cached.gridNodeTypes;
    let e = {};
    return (
        Object.keys(t.nodes).forEach((n) => {
            let r = t.nodes[n];
            r.spec.gridRole && (e[r.spec.gridRole] = r);
        }),
        (t.cached.gridNodeTypes = e),
        e
    );
}
function rx(t, e, n, r) {
    let i = nx(t),
        o = [];
    for (let s = 0; s < e; s += 1) {
        let l = tx(i.column, r);
        l && o.push(l);
    }
    return i.grid.createChecked({ cols: e, type: n }, o);
}
var Fh = ae.create({
    name: 'grid',
    group: 'block',
    defining: !0,
    isolating: !0,
    allowGapCursor: !1,
    content: 'gridColumn+',
    gridRole: 'grid',
    addOptions() {
        return { HTMLAttributes: { class: 'filament-tiptap-grid' } };
    },
    addAttributes() {
        return {
            type: { default: 'responsive', parseHTML: (t) => t.getAttribute('type') },
            cols: { default: 2, parseHTML: (t) => t.getAttribute('cols') },
        };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('filament-tiptap-grid') && null }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['div', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            insertGrid:
                ({ cols: t = 3, type: e = 'responsive' } = {}) =>
                ({ tr: n, dispatch: r, editor: i }) => {
                    let o = rx(i.schema, t, e);
                    if (r) {
                        let s = n.selection.anchor + 1;
                        n.replaceSelectionWith(o)
                            .scrollIntoView()
                            .setSelection(ce.near(n.doc.resolve(s)));
                    }
                    return !0;
                },
        };
    },
    addKeyboardShortcuts() {
        return { 'Mod-Alt-G': () => this.editor.commands.insertGrid() };
    },
    extendNodeSchema(t) {
        let e = { name: t.name, options: t.options, storage: t.storage };
        return { gridRole: Se(ie(t, 'gridRole', e)) };
    },
});
var Hh = ae.create({
    name: 'gridColumn',
    content: 'block+',
    gridRole: 'column',
    isolating: !0,
    addOptions() {
        return { HTMLAttributes: { class: 'filament-tiptap-grid__column' } };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('filament-tiptap-grid__column') && null }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['div', Z(this.options.HTMLAttributes, t), 0];
    },
});
var ox = (t) => t.match(/(youtube\.com|youtu\.be)(.+)?$/),
    ix = (t = !1) => (t ? 'https://www.youtube-nocookie.com/embed/' : 'https://www.youtube.com/embed/'),
    zh = (t) => {
        let { url: e, controls: n, nocookie: r, startAt: i } = t;
        if (e.includes('/embed/')) return e;
        if (e.includes('youtu.be')) {
            let d = e.split('/').pop();
            return d ? `${ix(r)}${d}` : null;
        }
        let s = /v=([-\w]+)/gm.exec(e);
        if (!s || !s[1]) return null;
        let l = `${ix(r)}${s[1]}`,
            u = [];
        return (
            n ? u.push('controls=1') : u.push('controls=0'),
            i && u.push(`start=${i}`),
            u.length && (l += `?${u.join('&')}`),
            l
        );
    };
var $h = ae.create({
    name: 'youtube',
    selectable: !0,
    draggable: !0,
    atom: !0,
    addOptions() {
        return { inline: !1, HTMLAttributes: {}, width: 640, height: 480 };
    },
    inline() {
        return this.options.inline;
    },
    group() {
        return this.options.inline ? 'inline' : 'block';
    },
    addAttributes() {
        return {
            style: { default: null, parseHTML: (t) => t.getAttribute('style') },
            src: { default: null },
            width: { default: this.options.width, parseHTML: (t) => t.getAttribute('width') },
            height: { default: this.options.height, parseHTML: (t) => t.getAttribute('height') },
            responsive: { default: !0, parseHTML: (t) => t.classList.contains('responsive') ?? !1 },
            start: { default: 0 },
            controls: { default: !0 },
            nocookie: { default: !1 },
            'data-aspect-width': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-width') },
            'data-aspect-height': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-height') },
        };
    },
    parseHTML() {
        return [{ tag: 'div[data-youtube-video] iframe' }];
    },
    addCommands() {
        return {
            setYoutubeVideo:
                (t) =>
                ({ commands: e }) => {
                    if (!ox(t.src)) return !1;
                    let n = zh({ url: t.src, controls: t.controls, nocookie: t.nocookie, startAt: t.start || 0 });
                    return e.insertContent({ type: this.name, attrs: { ...t, src: n } });
                },
        };
    },
    renderHTML({ HTMLAttributes: t }) {
        let e = zh({ url: t.src, controls: t.controls, nocookie: t.nocookie, startAt: t.start || 0 });
        return [
            'div',
            { 'data-youtube-video': '', class: t.responsive ? 'responsive' : null },
            [
                'iframe',
                {
                    src: e,
                    width: t.width,
                    height: t.height,
                    allowfullscreen: this.options.allowFullscreen,
                    style: t.responsive
                        ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
                        : null,
                    'data-aspect-width': t.responsive ? t['data-aspect-width'] : null,
                    'data-aspect-height': t.responsive ? t['data-aspect-height'] : null,
                },
            ],
        ];
    },
});
var sx = (t) => t.match(/(vimeo\.com)(.+)?$/),
    Uh = (t) => {
        let { url: e, autoplay: n, loop: r, title: i, byline: o, portrait: s } = t;
        if (e.includes('/video/')) return e;
        let u = /\.com\/([0-9]+)/gm.exec(e);
        if (!u || !u[1]) return null;
        let d = `https://player.vimeo.com/video/${u[1]}`,
            f = [`autoplay=${n}`, `loop=${r}`, `title=${i}`, `byline=${o}`, `portrait=${s}`];
        return (d += `?${f.join('&')}`), d;
    };
var Wh = ae.create({
    name: 'vimeo',
    selectable: !0,
    draggable: !0,
    atom: !0,
    addOptions() {
        return { inline: !1, HTMLAttributes: {}, allowFullscreen: !0, width: 640, height: 480 };
    },
    inline() {
        return this.options.inline;
    },
    group() {
        return this.options.inline ? 'inline' : 'block';
    },
    addAttributes() {
        return {
            style: { default: null, parseHTML: (t) => t.getAttribute('style') },
            src: { default: null },
            width: { default: this.options.width, parseHTML: (t) => t.getAttribute('width') },
            height: { default: this.options.height, parseHTML: (t) => t.getAttribute('height') },
            autoplay: { default: 0 },
            loop: { default: 0 },
            title: { default: 0 },
            byline: { default: 0 },
            portrait: { default: 0 },
            responsive: { default: !0, parseHTML: (t) => t.classList.contains('responsive') ?? !1 },
            'data-aspect-width': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-width') },
            'data-aspect-height': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-height') },
        };
    },
    parseHTML() {
        return [{ tag: 'div[data-vimeo-video] iframe' }];
    },
    addCommands() {
        return {
            setVimeoVideo:
                (t) =>
                ({ commands: e }) => {
                    if (!sx(t.src)) return !1;
                    let n = Uh({
                        url: t.src,
                        autoplay: t?.autoplay || 0,
                        loop: t?.loop || 0,
                        title: t?.title || 0,
                        byline: t?.byline || 0,
                        portrait: t?.portrait || 0,
                    });
                    return e.insertContent({ type: this.name, attrs: { ...t, src: n } });
                },
        };
    },
    renderHTML({ HTMLAttributes: t }) {
        let e = Uh({
            url: t.src,
            autoplay: t?.autoplay || 0,
            loop: t?.loop || 0,
            title: t?.title || 0,
            byline: t?.byline || 0,
            portrait: t?.portrait || 0,
        });
        return [
            'div',
            { 'data-vimeo-video': '', class: t.responsive ? 'responsive' : null },
            [
                'iframe',
                {
                    src: e,
                    width: t.width,
                    height: t.height,
                    allowfullscreen: this.options.allowfullscreen,
                    frameborder: 0,
                    allow: 'autoplay; fullscreen; picture-in-picture',
                    style: t.responsive
                        ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
                        : null,
                    'data-aspect-width': t.responsive ? t['data-aspect-width'] : null,
                    'data-aspect-height': t.responsive ? t['data-aspect-height'] : null,
                },
            ],
        ];
    },
});
var Kh = ae.create({
    name: 'video',
    selectable: !0,
    draggable: !0,
    atom: !0,
    inline() {
        return this.options.inline;
    },
    group() {
        return this.options.inline ? 'inline' : 'block';
    },
    addOptions() {
        return { inline: !1, HTMLAttributes: { autoplay: null, controls: null, loop: null }, width: 640, height: 480 };
    },
    addAttributes() {
        return {
            style: { default: null, parseHTML: (t) => t.getAttribute('style') },
            responsive: { default: !0, parseHTML: (t) => t.classList.contains('responsive') ?? !1 },
            src: { default: null },
            width: { default: this.options.width, parseHTML: (t) => t.getAttribute('width') },
            height: { default: this.options.height, parseHTML: (t) => t.getAttribute('height') },
            autoplay: { default: null, parseHTML: (t) => t.getAttribute('autoplay') },
            controls: { default: null, parseHTML: (t) => t.getAttribute('controls') },
            loop: { default: null, parseHTML: (t) => t.getAttribute('loop') },
            'data-aspect-width': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-width') },
            'data-aspect-height': { default: null, parseHTML: (t) => t.getAttribute('data-aspect-height') },
        };
    },
    parseHTML() {
        return [{ tag: 'div[data-native-video] video' }];
    },
    addCommands() {
        return {
            setVideo:
                (t) =>
                ({ commands: e }) =>
                    e.insertContent({ type: this.name, attrs: t }),
        };
    },
    renderHTML({ HTMLAttributes: t }) {
        return [
            'div',
            { 'data-native-video': '', class: t.responsive ? 'responsive' : null },
            [
                'video',
                {
                    src: t.src,
                    width: t.width,
                    height: t.height,
                    autoplay: t.autoplay ? 'true' : null,
                    controls: t.controls ? 'true' : null,
                    loop: t.loop ? 'true' : null,
                    style: t.responsive
                        ? `aspect-ratio: ${t['data-aspect-width']} / ${t['data-aspect-height']}; width: 100%; height: auto;`
                        : null,
                    'data-aspect-width': t.responsive ? t['data-aspect-width'] : null,
                    'data-aspect-height': t.responsive ? t['data-aspect-height'] : null,
                },
            ],
        ];
    },
});
var Vh = ae.create({
    name: 'details',
    content: 'detailsSummary detailsContent',
    group: 'block',
    defining: !0,
    isolating: !0,
    allowGapCursor: !1,
    addOptions() {
        return { HTMLAttributes: {} };
    },
    addAttributes() {
        return {};
    },
    parseHTML() {
        return [{ tag: 'details' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['details', Z(this.options.HTMLAttributes, t), 0];
    },
    addNodeView() {
        return ({ editor: t, getPos: e, node: n, HTMLAttributes: r }) => {
            let i = document.createElement('div'),
                o = document.createElement('div'),
                s = Z(this.options.HTMLAttributes, r, { 'data-type': this.name });
            return (
                Object.entries(s).forEach(([l, u]) => i.setAttribute(l, u)),
                {
                    dom: i,
                    contentDOM: i,
                    ignoreMutation(l) {
                        return l.type === 'selection' ? !1 : !i.contains(l.target) || i === l.target;
                    },
                    update: (l) => l.type === this.type,
                }
            );
        };
    },
    addCommands() {
        return {
            setDetails:
                () =>
                ({ state: t, chain: e }) => {
                    var n;
                    let { schema: r, selection: i } = t,
                        { $from: o, $to: s } = i,
                        l = o.blockRange(s);
                    if (!l) return !1;
                    let u = t.doc.slice(l.start, l.end);
                    if (!r.nodes.detailsContent.contentMatch.matchFragment(u.content)) return !1;
                    let f = ((n = u.toJSON()) === null || n === void 0 ? void 0 : n.content) || [];
                    return e()
                        .insertContentAt(
                            { from: l.start, to: l.end },
                            {
                                type: this.name,
                                content: [{ type: 'detailsSummary' }, { type: 'detailsContent', content: f }],
                            },
                        )
                        .setTextSelection(l.start + 2)
                        .run();
                },
            unsetDetails:
                () =>
                ({ state: t, chain: e }) => {
                    let { selection: n, schema: r } = t,
                        i = eo((T) => T.type === this.type)(n);
                    if (!i) return !1;
                    let o = Qi(i.node, (T) => T.type === r.nodes.detailsSummary),
                        s = Qi(i.node, (T) => T.type === r.nodes.detailsContent);
                    if (!o.length || !s.length) return !1;
                    let l = o[0],
                        u = s[0],
                        d = i.pos,
                        f = t.doc.resolve(d),
                        h = d + i.node.nodeSize,
                        m = { from: d, to: h },
                        b = u.node.content.toJSON() || [],
                        y = f.parent.type.contentMatch.defaultType,
                        x = [y?.create(null, l.node.content).toJSON(), ...b];
                    return e()
                        .insertContentAt(m, x)
                        .setTextSelection(d + 1)
                        .run();
                },
        };
    },
    addKeyboardShortcuts() {
        return {
            Backspace: () => {
                let { schema: t, selection: e } = this.editor.state,
                    { empty: n, $anchor: r } = e;
                return !n || r.parent.type !== t.nodes.detailsSummary
                    ? !1
                    : r.parentOffset !== 0
                      ? this.editor.commands.command(({ tr: i }) => {
                            let o = r.pos - 1,
                                s = r.pos;
                            return i.delete(o, s), !0;
                        })
                      : this.editor.commands.unsetDetails();
            },
        };
    },
});
var Gh = ae.create({
    name: 'detailsSummary',
    content: 'text*',
    defining: !0,
    selectable: !1,
    isolating: !0,
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [{ tag: 'summary' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['summary', Z(this.options.HTMLAttributes, t), 0];
    },
});
var qh = ae.create({
    name: 'detailsContent',
    content: 'block+',
    defining: !0,
    selectable: !1,
    addOptions() {
        return { HTMLAttributes: {} };
    },
    parseHTML() {
        return [{ tag: 'div[data-type="details-content"]' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['div', Z(this.options.HTMLAttributes, t, { 'data-type': 'details-content' }), 0];
    },
    addKeyboardShortcuts() {
        return {
            Enter: ({ editor: t }) => {
                let { state: e, view: n } = t,
                    { selection: r } = e,
                    { $from: i, empty: o } = r,
                    s = eo((me) => me.type === this.type)(r);
                if (!o || !s || !s.node.childCount) return !1;
                let l = i.index(s.depth),
                    { childCount: u } = s.node;
                if (!(u === l + 1)) return !1;
                let f = s.node.type.contentMatch.defaultType,
                    h = f?.createAndFill();
                if (!h) return !1;
                let m = e.doc.resolve(s.pos + 1),
                    b = u - 1,
                    y = s.node.child(b),
                    v = m.posAtIndex(b, s.depth);
                if (!y.eq(h)) return !1;
                let T = i.node(-3);
                if (!T) return !1;
                let D = i.indexAfter(-3),
                    I = vp(T.contentMatchAt(D));
                if (!I || !T.canReplaceWith(D, D, I)) return !1;
                let S = I.createAndFill();
                if (!S) return !1;
                let { tr: z } = e,
                    N = i.after(-2);
                z.replaceWith(N, N, S);
                let q = z.doc.resolve(N),
                    ne = fe.near(q, 1);
                z.setSelection(ne);
                let $ = v,
                    oe = v + y.nodeSize;
                return z.delete($, oe), z.scrollIntoView(), n.dispatch(z), !0;
            },
        };
    },
});
var o2 = /^```([a-z]+)?[\s\n]$/,
    s2 = /^~~~([a-z]+)?[\s\n]$/,
    ax = ae.create({
        name: 'codeBlock',
        addOptions() {
            return { languageClassPrefix: 'language-', exitOnTripleEnter: !0, exitOnArrowDown: !0, HTMLAttributes: {} };
        },
        content: 'text*',
        marks: '',
        group: 'block',
        code: !0,
        defining: !0,
        addAttributes() {
            return {
                language: {
                    default: null,
                    parseHTML: (t) => {
                        var e;
                        let { languageClassPrefix: n } = this.options,
                            o = [...(((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || [])]
                                .filter((s) => s.startsWith(n))
                                .map((s) => s.replace(n, ''))[0];
                        return o || null;
                    },
                    rendered: !1,
                },
            };
        },
        parseHTML() {
            return [{ tag: 'pre', preserveWhitespace: 'full' }];
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            return [
                'pre',
                Z(this.options.HTMLAttributes, e),
                ['code', { class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null }, 0],
            ];
        },
        addCommands() {
            return {
                setCodeBlock:
                    (t) =>
                    ({ commands: e }) =>
                        e.setNode(this.name, t),
                toggleCodeBlock:
                    (t) =>
                    ({ commands: e }) =>
                        e.toggleNode(this.name, 'paragraph', t),
            };
        },
        addKeyboardShortcuts() {
            return {
                'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
                Backspace: () => {
                    let { empty: t, $anchor: e } = this.editor.state.selection,
                        n = e.pos === 1;
                    return !t || e.parent.type.name !== this.name
                        ? !1
                        : n || !e.parent.textContent.length
                          ? this.editor.commands.clearNodes()
                          : !1;
                },
                Enter: ({ editor: t }) => {
                    if (!this.options.exitOnTripleEnter) return !1;
                    let { state: e } = t,
                        { selection: n } = e,
                        { $from: r, empty: i } = n;
                    if (!i || r.parent.type !== this.type) return !1;
                    let o = r.parentOffset === r.parent.nodeSize - 2,
                        s = r.parent.textContent.endsWith(`

`);
                    return !o || !s
                        ? !1
                        : t
                              .chain()
                              .command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0))
                              .exitCode()
                              .run();
                },
                ArrowDown: ({ editor: t }) => {
                    if (!this.options.exitOnArrowDown) return !1;
                    let { state: e } = t,
                        { selection: n, doc: r } = e,
                        { $from: i, empty: o } = n;
                    if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1;
                    let l = i.after();
                    return l === void 0 || r.nodeAt(l) ? !1 : t.commands.exitCode();
                },
            };
        },
        addInputRules() {
            return [
                ta({ find: o2, type: this.type, getAttributes: (t) => ({ language: t[1] }) }),
                ta({ find: s2, type: this.type, getAttributes: (t) => ({ language: t[1] }) }),
            ];
        },
        addProseMirrorPlugins() {
            return [
                new Oe({
                    key: new ze('codeBlockVSCodeHandler'),
                    props: {
                        handlePaste: (t, e) => {
                            if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1;
                            let n = e.clipboardData.getData('text/plain'),
                                r = e.clipboardData.getData('vscode-editor-data'),
                                i = r ? JSON.parse(r) : void 0,
                                o = i?.mode;
                            if (!n || !o) return !1;
                            let { tr: s } = t.state;
                            return (
                                t.state.selection.from === t.state.doc.nodeSize - (1 + t.state.selection.$to.depth * 2)
                                    ? s.insert(t.state.selection.from - 1, this.type.create({ language: o }))
                                    : s.replaceSelectionWith(this.type.create({ language: o })),
                                s.setSelection(ce.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))),
                                s.insertText(
                                    n.replace(
                                        /\r\n?/g,
                                        `
`,
                                    ),
                                ),
                                s.setMeta('paste', !0),
                                t.dispatch(s),
                                !0
                            );
                        },
                    },
                }),
            ];
        },
    });
var Qh = { exports: {} };
function em(t) {
    return (
        t instanceof Map
            ? (t.clear =
                  t.delete =
                  t.set =
                      function () {
                          throw new Error('map is read-only');
                      })
            : t instanceof Set &&
              (t.add =
                  t.clear =
                  t.delete =
                      function () {
                          throw new Error('set is read-only');
                      }),
        Object.freeze(t),
        Object.getOwnPropertyNames(t).forEach(function (e) {
            var n = t[e];
            typeof n == 'object' && !Object.isFrozen(n) && em(n);
        }),
        t
    );
}
Qh.exports = em;
Qh.exports.default = em;
var lu = class {
    constructor(e) {
        e.data === void 0 && (e.data = {}), (this.data = e.data), (this.isMatchIgnored = !1);
    }
    ignoreMatch() {
        this.isMatchIgnored = !0;
    }
};
function gx(t) {
    return t
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
}
function _i(t, ...e) {
    let n = Object.create(null);
    for (let r in t) n[r] = t[r];
    return (
        e.forEach(function (r) {
            for (let i in r) n[i] = r[i];
        }),
        n
    );
}
var a2 = '</span>',
    lx = (t) => !!t.scope || (t.sublanguage && t.language),
    l2 = (t, { prefix: e }) => {
        if (t.includes('.')) {
            let n = t.split('.');
            return [`${e}${n.shift()}`, ...n.map((r, i) => `${r}${'_'.repeat(i + 1)}`)].join(' ');
        }
        return `${e}${t}`;
    },
    Jh = class {
        constructor(e, n) {
            (this.buffer = ''), (this.classPrefix = n.classPrefix), e.walk(this);
        }
        addText(e) {
            this.buffer += gx(e);
        }
        openNode(e) {
            if (!lx(e)) return;
            let n = '';
            e.sublanguage ? (n = `language-${e.language}`) : (n = l2(e.scope, { prefix: this.classPrefix })),
                this.span(n);
        }
        closeNode(e) {
            lx(e) && (this.buffer += a2);
        }
        value() {
            return this.buffer;
        }
        span(e) {
            this.buffer += `<span class="${e}">`;
        }
    },
    cx = (t = {}) => {
        let e = { children: [] };
        return Object.assign(e, t), e;
    },
    Xh = class t {
        constructor() {
            (this.rootNode = cx()), (this.stack = [this.rootNode]);
        }
        get top() {
            return this.stack[this.stack.length - 1];
        }
        get root() {
            return this.rootNode;
        }
        add(e) {
            this.top.children.push(e);
        }
        openNode(e) {
            let n = cx({ scope: e });
            this.add(n), this.stack.push(n);
        }
        closeNode() {
            if (this.stack.length > 1) return this.stack.pop();
        }
        closeAllNodes() {
            for (; this.closeNode(); );
        }
        toJSON() {
            return JSON.stringify(this.rootNode, null, 4);
        }
        walk(e) {
            return this.constructor._walk(e, this.rootNode);
        }
        static _walk(e, n) {
            return (
                typeof n == 'string'
                    ? e.addText(n)
                    : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)),
                e
            );
        }
        static _collapse(e) {
            typeof e != 'string' &&
                e.children &&
                (e.children.every((n) => typeof n == 'string')
                    ? (e.children = [e.children.join('')])
                    : e.children.forEach((n) => {
                          t._collapse(n);
                      }));
        }
    },
    Zh = class extends Xh {
        constructor(e) {
            super(), (this.options = e);
        }
        addKeyword(e, n) {
            e !== '' && (this.openNode(n), this.addText(e), this.closeNode());
        }
        addText(e) {
            e !== '' && this.add(e);
        }
        addSublanguage(e, n) {
            let r = e.root;
            (r.sublanguage = !0), (r.language = n), this.add(r);
        }
        toHTML() {
            return new Jh(this, this.options).value();
        }
        finalize() {
            return !0;
        }
    };
function ga(t) {
    return t ? (typeof t == 'string' ? t : t.source) : null;
}
function bx(t) {
    return go('(?=', t, ')');
}
function c2(t) {
    return go('(?:', t, ')*');
}
function u2(t) {
    return go('(?:', t, ')?');
}
function go(...t) {
    return t.map((n) => ga(n)).join('');
}
function d2(t) {
    let e = t[t.length - 1];
    return typeof e == 'object' && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function tm(...t) {
    return '(' + (d2(t).capture ? '' : '?:') + t.map((r) => ga(r)).join('|') + ')';
}
function yx(t) {
    return new RegExp(t.toString() + '|').exec('').length - 1;
}
function f2(t, e) {
    let n = t && t.exec(e);
    return n && n.index === 0;
}
var p2 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function nm(t, { joinWith: e }) {
    let n = 0;
    return t
        .map((r) => {
            n += 1;
            let i = n,
                o = ga(r),
                s = '';
            for (; o.length > 0; ) {
                let l = p2.exec(o);
                if (!l) {
                    s += o;
                    break;
                }
                (s += o.substring(0, l.index)),
                    (o = o.substring(l.index + l[0].length)),
                    l[0][0] === '\\' && l[1]
                        ? (s += '\\' + String(Number(l[1]) + i))
                        : ((s += l[0]), l[0] === '(' && n++);
            }
            return s;
        })
        .map((r) => `(${r})`)
        .join(e);
}
var h2 = /\b\B/,
    Ex = '[a-zA-Z]\\w*',
    rm = '[a-zA-Z_]\\w*',
    vx = '\\b\\d+(\\.\\d+)?',
    wx = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
    xx = '\\b(0b[01]+)',
    m2 =
        '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~',
    g2 = (t = {}) => {
        let e = /^#![ ]*\//;
        return (
            t.binary && (t.begin = go(e, /.*\b/, t.binary, /\b.*/)),
            _i(
                {
                    scope: 'meta',
                    begin: e,
                    end: /$/,
                    relevance: 0,
                    'on:begin': (n, r) => {
                        n.index !== 0 && r.ignoreMatch();
                    },
                },
                t,
            )
        );
    },
    ba = { begin: '\\\\[\\s\\S]', relevance: 0 },
    b2 = { scope: 'string', begin: "'", end: "'", illegal: '\\n', contains: [ba] },
    y2 = { scope: 'string', begin: '"', end: '"', illegal: '\\n', contains: [ba] },
    E2 = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
    },
    uu = function (t, e, n = {}) {
        let r = _i({ scope: 'comment', begin: t, end: e, contains: [] }, n);
        r.contains.push({
            scope: 'doctag',
            begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
            end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
            excludeBegin: !0,
            relevance: 0,
        });
        let i = tm(
            'I',
            'a',
            'is',
            'so',
            'us',
            'to',
            'at',
            'if',
            'in',
            'it',
            'on',
            /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
            /[A-Za-z]+[-][a-z]+/,
            /[A-Za-z][a-z]{2,}/,
        );
        return r.contains.push({ begin: go(/[ ]+/, '(', i, /[.]?[:]?([.][ ]|[ ])/, '){3}') }), r;
    },
    v2 = uu('//', '$'),
    w2 = uu('/\\*', '\\*/'),
    x2 = uu('#', '$'),
    _2 = { scope: 'number', begin: vx, relevance: 0 },
    S2 = { scope: 'number', begin: wx, relevance: 0 },
    T2 = { scope: 'number', begin: xx, relevance: 0 },
    M2 = {
        begin: /(?=\/[^/\n]*\/)/,
        contains: [
            {
                scope: 'regexp',
                begin: /\//,
                end: /\/[gimuy]*/,
                illegal: /\n/,
                contains: [ba, { begin: /\[/, end: /\]/, relevance: 0, contains: [ba] }],
            },
        ],
    },
    A2 = { scope: 'title', begin: Ex, relevance: 0 },
    C2 = { scope: 'title', begin: rm, relevance: 0 },
    k2 = { begin: '\\.\\s*' + rm, relevance: 0 },
    N2 = function (t) {
        return Object.assign(t, {
            'on:begin': (e, n) => {
                n.data._beginMatch = e[1];
            },
            'on:end': (e, n) => {
                n.data._beginMatch !== e[1] && n.ignoreMatch();
            },
        });
    },
    au = Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: h2,
        IDENT_RE: Ex,
        UNDERSCORE_IDENT_RE: rm,
        NUMBER_RE: vx,
        C_NUMBER_RE: wx,
        BINARY_NUMBER_RE: xx,
        RE_STARTERS_RE: m2,
        SHEBANG: g2,
        BACKSLASH_ESCAPE: ba,
        APOS_STRING_MODE: b2,
        QUOTE_STRING_MODE: y2,
        PHRASAL_WORDS_MODE: E2,
        COMMENT: uu,
        C_LINE_COMMENT_MODE: v2,
        C_BLOCK_COMMENT_MODE: w2,
        HASH_COMMENT_MODE: x2,
        NUMBER_MODE: _2,
        C_NUMBER_MODE: S2,
        BINARY_NUMBER_MODE: T2,
        REGEXP_MODE: M2,
        TITLE_MODE: A2,
        UNDERSCORE_TITLE_MODE: C2,
        METHOD_GUARD: k2,
        END_SAME_AS_BEGIN: N2,
    });
function O2(t, e) {
    t.input[t.index - 1] === '.' && e.ignoreMatch();
}
function R2(t, e) {
    t.className !== void 0 && ((t.scope = t.className), delete t.className);
}
function I2(t, e) {
    e &&
        t.beginKeywords &&
        ((t.begin = '\\b(' + t.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)'),
        (t.__beforeBegin = O2),
        (t.keywords = t.keywords || t.beginKeywords),
        delete t.beginKeywords,
        t.relevance === void 0 && (t.relevance = 0));
}
function L2(t, e) {
    Array.isArray(t.illegal) && (t.illegal = tm(...t.illegal));
}
function D2(t, e) {
    if (t.match) {
        if (t.begin || t.end) throw new Error('begin & end are not supported with match');
        (t.begin = t.match), delete t.match;
    }
}
function P2(t, e) {
    t.relevance === void 0 && (t.relevance = 1);
}
var B2 = (t, e) => {
        if (!t.beforeMatch) return;
        if (t.starts) throw new Error('beforeMatch cannot be used with starts');
        let n = Object.assign({}, t);
        Object.keys(t).forEach((r) => {
            delete t[r];
        }),
            (t.keywords = n.keywords),
            (t.begin = go(n.beforeMatch, bx(n.begin))),
            (t.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: !0 })] }),
            (t.relevance = 0),
            delete n.beforeMatch;
    },
    F2 = ['of', 'and', 'for', 'in', 'not', 'or', 'if', 'then', 'parent', 'list', 'value'],
    H2 = 'keyword';
function _x(t, e, n = H2) {
    let r = Object.create(null);
    return (
        typeof t == 'string'
            ? i(n, t.split(' '))
            : Array.isArray(t)
              ? i(n, t)
              : Object.keys(t).forEach(function (o) {
                    Object.assign(r, _x(t[o], e, o));
                }),
        r
    );
    function i(o, s) {
        e && (s = s.map((l) => l.toLowerCase())),
            s.forEach(function (l) {
                let u = l.split('|');
                r[u[0]] = [o, z2(u[0], u[1])];
            });
    }
}
function z2(t, e) {
    return e ? Number(e) : $2(t) ? 0 : 1;
}
function $2(t) {
    return F2.includes(t.toLowerCase());
}
var ux = {},
    mo = (t) => {
        console.error(t);
    },
    dx = (t, ...e) => {
        console.log(`WARN: ${t}`, ...e);
    },
    ss = (t, e) => {
        ux[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), (ux[`${t}/${e}`] = !0));
    },
    cu = new Error();
function Sx(t, e, { key: n }) {
    let r = 0,
        i = t[n],
        o = {},
        s = {};
    for (let l = 1; l <= e.length; l++) (s[l + r] = i[l]), (o[l + r] = !0), (r += yx(e[l - 1]));
    (t[n] = s), (t[n]._emit = o), (t[n]._multi = !0);
}
function U2(t) {
    if (Array.isArray(t.begin)) {
        if (t.skip || t.excludeBegin || t.returnBegin)
            throw (mo('skip, excludeBegin, returnBegin not compatible with beginScope: {}'), cu);
        if (typeof t.beginScope != 'object' || t.beginScope === null) throw (mo('beginScope must be object'), cu);
        Sx(t, t.begin, { key: 'beginScope' }), (t.begin = nm(t.begin, { joinWith: '' }));
    }
}
function W2(t) {
    if (Array.isArray(t.end)) {
        if (t.skip || t.excludeEnd || t.returnEnd)
            throw (mo('skip, excludeEnd, returnEnd not compatible with endScope: {}'), cu);
        if (typeof t.endScope != 'object' || t.endScope === null) throw (mo('endScope must be object'), cu);
        Sx(t, t.end, { key: 'endScope' }), (t.end = nm(t.end, { joinWith: '' }));
    }
}
function K2(t) {
    t.scope && typeof t.scope == 'object' && t.scope !== null && ((t.beginScope = t.scope), delete t.scope);
}
function V2(t) {
    K2(t),
        typeof t.beginScope == 'string' && (t.beginScope = { _wrap: t.beginScope }),
        typeof t.endScope == 'string' && (t.endScope = { _wrap: t.endScope }),
        U2(t),
        W2(t);
}
function G2(t) {
    function e(s, l) {
        return new RegExp(ga(s), 'm' + (t.case_insensitive ? 'i' : '') + (t.unicodeRegex ? 'u' : '') + (l ? 'g' : ''));
    }
    class n {
        constructor() {
            (this.matchIndexes = {}), (this.regexes = []), (this.matchAt = 1), (this.position = 0);
        }
        addRule(l, u) {
            (u.position = this.position++),
                (this.matchIndexes[this.matchAt] = u),
                this.regexes.push([u, l]),
                (this.matchAt += yx(l) + 1);
        }
        compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            let l = this.regexes.map((u) => u[1]);
            (this.matcherRe = e(nm(l, { joinWith: '|' }), !0)), (this.lastIndex = 0);
        }
        exec(l) {
            this.matcherRe.lastIndex = this.lastIndex;
            let u = this.matcherRe.exec(l);
            if (!u) return null;
            let d = u.findIndex((h, m) => m > 0 && h !== void 0),
                f = this.matchIndexes[d];
            return u.splice(0, d), Object.assign(u, f);
        }
    }
    class r {
        constructor() {
            (this.rules = []), (this.multiRegexes = []), (this.count = 0), (this.lastIndex = 0), (this.regexIndex = 0);
        }
        getMatcher(l) {
            if (this.multiRegexes[l]) return this.multiRegexes[l];
            let u = new n();
            return this.rules.slice(l).forEach(([d, f]) => u.addRule(d, f)), u.compile(), (this.multiRegexes[l] = u), u;
        }
        resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
        }
        considerAll() {
            this.regexIndex = 0;
        }
        addRule(l, u) {
            this.rules.push([l, u]), u.type === 'begin' && this.count++;
        }
        exec(l) {
            let u = this.getMatcher(this.regexIndex);
            u.lastIndex = this.lastIndex;
            let d = u.exec(l);
            if (this.resumingScanAtSamePosition() && !(d && d.index === this.lastIndex)) {
                let f = this.getMatcher(0);
                (f.lastIndex = this.lastIndex + 1), (d = f.exec(l));
            }
            return d && ((this.regexIndex += d.position + 1), this.regexIndex === this.count && this.considerAll()), d;
        }
    }
    function i(s) {
        let l = new r();
        return (
            s.contains.forEach((u) => l.addRule(u.begin, { rule: u, type: 'begin' })),
            s.terminatorEnd && l.addRule(s.terminatorEnd, { type: 'end' }),
            s.illegal && l.addRule(s.illegal, { type: 'illegal' }),
            l
        );
    }
    function o(s, l) {
        let u = s;
        if (s.isCompiled) return u;
        [R2, D2, V2, B2].forEach((f) => f(s, l)),
            t.compilerExtensions.forEach((f) => f(s, l)),
            (s.__beforeBegin = null),
            [I2, L2, P2].forEach((f) => f(s, l)),
            (s.isCompiled = !0);
        let d = null;
        return (
            typeof s.keywords == 'object' &&
                s.keywords.$pattern &&
                ((s.keywords = Object.assign({}, s.keywords)), (d = s.keywords.$pattern), delete s.keywords.$pattern),
            (d = d || /\w+/),
            s.keywords && (s.keywords = _x(s.keywords, t.case_insensitive)),
            (u.keywordPatternRe = e(d, !0)),
            l &&
                (s.begin || (s.begin = /\B|\b/),
                (u.beginRe = e(u.begin)),
                !s.end && !s.endsWithParent && (s.end = /\B|\b/),
                s.end && (u.endRe = e(u.end)),
                (u.terminatorEnd = ga(u.end) || ''),
                s.endsWithParent && l.terminatorEnd && (u.terminatorEnd += (s.end ? '|' : '') + l.terminatorEnd)),
            s.illegal && (u.illegalRe = e(s.illegal)),
            s.contains || (s.contains = []),
            (s.contains = [].concat(
                ...s.contains.map(function (f) {
                    return q2(f === 'self' ? s : f);
                }),
            )),
            s.contains.forEach(function (f) {
                o(f, u);
            }),
            s.starts && o(s.starts, l),
            (u.matcher = i(u)),
            u
        );
    }
    if ((t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes('self')))
        throw new Error('ERR: contains `self` is not supported at the top-level of a language.  See documentation.');
    return (t.classNameAliases = _i(t.classNameAliases || {})), o(t);
}
function Tx(t) {
    return t ? t.endsWithParent || Tx(t.starts) : !1;
}
function q2(t) {
    return (
        t.variants &&
            !t.cachedVariants &&
            (t.cachedVariants = t.variants.map(function (e) {
                return _i(t, { variants: null }, e);
            })),
        t.cachedVariants
            ? t.cachedVariants
            : Tx(t)
              ? _i(t, { starts: t.starts ? _i(t.starts) : null })
              : Object.isFrozen(t)
                ? _i(t)
                : t
    );
}
var Y2 = '11.6.0',
    jh = class extends Error {
        constructor(e, n) {
            super(e), (this.name = 'HTMLInjectionError'), (this.html = n);
        }
    },
    Yh = gx,
    fx = _i,
    px = Symbol('nomatch'),
    J2 = 7,
    X2 = function (t) {
        let e = Object.create(null),
            n = Object.create(null),
            r = [],
            i = !0,
            o = "Could not find the language '{}', did you forget to load/include a language module?",
            s = { disableAutodetect: !0, name: 'Plain text', contains: [] },
            l = {
                ignoreUnescapedHTML: !1,
                throwUnescapedHTML: !1,
                noHighlightRe: /^(no-?highlight)$/i,
                languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
                classPrefix: 'hljs-',
                cssSelector: 'pre code',
                languages: null,
                __emitter: Zh,
            };
        function u(P) {
            return l.noHighlightRe.test(P);
        }
        function d(P) {
            let O = P.className + ' ';
            O += P.parentNode ? P.parentNode.className : '';
            let R = l.languageDetectRe.exec(O);
            if (R) {
                let V = $(R[1]);
                return (
                    V || (dx(o.replace('{}', R[1])), dx('Falling back to no-highlight mode for this block.', P)),
                    V ? R[1] : 'no-highlight'
                );
            }
            return O.split(/\s+/).find((V) => u(V) || $(V));
        }
        function f(P, O, R) {
            let V = '',
                Q = '';
            typeof O == 'object'
                ? ((V = P), (R = O.ignoreIllegals), (Q = O.language))
                : (ss('10.7.0', 'highlight(lang, code, ...args) has been deprecated.'),
                  ss(
                      '10.7.0',
                      `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`,
                  ),
                  (Q = P),
                  (V = O)),
                R === void 0 && (R = !0);
            let he = { code: V, language: Q };
            Me('before:highlight', he);
            let xe = he.result ? he.result : h(he.language, he.code, R);
            return (xe.code = he.code), Me('after:highlight', xe), xe;
        }
        function h(P, O, R, V) {
            let Q = Object.create(null);
            function he(J, re) {
                return J.keywords[re];
            }
            function xe() {
                if (!be.keywords) {
                    ee.addText(Ce);
                    return;
                }
                let J = 0;
                be.keywordPatternRe.lastIndex = 0;
                let re = be.keywordPatternRe.exec(Ce),
                    H = '';
                for (; re; ) {
                    H += Ce.substring(J, re.index);
                    let Y = St.case_insensitive ? re[0].toLowerCase() : re[0],
                        ue = he(be, Y);
                    if (ue) {
                        let [Ae, ct] = ue;
                        if (
                            (ee.addText(H),
                            (H = ''),
                            (Q[Y] = (Q[Y] || 0) + 1),
                            Q[Y] <= J2 && (Ke += ct),
                            Ae.startsWith('_'))
                        )
                            H += re[0];
                        else {
                            let Vt = St.classNameAliases[Ae] || Ae;
                            ee.addKeyword(re[0], Vt);
                        }
                    } else H += re[0];
                    (J = be.keywordPatternRe.lastIndex), (re = be.keywordPatternRe.exec(Ce));
                }
                (H += Ce.substring(J)), ee.addText(H);
            }
            function Ue() {
                if (Ce === '') return;
                let J = null;
                if (typeof be.subLanguage == 'string') {
                    if (!e[be.subLanguage]) {
                        ee.addText(Ce);
                        return;
                    }
                    (J = h(be.subLanguage, Ce, !0, Kt[be.subLanguage])), (Kt[be.subLanguage] = J._top);
                } else J = b(Ce, be.subLanguage.length ? be.subLanguage : null);
                be.relevance > 0 && (Ke += J.relevance), ee.addSublanguage(J._emitter, J.language);
            }
            function We() {
                be.subLanguage != null ? Ue() : xe(), (Ce = '');
            }
            function He(J, re) {
                let H = 1,
                    Y = re.length - 1;
                for (; H <= Y; ) {
                    if (!J._emit[H]) {
                        H++;
                        continue;
                    }
                    let ue = St.classNameAliases[J[H]] || J[H],
                        Ae = re[H];
                    ue ? ee.addKeyword(Ae, ue) : ((Ce = Ae), xe(), (Ce = '')), H++;
                }
            }
            function Xe(J, re) {
                return (
                    J.scope && typeof J.scope == 'string' && ee.openNode(St.classNameAliases[J.scope] || J.scope),
                    J.beginScope &&
                        (J.beginScope._wrap
                            ? (ee.addKeyword(Ce, St.classNameAliases[J.beginScope._wrap] || J.beginScope._wrap),
                              (Ce = ''))
                            : J.beginScope._multi && (He(J.beginScope, re), (Ce = ''))),
                    (be = Object.create(J, { parent: { value: be } })),
                    be
                );
            }
            function xt(J, re, H) {
                let Y = f2(J.endRe, H);
                if (Y) {
                    if (J['on:end']) {
                        let ue = new lu(J);
                        J['on:end'](re, ue), ue.isMatchIgnored && (Y = !1);
                    }
                    if (Y) {
                        for (; J.endsParent && J.parent; ) J = J.parent;
                        return J;
                    }
                }
                if (J.endsWithParent) return xt(J.parent, re, H);
            }
            function Pt(J) {
                return be.matcher.regexIndex === 0 ? ((Ce += J[0]), 1) : ((Ot = !0), 0);
            }
            function De(J) {
                let re = J[0],
                    H = J.rule,
                    Y = new lu(H),
                    ue = [H.__beforeBegin, H['on:begin']];
                for (let Ae of ue) if (Ae && (Ae(J, Y), Y.isMatchIgnored)) return Pt(re);
                return (
                    H.skip
                        ? (Ce += re)
                        : (H.excludeBegin && (Ce += re), We(), !H.returnBegin && !H.excludeBegin && (Ce = re)),
                    Xe(H, J),
                    H.returnBegin ? 0 : re.length
                );
            }
            function _t(J) {
                let re = J[0],
                    H = O.substring(J.index),
                    Y = xt(be, J, H);
                if (!Y) return px;
                let ue = be;
                be.endScope && be.endScope._wrap
                    ? (We(), ee.addKeyword(re, be.endScope._wrap))
                    : be.endScope && be.endScope._multi
                      ? (We(), He(be.endScope, J))
                      : ue.skip
                        ? (Ce += re)
                        : (ue.returnEnd || ue.excludeEnd || (Ce += re), We(), ue.excludeEnd && (Ce = re));
                do be.scope && ee.closeNode(), !be.skip && !be.subLanguage && (Ke += be.relevance), (be = be.parent);
                while (be !== Y.parent);
                return Y.starts && Xe(Y.starts, J), ue.returnEnd ? 0 : re.length;
            }
            function Zt() {
                let J = [];
                for (let re = be; re !== St; re = re.parent) re.scope && J.unshift(re.scope);
                J.forEach((re) => ee.openNode(re));
            }
            let st = {};
            function jt(J, re) {
                let H = re && re[0];
                if (((Ce += J), H == null)) return We(), 0;
                if (st.type === 'begin' && re.type === 'end' && st.index === re.index && H === '') {
                    if (((Ce += O.slice(re.index, re.index + 1)), !i)) {
                        let Y = new Error(`0 width match regex (${P})`);
                        throw ((Y.languageName = P), (Y.badRule = st.rule), Y);
                    }
                    return 1;
                }
                if (((st = re), re.type === 'begin')) return De(re);
                if (re.type === 'illegal' && !R) {
                    let Y = new Error('Illegal lexeme "' + H + '" for mode "' + (be.scope || '<unnamed>') + '"');
                    throw ((Y.mode = be), Y);
                } else if (re.type === 'end') {
                    let Y = _t(re);
                    if (Y !== px) return Y;
                }
                if (re.type === 'illegal' && H === '') return 1;
                if (mt > 1e5 && mt > re.index * 3)
                    throw new Error('potential infinite loop, way more iterations than matches');
                return (Ce += H), H.length;
            }
            let St = $(P);
            if (!St) throw (mo(o.replace('{}', P)), new Error('Unknown language: "' + P + '"'));
            let Nt = G2(St),
                ft = '',
                be = V || Nt,
                Kt = {},
                ee = new l.__emitter(l);
            Zt();
            let Ce = '',
                Ke = 0,
                Re = 0,
                mt = 0,
                Ot = !1;
            try {
                for (be.matcher.considerAll(); ; ) {
                    mt++, Ot ? (Ot = !1) : be.matcher.considerAll(), (be.matcher.lastIndex = Re);
                    let J = be.matcher.exec(O);
                    if (!J) break;
                    let re = O.substring(Re, J.index),
                        H = jt(re, J);
                    Re = J.index + H;
                }
                return (
                    jt(O.substring(Re)),
                    ee.closeAllNodes(),
                    ee.finalize(),
                    (ft = ee.toHTML()),
                    { language: P, value: ft, relevance: Ke, illegal: !1, _emitter: ee, _top: be }
                );
            } catch (J) {
                if (J.message && J.message.includes('Illegal'))
                    return {
                        language: P,
                        value: Yh(O),
                        illegal: !0,
                        relevance: 0,
                        _illegalBy: {
                            message: J.message,
                            index: Re,
                            context: O.slice(Re - 100, Re + 100),
                            mode: J.mode,
                            resultSoFar: ft,
                        },
                        _emitter: ee,
                    };
                if (i)
                    return {
                        language: P,
                        value: Yh(O),
                        illegal: !1,
                        relevance: 0,
                        errorRaised: J,
                        _emitter: ee,
                        _top: be,
                    };
                throw J;
            }
        }
        function m(P) {
            let O = { value: Yh(P), illegal: !1, relevance: 0, _top: s, _emitter: new l.__emitter(l) };
            return O._emitter.addText(P), O;
        }
        function b(P, O) {
            O = O || l.languages || Object.keys(e);
            let R = m(P),
                V = O.filter($)
                    .filter(me)
                    .map((We) => h(We, P, !1));
            V.unshift(R);
            let Q = V.sort((We, He) => {
                    if (We.relevance !== He.relevance) return He.relevance - We.relevance;
                    if (We.language && He.language) {
                        if ($(We.language).supersetOf === He.language) return 1;
                        if ($(He.language).supersetOf === We.language) return -1;
                    }
                    return 0;
                }),
                [he, xe] = Q,
                Ue = he;
            return (Ue.secondBest = xe), Ue;
        }
        function y(P, O, R) {
            let V = (O && n[O]) || R;
            P.classList.add('hljs'), P.classList.add(`language-${V}`);
        }
        function v(P) {
            let O = null,
                R = d(P);
            if (u(R)) return;
            if (
                (Me('before:highlightElement', { el: P, language: R }),
                P.children.length > 0 &&
                    (l.ignoreUnescapedHTML ||
                        (console.warn(
                            'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.',
                        ),
                        console.warn('https://github.com/highlightjs/highlight.js/wiki/security'),
                        console.warn('The element with unescaped HTML:'),
                        console.warn(P)),
                    l.throwUnescapedHTML))
            )
                throw new jh('One of your code blocks includes unescaped HTML.', P.innerHTML);
            O = P;
            let V = O.textContent,
                Q = R ? f(V, { language: R, ignoreIllegals: !0 }) : b(V);
            (P.innerHTML = Q.value),
                y(P, R, Q.language),
                (P.result = { language: Q.language, re: Q.relevance, relevance: Q.relevance }),
                Q.secondBest && (P.secondBest = { language: Q.secondBest.language, relevance: Q.secondBest.relevance }),
                Me('after:highlightElement', { el: P, result: Q, text: V });
        }
        function x(P) {
            l = fx(l, P);
        }
        let T = () => {
            S(), ss('10.6.0', 'initHighlighting() deprecated.  Use highlightAll() now.');
        };
        function D() {
            S(), ss('10.6.0', 'initHighlightingOnLoad() deprecated.  Use highlightAll() now.');
        }
        let I = !1;
        function S() {
            if (document.readyState === 'loading') {
                I = !0;
                return;
            }
            document.querySelectorAll(l.cssSelector).forEach(v);
        }
        function z() {
            I && S();
        }
        typeof window < 'u' && window.addEventListener && window.addEventListener('DOMContentLoaded', z, !1);
        function N(P, O) {
            let R = null;
            try {
                R = O(t);
            } catch (V) {
                if ((mo("Language definition for '{}' could not be registered.".replace('{}', P)), i)) mo(V);
                else throw V;
                R = s;
            }
            R.name || (R.name = P),
                (e[P] = R),
                (R.rawDefinition = O.bind(null, t)),
                R.aliases && oe(R.aliases, { languageName: P });
        }
        function q(P) {
            delete e[P];
            for (let O of Object.keys(n)) n[O] === P && delete n[O];
        }
        function ne() {
            return Object.keys(e);
        }
        function $(P) {
            return (P = (P || '').toLowerCase()), e[P] || e[n[P]];
        }
        function oe(P, { languageName: O }) {
            typeof P == 'string' && (P = [P]),
                P.forEach((R) => {
                    n[R.toLowerCase()] = O;
                });
        }
        function me(P) {
            let O = $(P);
            return O && !O.disableAutodetect;
        }
        function Te(P) {
            P['before:highlightBlock'] &&
                !P['before:highlightElement'] &&
                (P['before:highlightElement'] = (O) => {
                    P['before:highlightBlock'](Object.assign({ block: O.el }, O));
                }),
                P['after:highlightBlock'] &&
                    !P['after:highlightElement'] &&
                    (P['after:highlightElement'] = (O) => {
                        P['after:highlightBlock'](Object.assign({ block: O.el }, O));
                    });
        }
        function ge(P) {
            Te(P), r.push(P);
        }
        function Me(P, O) {
            let R = P;
            r.forEach(function (V) {
                V[R] && V[R](O);
            });
        }
        function Ee(P) {
            return (
                ss('10.7.0', 'highlightBlock will be removed entirely in v12.0'),
                ss('10.7.0', 'Please use highlightElement now.'),
                v(P)
            );
        }
        Object.assign(t, {
            highlight: f,
            highlightAuto: b,
            highlightAll: S,
            highlightElement: v,
            highlightBlock: Ee,
            configure: x,
            initHighlighting: T,
            initHighlightingOnLoad: D,
            registerLanguage: N,
            unregisterLanguage: q,
            listLanguages: ne,
            getLanguage: $,
            registerAliases: oe,
            autoDetection: me,
            inherit: fx,
            addPlugin: ge,
        }),
            (t.debugMode = function () {
                i = !1;
            }),
            (t.safeMode = function () {
                i = !0;
            }),
            (t.versionString = Y2),
            (t.regex = { concat: go, lookahead: bx, either: tm, optional: u2, anyNumberOfTimes: c2 });
        for (let P in au) typeof au[P] == 'object' && Qh.exports(au[P]);
        return Object.assign(t, au), t;
    },
    ya = X2({}),
    Z2 = ya;
ya.HighlightJS = ya;
ya.default = ya;
var j2 = Z2;
function Mx(t, e = []) {
    return t
        .map((n) => {
            let r = [...e, ...(n.properties ? n.properties.className : [])];
            return n.children ? Mx(n.children, r) : { text: n.value, classes: r };
        })
        .flat();
}
function hx(t) {
    return t.value || t.children || [];
}
function Q2(t) {
    return !!j2.getLanguage(t);
}
function mx({ doc: t, name: e, lowlight: n, defaultLanguage: r }) {
    let i = [];
    return (
        Qi(t, (o) => o.type.name === e).forEach((o) => {
            let s = o.pos + 1,
                l = o.node.attrs.language || r,
                u = n.listLanguages(),
                d =
                    l && (u.includes(l) || Q2(l))
                        ? hx(n.highlight(l, o.node.textContent))
                        : hx(n.highlightAuto(o.node.textContent));
            Mx(d).forEach((f) => {
                let h = s + f.text.length;
                if (f.classes.length) {
                    let m = Mt.inline(s, h, { class: f.classes.join(' ') });
                    i.push(m);
                }
                s = h;
            });
        }),
        lt.create(t, i)
    );
}
function eF(t) {
    return typeof t == 'function';
}
function tF({ name: t, lowlight: e, defaultLanguage: n }) {
    if (!['highlight', 'highlightAuto', 'listLanguages'].every((i) => eF(e[i])))
        throw Error('You should provide an instance of lowlight to use the code-block-lowlight extension');
    let r = new Oe({
        key: new ze('lowlight'),
        state: {
            init: (i, { doc: o }) => mx({ doc: o, name: t, lowlight: e, defaultLanguage: n }),
            apply: (i, o, s, l) => {
                let u = s.selection.$head.parent.type.name,
                    d = l.selection.$head.parent.type.name,
                    f = Qi(s.doc, (m) => m.type.name === t),
                    h = Qi(l.doc, (m) => m.type.name === t);
                return i.docChanged &&
                    ([u, d].includes(t) ||
                        h.length !== f.length ||
                        i.steps.some(
                            (m) =>
                                m.from !== void 0 &&
                                m.to !== void 0 &&
                                f.some((b) => b.pos >= m.from && b.pos + b.node.nodeSize <= m.to),
                        ))
                    ? mx({ doc: i.doc, name: t, lowlight: e, defaultLanguage: n })
                    : o.map(i.mapping, i.doc);
            },
        },
        props: {
            decorations(i) {
                return r.getState(i);
            },
        },
    });
    return r;
}
var Ax = ax.extend({
    addOptions() {
        var t;
        return {
            ...((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)),
            lowlight: {},
            defaultLanguage: null,
        };
    },
    addProseMirrorPlugins() {
        var t;
        return [
            ...(((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)) || []),
            tF({ name: this.name, lowlight: this.options.lowlight, defaultLanguage: this.options.defaultLanguage }),
        ];
    },
});
var im = Ax.extend({
    addKeyboardShortcuts() {
        return {
            ...this.parent?.(),
            ArrowDown: () => {
                let t = this.editor.state,
                    { from: e, to: n } = t.selection;
                if (e > 1 && e === n) {
                    let r = !1;
                    t.doc.nodesBetween(e - 1, n - 1, (o) => {
                        o.type.name === 'codeBlock' && (r = !0);
                    });
                    let i = !0;
                    if (
                        (t.doc.nodesBetween(e + 1, n + 1, (o) => {
                            o && (i = !1);
                        }),
                        r && i)
                    )
                        return this.editor.commands.setHardBreak();
                }
                return !1;
            },
        };
    },
});
var om = ae.create({
    name: 'hurdle',
    group: 'block',
    content: 'block+',
    addOptions() {
        return {
            colors: ['gray_light', 'gray', 'gray_dark', 'primary', 'secondary', 'tertiary', 'accent'],
            HTMLAttributes: { class: 'filament-tiptap-hurdle' },
        };
    },
    addAttributes() {
        return {
            color: {
                default: 'gray',
                parseHTML: (t) => t.getAttribute('data-color'),
                renderHTML: (t) => ({ 'data-color': t.color }),
            },
        };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('filament-tiptap-hurdle') }];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
        return ['div', Z(this.options.HTMLAttributes, e), 0];
    },
    addCommands() {
        return {
            setHurdle:
                (t) =>
                ({ commands: e }) =>
                    this.options.colors.includes(t.color) ? e.toggleWrap(this.name, t) : !1,
        };
    },
});
var sm = Ge.create({
    name: 'textAlign',
    addOptions() {
        return { types: [], alignments: ['start', 'center', 'end', 'justify'], defaultAlignment: 'start' };
    },
    addGlobalAttributes() {
        return [
            {
                types: this.options.types,
                attributes: {
                    textAlign: {
                        default: this.options.defaultAlignment,
                        parseHTML: (t) => t.style.textAlign || this.options.defaultAlignment,
                        renderHTML: (t) =>
                            t.textAlign === this.options.defaultAlignment
                                ? {}
                                : { style: `text-align: ${t.textAlign}` },
                    },
                },
            },
        ];
    },
    addCommands() {
        return {
            setTextAlign:
                (t) =>
                ({ commands: e }) =>
                    this.options.alignments.includes(t)
                        ? this.options.types.every((n) => e.updateAttributes(n, { textAlign: t }))
                        : !1,
            unsetTextAlign:
                () =>
                ({ commands: t }) =>
                    this.options.types.every((e) => t.resetAttributes(e, 'textAlign')),
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-l': () => this.editor.commands.setTextAlign('start'),
            'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),
            'Mod-Shift-r': () => this.editor.commands.setTextAlign('end'),
            'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify'),
        };
    },
});
function du(t, e, n = null) {
    return n ? t.createChecked({ 'data-col-span': e }, n) : t.createAndFill({ 'data-col-span': e });
}
function Cx(t) {
    if (t.cached.gridBuilderNodeTypes) return t.cached.gridBuilderNodeTypes;
    let e = {};
    return (
        Object.keys(t.nodes).forEach((n) => {
            let r = t.nodes[n];
            r.spec.gridBuilderRole && (e[r.spec.gridBuilderRole] = r);
        }),
        (t.cached.gridBuilderNodeTypes = e),
        e
    );
}
function kx(t, e, n, r, i, o, s) {
    let l = Cx(t),
        u = [];
    if (n === 'asymmetric') u.push(du(l.builderColumn, i, s)), u.push(du(l.builderColumn, o, s));
    else
        for (let d = 0; d < e; d += 1) {
            let f = du(l.builderColumn, null, s);
            f && u.push(f);
        }
    return l.gridBuilder.createChecked({ 'data-cols': e, 'data-type': n, 'data-stack-at': r }, u);
}
var am = ae.create({
    name: 'gridBuilder',
    group: 'block',
    defining: !0,
    isolating: !0,
    allowGapCursor: !1,
    content: 'gridBuilderColumn+',
    gridBuilderRole: 'gridBuilder',
    addOptions() {
        return { HTMLAttributes: { class: 'filament-tiptap-grid-builder' } };
    },
    addAttributes() {
        return {
            'data-type': { default: 'responsive', parseHTML: (t) => t.getAttribute('data-type') },
            'data-cols': { default: 2, parseHTML: (t) => t.getAttribute('data-cols') },
            'data-stack-at': { default: 'md', parseHTML: (t) => t.getAttribute('data-stack-at') },
            style: {
                default: null,
                parseHTML: (t) => t.getAttribute('style'),
                renderHTML: (t) => ({ style: `grid-template-columns: repeat(${t['data-cols']}, 1fr);` }),
            },
        };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('filament-tiptap-grid-builder') && null }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['div', Z(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
        return {
            insertGridBuilder:
                ({
                    cols: t = 3,
                    type: e = 'responsive',
                    stackAt: n,
                    asymmetricLeft: r = null,
                    asymmetricRight: i = null,
                } = {}) =>
                ({ tr: o, dispatch: s, editor: l }) => {
                    let u = kx(l.schema, t, e, n, r, i);
                    if (s) {
                        let d = o.selection.anchor + 1;
                        o.replaceSelectionWith(u)
                            .scrollIntoView()
                            .setSelection(ce.near(o.doc.resolve(d)));
                    }
                    return !0;
                },
        };
    },
    addKeyboardShortcuts() {
        return { 'Mod-Alt-G': () => this.editor.commands.insertGridBuilder() };
    },
    extendNodeSchema(t) {
        let e = { name: t.name, options: t.options, storage: t.storage };
        return { gridBuilderRole: Se(ie(t, 'gridBuilderRole', e)) };
    },
});
var lm = ae.create({
    name: 'gridBuilderColumn',
    content: 'block+',
    gridBuilderRole: 'builderColumn',
    isolating: !0,
    addOptions() {
        return { HTMLAttributes: { class: 'filament-tiptap-grid-builder__column' } };
    },
    addAttributes() {
        return {
            'data-col-span': { default: 1, parseHTML: (t) => t.getAttribute('data-col-span') },
            style: {
                default: null,
                parseHTML: (t) => t.getAttribute('style'),
                renderHTML: (t) => ({ style: `grid-column: span ${t['data-col-span']};` }),
            },
        };
    },
    parseHTML() {
        return [{ tag: 'div', getAttrs: (t) => t.classList.contains('filament-tiptap-grid-builder__column') && null }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['div', Z(this.options.HTMLAttributes, t), 0];
    },
});
var cm = Ge.create({
    name: 'dragAndDrop',
    addProseMirrorPlugins(t) {
        return [
            new Oe({
                props: {
                    handleDrop(e, n) {
                        if (!n) return !1;
                        n.preventDefault();
                        let r = e.posAtCoords({ left: n.clientX, top: n.clientY });
                        return n.dataTransfer.getData('block')
                            ? (n.target.dispatchEvent(
                                  new CustomEvent('dragged-block', {
                                      detail: { type: n.dataTransfer.getData('block'), coordinates: r },
                                      bubbles: !0,
                                  }),
                              ),
                              !1)
                            : (n.dataTransfer.getData('mergeTag') &&
                                  n.target.dispatchEvent(
                                      new CustomEvent('dragged-merge-tag', {
                                          detail: { tag: n.dataTransfer.getData('mergeTag'), coordinates: r },
                                          bubbles: !0,
                                      }),
                                  ),
                              !1);
                    },
                },
            }),
        ];
    },
});
var um = ae.create({
    name: 'tiptapBlock',
    group: 'block',
    atom: !0,
    defining: !0,
    draggable: !0,
    selectable: !0,
    isolating: !0,
    allowGapCursor: !0,
    inline: !1,
    addAttributes() {
        return {
            preview: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-preview'),
                renderHTML: (t) => (t.preview ? { 'data-preview': t.preview } : null),
            },
            statePath: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-state-path'),
                renderHTML: (t) => (t.statePath ? { 'data-state-path': t.statePath } : null),
            },
            type: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-type'),
                renderHTML: (t) => (t.type ? { 'data-type': t.type } : null),
            },
            label: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-label'),
                renderHTML: (t) => (t.label ? { 'data-label': t.label } : null),
            },
            data: {
                default: null,
                parseHTML: (t) => t.getAttribute('data-data'),
                renderHTML: (t) => (t.data ? { 'data-data': JSON.stringify(t.data) } : null),
            },
        };
    },
    parseHTML() {
        return [{ tag: 'tiptap-block' }];
    },
    renderHTML({ HTMLAttributes: t }) {
        return ['tiptap-block', Z(t)];
    },
    addNodeView() {
        return ({ node: t }) => {
            let e = document.createElement('div');
            (e.contentEditable = 'false'), e.classList.add('tiptap-block-wrapper');
            let n = typeof t.attrs.data == 'object' ? JSON.stringify(t.attrs.data) : t.attrs.data;
            return (
                (e.innerHTML = `
                <div
                    x-data="{
                        showOptionsButton: ${n === '[]' ? 'false' : 'true'},
                        openSettings() {
                            this.$dispatch('open-block-settings', {
                                type: \`${t.attrs.type}\`,
                                statePath: \`${t.attrs.statePath}\`,
                                data: ${n},
                            })
                        },
                        deleteBlock() {
                            this.$dispatch('delete-block')
                        }
                    }"
                    class="tiptap-block"
                    style="min-height: 3rem;"
                >
                    <div class="tiptap-block-heading">
                        <h3 class="tiptap-block-title">${t.attrs.label}</h3>
                        <div x-show="! disabled" class="tiptap-block-actions">
                            <button x-show="showOptionsButton" type="button" x-on:click="openSettings">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M7.84 1.804A1 1 0 018.82 1h2.36a1 1 0 01.98.804l.331 1.652a6.993 6.993 0 011.929 1.115l1.598-.54a1 1 0 011.186.447l1.18 2.044a1 1 0 01-.205 1.251l-1.267 1.113a7.047 7.047 0 010 2.228l1.267 1.113a1 1 0 01.206 1.25l-1.18 2.045a1 1 0 01-1.187.447l-1.598-.54a6.993 6.993 0 01-1.929 1.115l-.33 1.652a1 1 0 01-.98.804H8.82a1 1 0 01-.98-.804l-.331-1.652a6.993 6.993 0 01-1.929-1.115l-1.598.54a1 1 0 01-1.186-.447l-1.18-2.044a1 1 0 01.205-1.251l1.267-1.114a7.05 7.05 0 010-2.227L1.821 7.773a1 1 0 01-.206-1.25l1.18-2.045a1 1 0 011.187-.447l1.598.54A6.993 6.993 0 017.51 3.456l.33-1.652zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button type="button" x-on:click="deleteBlock()">
                                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="preview">
                        ${t.attrs.preview}
                    </div>
                </div>
            `),
                { dom: e }
            );
        };
    },
    addCommands() {
        return {
            insertBlock:
                (t) =>
                ({ chain: e, state: n }) => {
                    let r = e();
                    if (![null, void 0].includes(t.coordinates?.pos))
                        return (
                            r.insertContentAt(
                                { from: t.coordinates.pos, to: t.coordinates.pos },
                                { type: this.name, attrs: t },
                            ),
                            r.setTextSelection(t.coordinates.pos)
                        );
                    let { selection: i } = n,
                        { $from: o, $to: s } = i,
                        l = o.blockRange(s);
                    return l
                        ? (s.parentOffset === 0
                              ? r.insertContentAt(Math.max(s.pos - 1, 0), { type: this.name, attrs: t })
                              : r.insertContentAt({ from: l.start, to: l.end }, { type: this.name, attrs: t }),
                          r.setTextSelection(l.end))
                        : (s.parentOffset === 0
                              ? r
                                    .insertContentAt(Math.max(s.pos - 1, 0), { type: 'paragraph' })
                                    .insertContentAt({ from: o.pos, to: s.pos }, { type: this.name, attrs: t })
                              : r
                                    .setNode({ type: 'paragraph' })
                                    .insertContentAt({ from: o.pos, to: s.pos }, { type: this.name, attrs: t }),
                          r.setTextSelection(s.pos + 1));
                },
            updateBlock:
                (t) =>
                ({ chain: e, state: n }) => {
                    let { selection: r } = n,
                        { $from: i, $to: o } = r,
                        s = i.blockRange(o),
                        l = e();
                    return s
                        ? (l.insertContentAt({ from: s.start, to: s.end }, { type: this.name, attrs: t }),
                          l.focus(s.end + 1))
                        : (l.insertContentAt({ from: i.pos, to: i.pos + 1 }, { type: this.name, attrs: t }), !1);
                },
            removeBlock:
                () =>
                ({ commands: t }) =>
                    t.deleteSelection(),
        };
    },
});
function nF(t) {
    var e;
    let { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: o, $position: s } = t,
        l = UE(n),
        u = new RegExp(`\\s${l}$`),
        d = o ? '^' : '',
        f = r ? new RegExp(`${d}${l}.*?(?=\\s${l}|$)`, 'gm') : new RegExp(`${d}(?:^)?${l}[^\\s${l}]*`, 'gm'),
        h = ((e = s.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && s.nodeBefore.text;
    if (!h) return null;
    let m = s.pos - h.length,
        b = Array.from(h.matchAll(f)).pop();
    if (!b || b.input === void 0 || b.index === void 0) return null;
    let y = b.input.slice(Math.max(0, b.index - 1), b.index),
        v = new RegExp(`^[${i?.join('')}\0]?$`).test(y);
    if (i !== null && !v) return null;
    let x = m + b.index,
        T = x + b[0].length;
    return (
        r && u.test(h.slice(T - 1, T + 1)) && ((b[0] += ' '), (T += 1)),
        x < s.pos && T >= s.pos ? { range: { from: x, to: T }, query: b[0].slice(n.length), text: b[0] } : null
    );
}
var rF = new ze('suggestion');
function Nx({
    pluginKey: t = rF,
    editor: e,
    char: n = '@',
    allowSpaces: r = !1,
    allowedPrefixes: i = [' '],
    startOfLine: o = !1,
    decorationTag: s = 'span',
    decorationClass: l = 'suggestion',
    command: u = () => null,
    items: d = () => [],
    render: f = () => ({}),
    allow: h = () => !0,
    findSuggestionMatch: m = nF,
}) {
    let b,
        y = f?.(),
        v = new Oe({
            key: t,
            view() {
                return {
                    update: async (x, T) => {
                        var D, I, S, z, N, q, ne;
                        let $ = (D = this.key) === null || D === void 0 ? void 0 : D.getState(T),
                            oe = (I = this.key) === null || I === void 0 ? void 0 : I.getState(x.state),
                            me = $.active && oe.active && $.range.from !== oe.range.from,
                            Te = !$.active && oe.active,
                            ge = $.active && !oe.active,
                            Me = !Te && !ge && $.query !== oe.query,
                            Ee = Te || me,
                            P = Me && !me,
                            O = ge || me;
                        if (!Ee && !P && !O) return;
                        let R = O && !Ee ? $ : oe,
                            V = x.dom.querySelector(`[data-decoration-id="${R.decorationId}"]`);
                        (b = {
                            editor: e,
                            range: R.range,
                            query: R.query,
                            text: R.text,
                            items: [],
                            command: (Q) => u({ editor: e, range: R.range, props: Q }),
                            decorationNode: V,
                            clientRect: V
                                ? () => {
                                      var Q;
                                      let { decorationId: he } =
                                              (Q = this.key) === null || Q === void 0 ? void 0 : Q.getState(e.state),
                                          xe = x.dom.querySelector(`[data-decoration-id="${he}"]`);
                                      return xe?.getBoundingClientRect() || null;
                                  }
                                : null,
                        }),
                            Ee && ((S = y?.onBeforeStart) === null || S === void 0 || S.call(y, b)),
                            P && ((z = y?.onBeforeUpdate) === null || z === void 0 || z.call(y, b)),
                            (P || Ee) && (b.items = await d({ editor: e, query: R.query })),
                            O && ((N = y?.onExit) === null || N === void 0 || N.call(y, b)),
                            P && ((q = y?.onUpdate) === null || q === void 0 || q.call(y, b)),
                            Ee && ((ne = y?.onStart) === null || ne === void 0 || ne.call(y, b));
                    },
                    destroy: () => {
                        var x;
                        b && ((x = y?.onExit) === null || x === void 0 || x.call(y, b));
                    },
                };
            },
            state: {
                init() {
                    return { active: !1, range: { from: 0, to: 0 }, query: null, text: null, composing: !1 };
                },
                apply(x, T, D, I) {
                    let { isEditable: S } = e,
                        { composing: z } = e.view,
                        { selection: N } = x,
                        { empty: q, from: ne } = N,
                        $ = { ...T };
                    if ((($.composing = z), S && (q || e.view.composing))) {
                        (ne < T.range.from || ne > T.range.to) && !z && !T.composing && ($.active = !1);
                        let oe = m({ char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: o, $position: N.$from }),
                            me = `id_${Math.floor(Math.random() * 4294967295)}`;
                        oe && h({ editor: e, state: I, range: oe.range })
                            ? (($.active = !0),
                              ($.decorationId = T.decorationId ? T.decorationId : me),
                              ($.range = oe.range),
                              ($.query = oe.query),
                              ($.text = oe.text))
                            : ($.active = !1);
                    } else $.active = !1;
                    return (
                        $.active ||
                            (($.decorationId = null),
                            ($.range = { from: 0, to: 0 }),
                            ($.query = null),
                            ($.text = null)),
                        $
                    );
                },
            },
            props: {
                handleKeyDown(x, T) {
                    var D;
                    let { active: I, range: S } = v.getState(x.state);
                    return (
                        (I &&
                            ((D = y?.onKeyDown) === null || D === void 0
                                ? void 0
                                : D.call(y, { view: x, event: T, range: S }))) ||
                        !1
                    );
                },
                decorations(x) {
                    let { active: T, range: D, decorationId: I } = v.getState(x);
                    return T
                        ? lt.create(x.doc, [
                              Mt.inline(D.from, D.to, { nodeName: s, class: l, 'data-decoration-id': I }),
                          ])
                        : null;
                },
            },
        });
    return v;
}
var iF = new ze('mergeTag'),
    dm = ae.create({
        name: 'mergeTag',
        group: 'inline',
        inline: !0,
        selectable: !1,
        atom: !0,
        addAttributes() {
            return {
                id: {
                    default: null,
                    parseHTML: (t) => t.getAttribute('data-id'),
                    renderHTML: (t) => (t.id ? { 'data-id': t.id } : {}),
                },
            };
        },
        parseHTML() {
            return [{ tag: `span[data-type='${this.name}']` }];
        },
        renderHTML({ node: t, HTMLAttributes: e }) {
            return ['span', Z({ 'data-type': this.name }, e), `{{ ${t.attrs.id} }}`];
        },
        renderText({ node: t }) {
            return `{{ ${t.attrs.id} }}`;
        },
        addKeyboardShortcuts() {
            return {
                Backspace: () =>
                    this.editor.commands.command(({ tr: t, state: e }) => {
                        let n = !1,
                            { selection: r } = e,
                            { empty: i, anchor: o } = r;
                        return i
                            ? (e.doc.nodesBetween(o - 1, o, (s, l) => {
                                  if (s.type.name === this.name)
                                      return (n = !0), t.insertText('{{', l, l + s.nodeSize), !1;
                              }),
                              n)
                            : !1;
                    }),
            };
        },
        addCommands() {
            return {
                insertMergeTag:
                    (t) =>
                    ({ chain: e, state: n }) => {
                        let r = e();
                        if (![null, void 0].includes(t.coordinates?.pos))
                            return (
                                r.insertContentAt({ from: t.coordinates.pos, to: t.coordinates.pos }, [
                                    { type: this.name, attrs: { id: t.tag } },
                                    { type: 'text', text: ' ' },
                                ]),
                                r
                            );
                    },
            };
        },
        addProseMirrorPlugins() {
            return [
                Nx({
                    editor: this.editor,
                    char: '{{',
                    items: ({ query: t }) =>
                        this.options.mergeTags.filter((e) => e.toLowerCase().startsWith(t.toLowerCase())).slice(0, 5),
                    pluginKey: iF,
                    command: ({ editor: t, range: e, props: n }) => {
                        t.view.state.selection.$to.nodeAfter?.text?.startsWith(' ') && (e.to += 1),
                            t
                                .chain()
                                .focus()
                                .insertContentAt(e, [
                                    { type: this.name, attrs: n },
                                    { type: 'text', text: ' ' },
                                ])
                                .run(),
                            window.getSelection()?.collapseToEnd();
                    },
                    allow: ({ state: t, range: e }) => {
                        let n = t.doc.resolve(e.from),
                            r = t.schema.nodes[this.name];
                        return !!n.parent.type.contentMatch.matchType(r);
                    },
                    render: () => {
                        let t, e;
                        return {
                            onStart: (n) => {
                                if (!n.clientRect) return;
                                let r = `
                                <div
                                    x-data="{

                                        items: ['${n.items.join("', '")}'],

                                        selectedIndex: 0,

                                        init: function () {
                                            this.$el.parentElement.addEventListener(
                                                'merge-tags-key-down',
                                                (event) => this.onKeyDown(event.detail),
                                            );

                                            this.$el.parentElement.addEventListener(
                                                'merge-tags-update-items',
                                                (event) => (items = event.detail),
                                            );
                                        },

                                        onKeyDown: function (event) {
                                            if (event.key === 'ArrowUp') {
                                                event.preventDefault();
                                                this.selectedIndex = ((this.selectedIndex + this.items.length) - 1) % this.items.length;

                                                return true;
                                            };

                                            if (event.key === 'ArrowDown') {
                                                event.preventDefault();
                                                this.selectedIndex = (this.selectedIndex + 1) % this.items.length;

                                                return true;
                                            };

                                            if (event.key === 'Enter') {
                                                event.preventDefault();
                                                this.selectItem(this.selectedIndex);

                                                return true;
                                            };

                                            return false;
                                        },

                                        selectItem: function (index) {
                                            const item = this.items[index];

                                            if (! item) {
                                                return;
                                            };

                                            $el.parentElement.dispatchEvent(new CustomEvent('merge-tags-select', { detail: { item } }));
                                        },

                                    }"
                                    class="tippy-content-p-0"
                                >
                                    <template x-for="(item, index) in items" :key="index">
                                        <button
                                            x-text="item"
                                            x-on:click="selectItem(index)"
                                            :class="{ 'bg-primary-500': index === selectedIndex }"
                                            class="block w-full text-left rounded px-2 py-1"
                                        ></button>
                                    </template>
                                </div>
                            `;
                                (t = document.createElement('div')),
                                    (t.innerHTML = r),
                                    t.addEventListener('merge-tags-select', (i) => {
                                        n.command({ id: i.detail.item });
                                    }),
                                    (e = ts('body', {
                                        getReferenceClientRect: n.clientRect,
                                        appendTo: () => document.body,
                                        content: t,
                                        allowHTML: !0,
                                        showOnCreate: !0,
                                        interactive: !0,
                                        trigger: 'manual',
                                        placement: 'bottom-start',
                                    }));
                            },
                            onUpdate(n) {
                                if (!n.items.length) {
                                    e[0].hide();
                                    return;
                                }
                                e[0].show(),
                                    t.dispatchEvent(new CustomEvent('merge-tags-update-items', { detail: n.items }));
                            },
                            onKeyDown(n) {
                                t.dispatchEvent(new CustomEvent('merge-tags-key-down', { detail: n.event }));
                            },
                            onExit() {
                                e[0].destroy();
                            },
                        };
                    },
                }),
            ];
        },
    });
var fm = Ge.create({
    name: 'classExtension',
    addGlobalAttributes() {
        return [
            {
                types: [
                    'heading',
                    'paragraph',
                    'link',
                    'image',
                    'listItem',
                    'bulletList',
                    'orderedList',
                    'table',
                    'tableHeader',
                    'tableRow',
                    'tableCell',
                    'textStyle',
                ],
                attributes: {
                    class: {
                        default: null,
                        parseHTML: (t) => t.getAttribute('class') ?? null,
                        renderHTML: (t) => (t.class ? { class: t.class } : null),
                    },
                },
            },
        ];
    },
});
var pm = Ge.create({
    name: 'idExtension',
    addGlobalAttributes() {
        return [
            {
                types: ['heading', 'link'],
                attributes: {
                    id: {
                        default: null,
                        parseHTML: (t) => t.getAttribute('id') ?? null,
                        renderHTML: (t) => (t.id ? { id: t.id } : null),
                    },
                },
            },
        ];
    },
});
var Ox = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'],
    fu = (t, e, n = {}) => {
        t.dom.closest('form')?.dispatchEvent(new CustomEvent(e, { composed: !0, cancelable: !0, detail: n }));
    },
    oF = ({ key: t, editor: e, getFileAttachmentUrl: n, statePath: r, upload: i, uploadingMessage: o }) =>
        new Oe({
            key: t || new ze('localFiles'),
            props: {
                handleDrop(s, l) {
                    if (!l.dataTransfer?.files.length) return !1;
                    let u = Array.from(l.dataTransfer.files).filter((f) => Ox.includes(f.type));
                    if (!u.length) return !1;
                    fu(s, 'form-processing-started', { message: o }), l.preventDefault(), l.stopPropagation();
                    let d = s.posAtCoords({ left: l.clientX, top: l.clientY });
                    return (
                        u.forEach((f, h) => {
                            e.setEditable(!1);
                            let m = new FileReader();
                            m.readAsDataURL(f),
                                (m.onload = () => {
                                    e.chain()
                                        .insertContentAt(d?.pos ?? 0, {
                                            type: 'image',
                                            attrs: { class: 'filament-tiptap-loading-image', src: m.result },
                                        })
                                        .run();
                                });
                            let b = ('10000000-1000-4000-8000' + -1e11).replace(/[018]/g, (y) =>
                                (y ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (y / 4)))).toString(16),
                            );
                            i(`componentFileAttachments.${r}.${b}`, f, () => {
                                n(b).then((y) => {
                                    y &&
                                        (e
                                            .chain()
                                            .insertContentAt(
                                                { from: d?.pos ?? 0, to: (d?.pos ?? 0) + 1 },
                                                { type: 'image', attrs: { id: b, src: y } },
                                            )
                                            .run(),
                                        e.setEditable(!0),
                                        h === u.length - 1 && fu(s, 'form-processing-finished'));
                                });
                            });
                        }),
                        !0
                    );
                },
                handlePaste(s, l) {
                    if (!l.clipboardData?.files.length) return !1;
                    let u = Array.from(l.clipboardData.files).filter((d) => Ox.includes(d.type));
                    return u.length
                        ? (l.preventDefault(),
                          l.stopPropagation(),
                          fu(s, 'form-processing-started', { message: o }),
                          u.forEach((d, f) => {
                              e.setEditable(!1);
                              let h = new FileReader();
                              h.readAsDataURL(d),
                                  (h.onload = () => {
                                      e.chain()
                                          .insertContentAt(e.state.selection.anchor, {
                                              type: 'image',
                                              attrs: { class: 'filament-tiptap-loading-image', src: h.result },
                                          })
                                          .run();
                                  });
                              let m = ('10000000-1000-4000-8000' + -1e11).replace(/[018]/g, (b) =>
                                  (b ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (b / 4)))).toString(16),
                              );
                              i(`componentFileAttachments.${r}.${m}`, d, () => {
                                  n(m).then((b) => {
                                      b &&
                                          (e
                                              .chain()
                                              .insertContentAt(
                                                  { from: e.state.selection.anchor - 1, to: e.state.selection.anchor },
                                                  { type: 'image', attrs: { id: m, src: b } },
                                              )
                                              .run(),
                                          e.setEditable(!0),
                                          f === u.length - 1 && fu(s, 'form-processing-finished'));
                                  });
                              });
                          }),
                          !0)
                        : !1;
                },
            },
        }),
    hm = Ge.create({
        name: 'localFiles',
        addOptions() {
            return { getFileAttachmentUrl: null, statePath: null, upload: null, uploadingMessage: null };
        },
        addProseMirrorPlugins() {
            return [
                oF({
                    key: new ze(this.name),
                    editor: this.editor,
                    getFileAttachmentUrl: this.options.getFileAttachmentUrl,
                    statePath: this.options.statePath,
                    upload: this.options.upload,
                    uploadingMessage: this.options.uploadingMessage,
                }),
            ];
        },
    });
var mm = Ge.create({
    name: 'styleExtension',
    addGlobalAttributes() {
        return [
            {
                types: [
                    'heading',
                    'paragraph',
                    'link',
                    'image',
                    'listItem',
                    'bulletList',
                    'orderedList',
                    'table',
                    'tableHeader',
                    'tableRow',
                    'tableCell',
                    'textStyle',
                ],
                attributes: {
                    style: {
                        default: null,
                        parseHTML: (t) => t.getAttribute('style') ?? null,
                        renderHTML: (t) => (t.style ? { style: t.style } : null),
                    },
                },
            },
        ];
    },
});
var gm = Ge.create({
    name: 'statePath',
    addOptions() {
        return { statePath: null };
    },
    addStorage() {
        return { statePath: null };
    },
    onCreate() {
        this.storage.statePath = this.options.statePath;
    },
    addCommands() {
        return { getStatePath: () => () => this.storage.statePath };
    },
});
function sF(t) {
    let e = t.regex,
        n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
        r = 'decltype\\(auto\\)',
        i = '[a-zA-Z_]\\w*::',
        s = '(?!struct)(' + r + '|' + e.optional(i) + '[a-zA-Z_]\\w*' + e.optional('<[^<>]+>') + ')',
        l = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' },
        d = {
            className: 'string',
            variants: [
                { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [t.BACKSLASH_ESCAPE] },
                {
                    begin: "(u8?|U|L)?'(" + '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' + '|.)',
                    end: "'",
                    illegal: '.',
                },
                t.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ }),
            ],
        },
        f = {
            className: 'number',
            variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
            ],
            relevance: 0,
        },
        h = {
            className: 'meta',
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
                keyword: 'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
            },
            contains: [
                { begin: /\\\n/, relevance: 0 },
                t.inherit(d, { className: 'string' }),
                { className: 'string', begin: /<.*?>/ },
                n,
                t.C_BLOCK_COMMENT_MODE,
            ],
        },
        m = { className: 'title', begin: e.optional(i) + t.IDENT_RE, relevance: 0 },
        b = e.optional(i) + t.IDENT_RE + '\\s*\\(',
        y = [
            'alignas',
            'alignof',
            'and',
            'and_eq',
            'asm',
            'atomic_cancel',
            'atomic_commit',
            'atomic_noexcept',
            'auto',
            'bitand',
            'bitor',
            'break',
            'case',
            'catch',
            'class',
            'co_await',
            'co_return',
            'co_yield',
            'compl',
            'concept',
            'const_cast|10',
            'consteval',
            'constexpr',
            'constinit',
            'continue',
            'decltype',
            'default',
            'delete',
            'do',
            'dynamic_cast|10',
            'else',
            'enum',
            'explicit',
            'export',
            'extern',
            'false',
            'final',
            'for',
            'friend',
            'goto',
            'if',
            'import',
            'inline',
            'module',
            'mutable',
            'namespace',
            'new',
            'noexcept',
            'not',
            'not_eq',
            'nullptr',
            'operator',
            'or',
            'or_eq',
            'override',
            'private',
            'protected',
            'public',
            'reflexpr',
            'register',
            'reinterpret_cast|10',
            'requires',
            'return',
            'sizeof',
            'static_assert',
            'static_cast|10',
            'struct',
            'switch',
            'synchronized',
            'template',
            'this',
            'thread_local',
            'throw',
            'transaction_safe',
            'transaction_safe_dynamic',
            'true',
            'try',
            'typedef',
            'typeid',
            'typename',
            'union',
            'using',
            'virtual',
            'volatile',
            'while',
            'xor',
            'xor_eq',
        ],
        v = [
            'bool',
            'char',
            'char16_t',
            'char32_t',
            'char8_t',
            'double',
            'float',
            'int',
            'long',
            'short',
            'void',
            'wchar_t',
            'unsigned',
            'signed',
            'const',
            'static',
        ],
        x = [
            'any',
            'auto_ptr',
            'barrier',
            'binary_semaphore',
            'bitset',
            'complex',
            'condition_variable',
            'condition_variable_any',
            'counting_semaphore',
            'deque',
            'false_type',
            'future',
            'imaginary',
            'initializer_list',
            'istringstream',
            'jthread',
            'latch',
            'lock_guard',
            'multimap',
            'multiset',
            'mutex',
            'optional',
            'ostringstream',
            'packaged_task',
            'pair',
            'promise',
            'priority_queue',
            'queue',
            'recursive_mutex',
            'recursive_timed_mutex',
            'scoped_lock',
            'set',
            'shared_future',
            'shared_lock',
            'shared_mutex',
            'shared_timed_mutex',
            'shared_ptr',
            'stack',
            'string_view',
            'stringstream',
            'timed_mutex',
            'thread',
            'true_type',
            'tuple',
            'unique_lock',
            'unique_ptr',
            'unordered_map',
            'unordered_multimap',
            'unordered_multiset',
            'unordered_set',
            'variant',
            'vector',
            'weak_ptr',
            'wstring',
            'wstring_view',
        ],
        T = [
            'abort',
            'abs',
            'acos',
            'apply',
            'as_const',
            'asin',
            'atan',
            'atan2',
            'calloc',
            'ceil',
            'cerr',
            'cin',
            'clog',
            'cos',
            'cosh',
            'cout',
            'declval',
            'endl',
            'exchange',
            'exit',
            'exp',
            'fabs',
            'floor',
            'fmod',
            'forward',
            'fprintf',
            'fputs',
            'free',
            'frexp',
            'fscanf',
            'future',
            'invoke',
            'isalnum',
            'isalpha',
            'iscntrl',
            'isdigit',
            'isgraph',
            'islower',
            'isprint',
            'ispunct',
            'isspace',
            'isupper',
            'isxdigit',
            'labs',
            'launder',
            'ldexp',
            'log',
            'log10',
            'make_pair',
            'make_shared',
            'make_shared_for_overwrite',
            'make_tuple',
            'make_unique',
            'malloc',
            'memchr',
            'memcmp',
            'memcpy',
            'memset',
            'modf',
            'move',
            'pow',
            'printf',
            'putchar',
            'puts',
            'realloc',
            'scanf',
            'sin',
            'sinh',
            'snprintf',
            'sprintf',
            'sqrt',
            'sscanf',
            'std',
            'stderr',
            'stdin',
            'stdout',
            'strcat',
            'strchr',
            'strcmp',
            'strcpy',
            'strcspn',
            'strlen',
            'strncat',
            'strncmp',
            'strncpy',
            'strpbrk',
            'strrchr',
            'strspn',
            'strstr',
            'swap',
            'tan',
            'tanh',
            'terminate',
            'to_underlying',
            'tolower',
            'toupper',
            'vfprintf',
            'visit',
            'vprintf',
            'vsprintf',
        ],
        S = {
            type: v,
            keyword: y,
            literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
            built_in: ['_Pragma'],
            _type_hints: x,
        },
        z = {
            className: 'function.dispatch',
            relevance: 0,
            keywords: { _hint: T },
            begin: e.concat(
                /\b/,
                /(?!decltype)/,
                /(?!if)/,
                /(?!for)/,
                /(?!switch)/,
                /(?!while)/,
                t.IDENT_RE,
                e.lookahead(/(<[^<>]+>|)\s*\(/),
            ),
        },
        N = [z, h, l, n, t.C_BLOCK_COMMENT_MODE, f, d],
        q = {
            variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: 'new throw return else', end: /;/ },
            ],
            keywords: S,
            contains: N.concat([{ begin: /\(/, end: /\)/, keywords: S, contains: N.concat(['self']), relevance: 0 }]),
            relevance: 0,
        },
        ne = {
            className: 'function',
            begin: '(' + s + '[\\*&\\s]+)+' + b,
            returnBegin: !0,
            end: /[{;=]/,
            excludeEnd: !0,
            keywords: S,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [
                { begin: r, keywords: S, relevance: 0 },
                { begin: b, returnBegin: !0, contains: [m], relevance: 0 },
                { begin: /::/, relevance: 0 },
                { begin: /:/, endsWithParent: !0, contains: [d, f] },
                { relevance: 0, match: /,/ },
                {
                    className: 'params',
                    begin: /\(/,
                    end: /\)/,
                    keywords: S,
                    relevance: 0,
                    contains: [
                        n,
                        t.C_BLOCK_COMMENT_MODE,
                        d,
                        f,
                        l,
                        {
                            begin: /\(/,
                            end: /\)/,
                            keywords: S,
                            relevance: 0,
                            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l],
                        },
                    ],
                },
                l,
                n,
                t.C_BLOCK_COMMENT_MODE,
                h,
            ],
        };
    return {
        name: 'C++',
        aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
        keywords: S,
        illegal: '</',
        classNameAliases: { 'function.dispatch': 'built_in' },
        contains: [].concat(q, ne, z, N, [
            h,
            {
                begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)',
                end: '>',
                keywords: S,
                contains: ['self', l],
            },
            { begin: t.IDENT_RE + '::', keywords: S },
            {
                match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
                className: { 1: 'keyword', 3: 'title.class' },
            },
        ]),
    };
}
function Rx(t) {
    let e = {
            type: ['boolean', 'byte', 'word', 'String'],
            built_in: [
                'KeyboardController',
                'MouseController',
                'SoftwareSerial',
                'EthernetServer',
                'EthernetClient',
                'LiquidCrystal',
                'RobotControl',
                'GSMVoiceCall',
                'EthernetUDP',
                'EsploraTFT',
                'HttpClient',
                'RobotMotor',
                'WiFiClient',
                'GSMScanner',
                'FileSystem',
                'Scheduler',
                'GSMServer',
                'YunClient',
                'YunServer',
                'IPAddress',
                'GSMClient',
                'GSMModem',
                'Keyboard',
                'Ethernet',
                'Console',
                'GSMBand',
                'Esplora',
                'Stepper',
                'Process',
                'WiFiUDP',
                'GSM_SMS',
                'Mailbox',
                'USBHost',
                'Firmata',
                'PImage',
                'Client',
                'Server',
                'GSMPIN',
                'FileIO',
                'Bridge',
                'Serial',
                'EEPROM',
                'Stream',
                'Mouse',
                'Audio',
                'Servo',
                'File',
                'Task',
                'GPRS',
                'WiFi',
                'Wire',
                'TFT',
                'GSM',
                'SPI',
                'SD',
            ],
            _hints: [
                'setup',
                'loop',
                'runShellCommandAsynchronously',
                'analogWriteResolution',
                'retrieveCallingNumber',
                'printFirmwareVersion',
                'analogReadResolution',
                'sendDigitalPortPair',
                'noListenOnLocalhost',
                'readJoystickButton',
                'setFirmwareVersion',
                'readJoystickSwitch',
                'scrollDisplayRight',
                'getVoiceCallStatus',
                'scrollDisplayLeft',
                'writeMicroseconds',
                'delayMicroseconds',
                'beginTransmission',
                'getSignalStrength',
                'runAsynchronously',
                'getAsynchronously',
                'listenOnLocalhost',
                'getCurrentCarrier',
                'readAccelerometer',
                'messageAvailable',
                'sendDigitalPorts',
                'lineFollowConfig',
                'countryNameWrite',
                'runShellCommand',
                'readStringUntil',
                'rewindDirectory',
                'readTemperature',
                'setClockDivider',
                'readLightSensor',
                'endTransmission',
                'analogReference',
                'detachInterrupt',
                'countryNameRead',
                'attachInterrupt',
                'encryptionType',
                'readBytesUntil',
                'robotNameWrite',
                'readMicrophone',
                'robotNameRead',
                'cityNameWrite',
                'userNameWrite',
                'readJoystickY',
                'readJoystickX',
                'mouseReleased',
                'openNextFile',
                'scanNetworks',
                'noInterrupts',
                'digitalWrite',
                'beginSpeaker',
                'mousePressed',
                'isActionDone',
                'mouseDragged',
                'displayLogos',
                'noAutoscroll',
                'addParameter',
                'remoteNumber',
                'getModifiers',
                'keyboardRead',
                'userNameRead',
                'waitContinue',
                'processInput',
                'parseCommand',
                'printVersion',
                'readNetworks',
                'writeMessage',
                'blinkVersion',
                'cityNameRead',
                'readMessage',
                'setDataMode',
                'parsePacket',
                'isListening',
                'setBitOrder',
                'beginPacket',
                'isDirectory',
                'motorsWrite',
                'drawCompass',
                'digitalRead',
                'clearScreen',
                'serialEvent',
                'rightToLeft',
                'setTextSize',
                'leftToRight',
                'requestFrom',
                'keyReleased',
                'compassRead',
                'analogWrite',
                'interrupts',
                'WiFiServer',
                'disconnect',
                'playMelody',
                'parseFloat',
                'autoscroll',
                'getPINUsed',
                'setPINUsed',
                'setTimeout',
                'sendAnalog',
                'readSlider',
                'analogRead',
                'beginWrite',
                'createChar',
                'motorsStop',
                'keyPressed',
                'tempoWrite',
                'readButton',
                'subnetMask',
                'debugPrint',
                'macAddress',
                'writeGreen',
                'randomSeed',
                'attachGPRS',
                'readString',
                'sendString',
                'remotePort',
                'releaseAll',
                'mouseMoved',
                'background',
                'getXChange',
                'getYChange',
                'answerCall',
                'getResult',
                'voiceCall',
                'endPacket',
                'constrain',
                'getSocket',
                'writeJSON',
                'getButton',
                'available',
                'connected',
                'findUntil',
                'readBytes',
                'exitValue',
                'readGreen',
                'writeBlue',
                'startLoop',
                'IPAddress',
                'isPressed',
                'sendSysex',
                'pauseMode',
                'gatewayIP',
                'setCursor',
                'getOemKey',
                'tuneWrite',
                'noDisplay',
                'loadImage',
                'switchPIN',
                'onRequest',
                'onReceive',
                'changePIN',
                'playFile',
                'noBuffer',
                'parseInt',
                'overflow',
                'checkPIN',
                'knobRead',
                'beginTFT',
                'bitClear',
                'updateIR',
                'bitWrite',
                'position',
                'writeRGB',
                'highByte',
                'writeRed',
                'setSpeed',
                'readBlue',
                'noStroke',
                'remoteIP',
                'transfer',
                'shutdown',
                'hangCall',
                'beginSMS',
                'endWrite',
                'attached',
                'maintain',
                'noCursor',
                'checkReg',
                'checkPUK',
                'shiftOut',
                'isValid',
                'shiftIn',
                'pulseIn',
                'connect',
                'println',
                'localIP',
                'pinMode',
                'getIMEI',
                'display',
                'noBlink',
                'process',
                'getBand',
                'running',
                'beginSD',
                'drawBMP',
                'lowByte',
                'setBand',
                'release',
                'bitRead',
                'prepare',
                'pointTo',
                'readRed',
                'setMode',
                'noFill',
                'remove',
                'listen',
                'stroke',
                'detach',
                'attach',
                'noTone',
                'exists',
                'buffer',
                'height',
                'bitSet',
                'circle',
                'config',
                'cursor',
                'random',
                'IRread',
                'setDNS',
                'endSMS',
                'getKey',
                'micros',
                'millis',
                'begin',
                'print',
                'write',
                'ready',
                'flush',
                'width',
                'isPIN',
                'blink',
                'clear',
                'press',
                'mkdir',
                'rmdir',
                'close',
                'point',
                'yield',
                'image',
                'BSSID',
                'click',
                'delay',
                'read',
                'text',
                'move',
                'peek',
                'beep',
                'rect',
                'line',
                'open',
                'seek',
                'fill',
                'size',
                'turn',
                'stop',
                'home',
                'find',
                'step',
                'tone',
                'sqrt',
                'RSSI',
                'SSID',
                'end',
                'bit',
                'tan',
                'cos',
                'sin',
                'pow',
                'map',
                'abs',
                'max',
                'min',
                'get',
                'run',
                'put',
            ],
            literal: [
                'DIGITAL_MESSAGE',
                'FIRMATA_STRING',
                'ANALOG_MESSAGE',
                'REPORT_DIGITAL',
                'REPORT_ANALOG',
                'INPUT_PULLUP',
                'SET_PIN_MODE',
                'INTERNAL2V56',
                'SYSTEM_RESET',
                'LED_BUILTIN',
                'INTERNAL1V1',
                'SYSEX_START',
                'INTERNAL',
                'EXTERNAL',
                'DEFAULT',
                'OUTPUT',
                'INPUT',
                'HIGH',
                'LOW',
            ],
        },
        n = sF(t),
        r = n.keywords;
    return (
        (r.type = [...r.type, ...e.type]),
        (r.literal = [...r.literal, ...e.literal]),
        (r.built_in = [...r.built_in, ...e.built_in]),
        (r._hints = e._hints),
        (n.name = 'Arduino'),
        (n.aliases = ['ino']),
        (n.supersetOf = 'cpp'),
        n
    );
}
function Ix(t) {
    let e = t.regex,
        n = {},
        r = { begin: /\$\{/, end: /\}/, contains: ['self', { begin: /:-/, contains: [n] }] };
    Object.assign(n, {
        className: 'variable',
        variants: [{ begin: e.concat(/\$[\w\d#@][\w\d_]*/, '(?![\\w\\d])(?![$])') }, r],
    });
    let i = { className: 'subst', begin: /\$\(/, end: /\)/, contains: [t.BACKSLASH_ESCAPE] },
        o = {
            begin: /<<-?\s*(?=\w+)/,
            starts: { contains: [t.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: 'string' })] },
        },
        s = { className: 'string', begin: /"/, end: /"/, contains: [t.BACKSLASH_ESCAPE, n, i] };
    i.contains.push(s);
    let l = { className: '', begin: /\\"/ },
        u = { className: 'string', begin: /'/, end: /'/ },
        d = {
            begin: /\$?\(\(/,
            end: /\)\)/,
            contains: [{ begin: /\d+#[0-9a-f]+/, className: 'number' }, t.NUMBER_MODE, n],
        },
        f = ['fish', 'bash', 'zsh', 'sh', 'csh', 'ksh', 'tcsh', 'dash', 'scsh'],
        h = t.SHEBANG({ binary: `(${f.join('|')})`, relevance: 10 }),
        m = {
            className: 'function',
            begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
            returnBegin: !0,
            contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
            relevance: 0,
        },
        b = [
            'if',
            'then',
            'else',
            'elif',
            'fi',
            'for',
            'while',
            'until',
            'in',
            'do',
            'done',
            'case',
            'esac',
            'function',
            'select',
        ],
        y = ['true', 'false'],
        v = { match: /(\/[a-z._-]+)+/ },
        x = [
            'break',
            'cd',
            'continue',
            'eval',
            'exec',
            'exit',
            'export',
            'getopts',
            'hash',
            'pwd',
            'readonly',
            'return',
            'shift',
            'test',
            'times',
            'trap',
            'umask',
            'unset',
        ],
        T = [
            'alias',
            'bind',
            'builtin',
            'caller',
            'command',
            'declare',
            'echo',
            'enable',
            'help',
            'let',
            'local',
            'logout',
            'mapfile',
            'printf',
            'read',
            'readarray',
            'source',
            'type',
            'typeset',
            'ulimit',
            'unalias',
        ],
        D = [
            'autoload',
            'bg',
            'bindkey',
            'bye',
            'cap',
            'chdir',
            'clone',
            'comparguments',
            'compcall',
            'compctl',
            'compdescribe',
            'compfiles',
            'compgroups',
            'compquote',
            'comptags',
            'comptry',
            'compvalues',
            'dirs',
            'disable',
            'disown',
            'echotc',
            'echoti',
            'emulate',
            'fc',
            'fg',
            'float',
            'functions',
            'getcap',
            'getln',
            'history',
            'integer',
            'jobs',
            'kill',
            'limit',
            'log',
            'noglob',
            'popd',
            'print',
            'pushd',
            'pushln',
            'rehash',
            'sched',
            'setcap',
            'setopt',
            'stat',
            'suspend',
            'ttyctl',
            'unfunction',
            'unhash',
            'unlimit',
            'unsetopt',
            'vared',
            'wait',
            'whence',
            'where',
            'which',
            'zcompile',
            'zformat',
            'zftp',
            'zle',
            'zmodload',
            'zparseopts',
            'zprof',
            'zpty',
            'zregexparse',
            'zsocket',
            'zstyle',
            'ztcp',
        ],
        I = [
            'chcon',
            'chgrp',
            'chown',
            'chmod',
            'cp',
            'dd',
            'df',
            'dir',
            'dircolors',
            'ln',
            'ls',
            'mkdir',
            'mkfifo',
            'mknod',
            'mktemp',
            'mv',
            'realpath',
            'rm',
            'rmdir',
            'shred',
            'sync',
            'touch',
            'truncate',
            'vdir',
            'b2sum',
            'base32',
            'base64',
            'cat',
            'cksum',
            'comm',
            'csplit',
            'cut',
            'expand',
            'fmt',
            'fold',
            'head',
            'join',
            'md5sum',
            'nl',
            'numfmt',
            'od',
            'paste',
            'ptx',
            'pr',
            'sha1sum',
            'sha224sum',
            'sha256sum',
            'sha384sum',
            'sha512sum',
            'shuf',
            'sort',
            'split',
            'sum',
            'tac',
            'tail',
            'tr',
            'tsort',
            'unexpand',
            'uniq',
            'wc',
            'arch',
            'basename',
            'chroot',
            'date',
            'dirname',
            'du',
            'echo',
            'env',
            'expr',
            'factor',
            'groups',
            'hostid',
            'id',
            'link',
            'logname',
            'nice',
            'nohup',
            'nproc',
            'pathchk',
            'pinky',
            'printenv',
            'printf',
            'pwd',
            'readlink',
            'runcon',
            'seq',
            'sleep',
            'stat',
            'stdbuf',
            'stty',
            'tee',
            'test',
            'timeout',
            'tty',
            'uname',
            'unlink',
            'uptime',
            'users',
            'who',
            'whoami',
            'yes',
        ];
    return {
        name: 'Bash',
        aliases: ['sh'],
        keywords: {
            $pattern: /\b[a-z][a-z0-9._-]+\b/,
            keyword: b,
            literal: y,
            built_in: [...x, ...T, 'set', 'shopt', ...D, ...I],
        },
        contains: [h, t.SHEBANG(), m, d, t.HASH_COMMENT_MODE, o, v, s, l, u, n],
    };
}
function Lx(t) {
    let e = t.regex,
        n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
        r = 'decltype\\(auto\\)',
        i = '[a-zA-Z_]\\w*::',
        s = '(' + r + '|' + e.optional(i) + '[a-zA-Z_]\\w*' + e.optional('<[^<>]+>') + ')',
        l = { className: 'type', variants: [{ begin: '\\b[a-z\\d_]*_t\\b' }, { match: /\batomic_[a-z]{3,6}\b/ }] },
        d = {
            className: 'string',
            variants: [
                { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [t.BACKSLASH_ESCAPE] },
                {
                    begin: "(u8?|U|L)?'(" + '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' + '|.)',
                    end: "'",
                    illegal: '.',
                },
                t.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ }),
            ],
        },
        f = {
            className: 'number',
            variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
            ],
            relevance: 0,
        },
        h = {
            className: 'meta',
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
                keyword: 'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
            },
            contains: [
                { begin: /\\\n/, relevance: 0 },
                t.inherit(d, { className: 'string' }),
                { className: 'string', begin: /<.*?>/ },
                n,
                t.C_BLOCK_COMMENT_MODE,
            ],
        },
        m = { className: 'title', begin: e.optional(i) + t.IDENT_RE, relevance: 0 },
        b = e.optional(i) + t.IDENT_RE + '\\s*\\(',
        x = {
            keyword: [
                'asm',
                'auto',
                'break',
                'case',
                'continue',
                'default',
                'do',
                'else',
                'enum',
                'extern',
                'for',
                'fortran',
                'goto',
                'if',
                'inline',
                'register',
                'restrict',
                'return',
                'sizeof',
                'struct',
                'switch',
                'typedef',
                'union',
                'volatile',
                'while',
                '_Alignas',
                '_Alignof',
                '_Atomic',
                '_Generic',
                '_Noreturn',
                '_Static_assert',
                '_Thread_local',
                'alignas',
                'alignof',
                'noreturn',
                'static_assert',
                'thread_local',
                '_Pragma',
            ],
            type: [
                'float',
                'double',
                'signed',
                'unsigned',
                'int',
                'short',
                'long',
                'char',
                'void',
                '_Bool',
                '_Complex',
                '_Imaginary',
                '_Decimal32',
                '_Decimal64',
                '_Decimal128',
                'const',
                'static',
                'complex',
                'bool',
                'imaginary',
            ],
            literal: 'true false NULL',
            built_in:
                'std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr',
        },
        T = [h, l, n, t.C_BLOCK_COMMENT_MODE, f, d],
        D = {
            variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: 'new throw return else', end: /;/ },
            ],
            keywords: x,
            contains: T.concat([{ begin: /\(/, end: /\)/, keywords: x, contains: T.concat(['self']), relevance: 0 }]),
            relevance: 0,
        },
        I = {
            begin: '(' + s + '[\\*&\\s]+)+' + b,
            returnBegin: !0,
            end: /[{;=]/,
            excludeEnd: !0,
            keywords: x,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [
                { begin: r, keywords: x, relevance: 0 },
                { begin: b, returnBegin: !0, contains: [t.inherit(m, { className: 'title.function' })], relevance: 0 },
                { relevance: 0, match: /,/ },
                {
                    className: 'params',
                    begin: /\(/,
                    end: /\)/,
                    keywords: x,
                    relevance: 0,
                    contains: [
                        n,
                        t.C_BLOCK_COMMENT_MODE,
                        d,
                        f,
                        l,
                        {
                            begin: /\(/,
                            end: /\)/,
                            keywords: x,
                            relevance: 0,
                            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l],
                        },
                    ],
                },
                l,
                n,
                t.C_BLOCK_COMMENT_MODE,
                h,
            ],
        };
    return {
        name: 'C',
        aliases: ['h'],
        keywords: x,
        disableAutodetect: !0,
        illegal: '</',
        contains: [].concat(D, I, T, [
            h,
            { begin: t.IDENT_RE + '::', keywords: x },
            {
                className: 'class',
                beginKeywords: 'enum class struct union',
                end: /[{;:<>=]/,
                contains: [{ beginKeywords: 'final class struct' }, t.TITLE_MODE],
            },
        ]),
        exports: { preprocessor: h, strings: d, keywords: x },
    };
}
function Dx(t) {
    let e = t.regex,
        n = t.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
        r = 'decltype\\(auto\\)',
        i = '[a-zA-Z_]\\w*::',
        s = '(?!struct)(' + r + '|' + e.optional(i) + '[a-zA-Z_]\\w*' + e.optional('<[^<>]+>') + ')',
        l = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' },
        d = {
            className: 'string',
            variants: [
                { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [t.BACKSLASH_ESCAPE] },
                {
                    begin: "(u8?|U|L)?'(" + '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)' + '|.)',
                    end: "'",
                    illegal: '.',
                },
                t.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ }),
            ],
        },
        f = {
            className: 'number',
            variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
            ],
            relevance: 0,
        },
        h = {
            className: 'meta',
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
                keyword: 'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
            },
            contains: [
                { begin: /\\\n/, relevance: 0 },
                t.inherit(d, { className: 'string' }),
                { className: 'string', begin: /<.*?>/ },
                n,
                t.C_BLOCK_COMMENT_MODE,
            ],
        },
        m = { className: 'title', begin: e.optional(i) + t.IDENT_RE, relevance: 0 },
        b = e.optional(i) + t.IDENT_RE + '\\s*\\(',
        y = [
            'alignas',
            'alignof',
            'and',
            'and_eq',
            'asm',
            'atomic_cancel',
            'atomic_commit',
            'atomic_noexcept',
            'auto',
            'bitand',
            'bitor',
            'break',
            'case',
            'catch',
            'class',
            'co_await',
            'co_return',
            'co_yield',
            'compl',
            'concept',
            'const_cast|10',
            'consteval',
            'constexpr',
            'constinit',
            'continue',
            'decltype',
            'default',
            'delete',
            'do',
            'dynamic_cast|10',
            'else',
            'enum',
            'explicit',
            'export',
            'extern',
            'false',
            'final',
            'for',
            'friend',
            'goto',
            'if',
            'import',
            'inline',
            'module',
            'mutable',
            'namespace',
            'new',
            'noexcept',
            'not',
            'not_eq',
            'nullptr',
            'operator',
            'or',
            'or_eq',
            'override',
            'private',
            'protected',
            'public',
            'reflexpr',
            'register',
            'reinterpret_cast|10',
            'requires',
            'return',
            'sizeof',
            'static_assert',
            'static_cast|10',
            'struct',
            'switch',
            'synchronized',
            'template',
            'this',
            'thread_local',
            'throw',
            'transaction_safe',
            'transaction_safe_dynamic',
            'true',
            'try',
            'typedef',
            'typeid',
            'typename',
            'union',
            'using',
            'virtual',
            'volatile',
            'while',
            'xor',
            'xor_eq',
        ],
        v = [
            'bool',
            'char',
            'char16_t',
            'char32_t',
            'char8_t',
            'double',
            'float',
            'int',
            'long',
            'short',
            'void',
            'wchar_t',
            'unsigned',
            'signed',
            'const',
            'static',
        ],
        x = [
            'any',
            'auto_ptr',
            'barrier',
            'binary_semaphore',
            'bitset',
            'complex',
            'condition_variable',
            'condition_variable_any',
            'counting_semaphore',
            'deque',
            'false_type',
            'future',
            'imaginary',
            'initializer_list',
            'istringstream',
            'jthread',
            'latch',
            'lock_guard',
            'multimap',
            'multiset',
            'mutex',
            'optional',
            'ostringstream',
            'packaged_task',
            'pair',
            'promise',
            'priority_queue',
            'queue',
            'recursive_mutex',
            'recursive_timed_mutex',
            'scoped_lock',
            'set',
            'shared_future',
            'shared_lock',
            'shared_mutex',
            'shared_timed_mutex',
            'shared_ptr',
            'stack',
            'string_view',
            'stringstream',
            'timed_mutex',
            'thread',
            'true_type',
            'tuple',
            'unique_lock',
            'unique_ptr',
            'unordered_map',
            'unordered_multimap',
            'unordered_multiset',
            'unordered_set',
            'variant',
            'vector',
            'weak_ptr',
            'wstring',
            'wstring_view',
        ],
        T = [
            'abort',
            'abs',
            'acos',
            'apply',
            'as_const',
            'asin',
            'atan',
            'atan2',
            'calloc',
            'ceil',
            'cerr',
            'cin',
            'clog',
            'cos',
            'cosh',
            'cout',
            'declval',
            'endl',
            'exchange',
            'exit',
            'exp',
            'fabs',
            'floor',
            'fmod',
            'forward',
            'fprintf',
            'fputs',
            'free',
            'frexp',
            'fscanf',
            'future',
            'invoke',
            'isalnum',
            'isalpha',
            'iscntrl',
            'isdigit',
            'isgraph',
            'islower',
            'isprint',
            'ispunct',
            'isspace',
            'isupper',
            'isxdigit',
            'labs',
            'launder',
            'ldexp',
            'log',
            'log10',
            'make_pair',
            'make_shared',
            'make_shared_for_overwrite',
            'make_tuple',
            'make_unique',
            'malloc',
            'memchr',
            'memcmp',
            'memcpy',
            'memset',
            'modf',
            'move',
            'pow',
            'printf',
            'putchar',
            'puts',
            'realloc',
            'scanf',
            'sin',
            'sinh',
            'snprintf',
            'sprintf',
            'sqrt',
            'sscanf',
            'std',
            'stderr',
            'stdin',
            'stdout',
            'strcat',
            'strchr',
            'strcmp',
            'strcpy',
            'strcspn',
            'strlen',
            'strncat',
            'strncmp',
            'strncpy',
            'strpbrk',
            'strrchr',
            'strspn',
            'strstr',
            'swap',
            'tan',
            'tanh',
            'terminate',
            'to_underlying',
            'tolower',
            'toupper',
            'vfprintf',
            'visit',
            'vprintf',
            'vsprintf',
        ],
        S = {
            type: v,
            keyword: y,
            literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
            built_in: ['_Pragma'],
            _type_hints: x,
        },
        z = {
            className: 'function.dispatch',
            relevance: 0,
            keywords: { _hint: T },
            begin: e.concat(
                /\b/,
                /(?!decltype)/,
                /(?!if)/,
                /(?!for)/,
                /(?!switch)/,
                /(?!while)/,
                t.IDENT_RE,
                e.lookahead(/(<[^<>]+>|)\s*\(/),
            ),
        },
        N = [z, h, l, n, t.C_BLOCK_COMMENT_MODE, f, d],
        q = {
            variants: [
                { begin: /=/, end: /;/ },
                { begin: /\(/, end: /\)/ },
                { beginKeywords: 'new throw return else', end: /;/ },
            ],
            keywords: S,
            contains: N.concat([{ begin: /\(/, end: /\)/, keywords: S, contains: N.concat(['self']), relevance: 0 }]),
            relevance: 0,
        },
        ne = {
            className: 'function',
            begin: '(' + s + '[\\*&\\s]+)+' + b,
            returnBegin: !0,
            end: /[{;=]/,
            excludeEnd: !0,
            keywords: S,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [
                { begin: r, keywords: S, relevance: 0 },
                { begin: b, returnBegin: !0, contains: [m], relevance: 0 },
                { begin: /::/, relevance: 0 },
                { begin: /:/, endsWithParent: !0, contains: [d, f] },
                { relevance: 0, match: /,/ },
                {
                    className: 'params',
                    begin: /\(/,
                    end: /\)/,
                    keywords: S,
                    relevance: 0,
                    contains: [
                        n,
                        t.C_BLOCK_COMMENT_MODE,
                        d,
                        f,
                        l,
                        {
                            begin: /\(/,
                            end: /\)/,
                            keywords: S,
                            relevance: 0,
                            contains: ['self', n, t.C_BLOCK_COMMENT_MODE, d, f, l],
                        },
                    ],
                },
                l,
                n,
                t.C_BLOCK_COMMENT_MODE,
                h,
            ],
        };
    return {
        name: 'C++',
        aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
        keywords: S,
        illegal: '</',
        classNameAliases: { 'function.dispatch': 'built_in' },
        contains: [].concat(q, ne, z, N, [
            h,
            {
                begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)',
                end: '>',
                keywords: S,
                contains: ['self', l],
            },
            { begin: t.IDENT_RE + '::', keywords: S },
            {
                match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
                className: { 1: 'keyword', 3: 'title.class' },
            },
        ]),
    };
}
function Px(t) {
    let e = [
            'bool',
            'byte',
            'char',
            'decimal',
            'delegate',
            'double',
            'dynamic',
            'enum',
            'float',
            'int',
            'long',
            'nint',
            'nuint',
            'object',
            'sbyte',
            'short',
            'string',
            'ulong',
            'uint',
            'ushort',
        ],
        n = [
            'public',
            'private',
            'protected',
            'static',
            'internal',
            'protected',
            'abstract',
            'async',
            'extern',
            'override',
            'unsafe',
            'virtual',
            'new',
            'sealed',
            'partial',
        ],
        r = ['default', 'false', 'null', 'true'],
        i = [
            'abstract',
            'as',
            'base',
            'break',
            'case',
            'catch',
            'class',
            'const',
            'continue',
            'do',
            'else',
            'event',
            'explicit',
            'extern',
            'finally',
            'fixed',
            'for',
            'foreach',
            'goto',
            'if',
            'implicit',
            'in',
            'interface',
            'internal',
            'is',
            'lock',
            'namespace',
            'new',
            'operator',
            'out',
            'override',
            'params',
            'private',
            'protected',
            'public',
            'readonly',
            'record',
            'ref',
            'return',
            'scoped',
            'sealed',
            'sizeof',
            'stackalloc',
            'static',
            'struct',
            'switch',
            'this',
            'throw',
            'try',
            'typeof',
            'unchecked',
            'unsafe',
            'using',
            'virtual',
            'void',
            'volatile',
            'while',
        ],
        o = [
            'add',
            'alias',
            'and',
            'ascending',
            'async',
            'await',
            'by',
            'descending',
            'equals',
            'from',
            'get',
            'global',
            'group',
            'init',
            'into',
            'join',
            'let',
            'nameof',
            'not',
            'notnull',
            'on',
            'or',
            'orderby',
            'partial',
            'remove',
            'select',
            'set',
            'unmanaged',
            'value|0',
            'var',
            'when',
            'where',
            'with',
            'yield',
        ],
        s = { keyword: i.concat(o), built_in: e, literal: r },
        l = t.inherit(t.TITLE_MODE, { begin: '[a-zA-Z](\\.?\\w)*' }),
        u = {
            className: 'number',
            variants: [
                { begin: "\\b(0b[01']+)" },
                { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
                { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" },
            ],
            relevance: 0,
        },
        d = { className: 'string', begin: '@"', end: '"', contains: [{ begin: '""' }] },
        f = t.inherit(d, { illegal: /\n/ }),
        h = { className: 'subst', begin: /\{/, end: /\}/, keywords: s },
        m = t.inherit(h, { illegal: /\n/ }),
        b = {
            className: 'string',
            begin: /\$"/,
            end: '"',
            illegal: /\n/,
            contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, t.BACKSLASH_ESCAPE, m],
        },
        y = {
            className: 'string',
            begin: /\$@"/,
            end: '"',
            contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, h],
        },
        v = t.inherit(y, { illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, m] });
    (h.contains = [y, b, d, t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, u, t.C_BLOCK_COMMENT_MODE]),
        (m.contains = [
            v,
            b,
            f,
            t.APOS_STRING_MODE,
            t.QUOTE_STRING_MODE,
            u,
            t.inherit(t.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
        ]);
    let x = { variants: [y, b, d, t.APOS_STRING_MODE, t.QUOTE_STRING_MODE] },
        T = { begin: '<', end: '>', contains: [{ beginKeywords: 'in out' }, l] },
        D = t.IDENT_RE + '(<' + t.IDENT_RE + '(\\s*,\\s*' + t.IDENT_RE + ')*>)?(\\[\\])?',
        I = { begin: '@' + t.IDENT_RE, relevance: 0 };
    return {
        name: 'C#',
        aliases: ['cs', 'c#'],
        keywords: s,
        illegal: /::/,
        contains: [
            t.COMMENT('///', '$', {
                returnBegin: !0,
                contains: [
                    {
                        className: 'doctag',
                        variants: [{ begin: '///', relevance: 0 }, { begin: '<!--|-->' }, { begin: '</?', end: '>' }],
                    },
                ],
            }),
            t.C_LINE_COMMENT_MODE,
            t.C_BLOCK_COMMENT_MODE,
            {
                className: 'meta',
                begin: '#',
                end: '$',
                keywords: {
                    keyword: 'if else elif endif define undef warning error line region endregion pragma checksum',
                },
            },
            x,
            u,
            {
                beginKeywords: 'class interface',
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:,]/,
                contains: [{ beginKeywords: 'where class' }, l, T, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE],
            },
            {
                beginKeywords: 'namespace',
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [l, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE],
            },
            {
                beginKeywords: 'record',
                relevance: 0,
                end: /[{;=]/,
                illegal: /[^\s:]/,
                contains: [l, T, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE],
            },
            {
                className: 'meta',
                begin: '^\\s*\\[(?=[\\w])',
                excludeBegin: !0,
                end: '\\]',
                excludeEnd: !0,
                contains: [{ className: 'string', begin: /"/, end: /"/ }],
            },
            { beginKeywords: 'new return throw await else', relevance: 0 },
            {
                className: 'function',
                begin: '(' + D + '\\s+)+' + t.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
                returnBegin: !0,
                end: /\s*[{;=]/,
                excludeEnd: !0,
                keywords: s,
                contains: [
                    { beginKeywords: n.join(' '), relevance: 0 },
                    {
                        begin: t.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
                        returnBegin: !0,
                        contains: [t.TITLE_MODE, T],
                        relevance: 0,
                    },
                    { match: /\(\)/ },
                    {
                        className: 'params',
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: !0,
                        excludeEnd: !0,
                        keywords: s,
                        relevance: 0,
                        contains: [x, u, t.C_BLOCK_COMMENT_MODE],
                    },
                    t.C_LINE_COMMENT_MODE,
                    t.C_BLOCK_COMMENT_MODE,
                ],
            },
            I,
        ],
    };
}
var aF = (t) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
            scope: 'selector-attr',
            begin: /\[/,
            end: /\]/,
            illegal: '$',
            contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
            scope: 'number',
            begin:
                t.NUMBER_RE +
                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
            relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ },
    }),
    lF = [
        'a',
        'abbr',
        'address',
        'article',
        'aside',
        'audio',
        'b',
        'blockquote',
        'body',
        'button',
        'canvas',
        'caption',
        'cite',
        'code',
        'dd',
        'del',
        'details',
        'dfn',
        'div',
        'dl',
        'dt',
        'em',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'header',
        'hgroup',
        'html',
        'i',
        'iframe',
        'img',
        'input',
        'ins',
        'kbd',
        'label',
        'legend',
        'li',
        'main',
        'mark',
        'menu',
        'nav',
        'object',
        'ol',
        'p',
        'q',
        'quote',
        'samp',
        'section',
        'span',
        'strong',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'tr',
        'ul',
        'var',
        'video',
    ],
    cF = [
        'any-hover',
        'any-pointer',
        'aspect-ratio',
        'color',
        'color-gamut',
        'color-index',
        'device-aspect-ratio',
        'device-height',
        'device-width',
        'display-mode',
        'forced-colors',
        'grid',
        'height',
        'hover',
        'inverted-colors',
        'monochrome',
        'orientation',
        'overflow-block',
        'overflow-inline',
        'pointer',
        'prefers-color-scheme',
        'prefers-contrast',
        'prefers-reduced-motion',
        'prefers-reduced-transparency',
        'resolution',
        'scan',
        'scripting',
        'update',
        'width',
        'min-width',
        'max-width',
        'min-height',
        'max-height',
    ],
    uF = [
        'active',
        'any-link',
        'blank',
        'checked',
        'current',
        'default',
        'defined',
        'dir',
        'disabled',
        'drop',
        'empty',
        'enabled',
        'first',
        'first-child',
        'first-of-type',
        'fullscreen',
        'future',
        'focus',
        'focus-visible',
        'focus-within',
        'has',
        'host',
        'host-context',
        'hover',
        'indeterminate',
        'in-range',
        'invalid',
        'is',
        'lang',
        'last-child',
        'last-of-type',
        'left',
        'link',
        'local-link',
        'not',
        'nth-child',
        'nth-col',
        'nth-last-child',
        'nth-last-col',
        'nth-last-of-type',
        'nth-of-type',
        'only-child',
        'only-of-type',
        'optional',
        'out-of-range',
        'past',
        'placeholder-shown',
        'read-only',
        'read-write',
        'required',
        'right',
        'root',
        'scope',
        'target',
        'target-within',
        'user-invalid',
        'valid',
        'visited',
        'where',
    ],
    dF = [
        'after',
        'backdrop',
        'before',
        'cue',
        'cue-region',
        'first-letter',
        'first-line',
        'grammar-error',
        'marker',
        'part',
        'placeholder',
        'selection',
        'slotted',
        'spelling-error',
    ],
    fF = [
        'align-content',
        'align-items',
        'align-self',
        'all',
        'animation',
        'animation-delay',
        'animation-direction',
        'animation-duration',
        'animation-fill-mode',
        'animation-iteration-count',
        'animation-name',
        'animation-play-state',
        'animation-timing-function',
        'backface-visibility',
        'background',
        'background-attachment',
        'background-blend-mode',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'block-size',
        'border',
        'border-block',
        'border-block-color',
        'border-block-end',
        'border-block-end-color',
        'border-block-end-style',
        'border-block-end-width',
        'border-block-start',
        'border-block-start-color',
        'border-block-start-style',
        'border-block-start-width',
        'border-block-style',
        'border-block-width',
        'border-bottom',
        'border-bottom-color',
        'border-bottom-left-radius',
        'border-bottom-right-radius',
        'border-bottom-style',
        'border-bottom-width',
        'border-collapse',
        'border-color',
        'border-image',
        'border-image-outset',
        'border-image-repeat',
        'border-image-slice',
        'border-image-source',
        'border-image-width',
        'border-inline',
        'border-inline-color',
        'border-inline-end',
        'border-inline-end-color',
        'border-inline-end-style',
        'border-inline-end-width',
        'border-inline-start',
        'border-inline-start-color',
        'border-inline-start-style',
        'border-inline-start-width',
        'border-inline-style',
        'border-inline-width',
        'border-left',
        'border-left-color',
        'border-left-style',
        'border-left-width',
        'border-radius',
        'border-right',
        'border-right-color',
        'border-right-style',
        'border-right-width',
        'border-spacing',
        'border-style',
        'border-top',
        'border-top-color',
        'border-top-left-radius',
        'border-top-right-radius',
        'border-top-style',
        'border-top-width',
        'border-width',
        'bottom',
        'box-decoration-break',
        'box-shadow',
        'box-sizing',
        'break-after',
        'break-before',
        'break-inside',
        'caption-side',
        'caret-color',
        'clear',
        'clip',
        'clip-path',
        'clip-rule',
        'color',
        'column-count',
        'column-fill',
        'column-gap',
        'column-rule',
        'column-rule-color',
        'column-rule-style',
        'column-rule-width',
        'column-span',
        'column-width',
        'columns',
        'contain',
        'content',
        'content-visibility',
        'counter-increment',
        'counter-reset',
        'cue',
        'cue-after',
        'cue-before',
        'cursor',
        'direction',
        'display',
        'empty-cells',
        'filter',
        'flex',
        'flex-basis',
        'flex-direction',
        'flex-flow',
        'flex-grow',
        'flex-shrink',
        'flex-wrap',
        'float',
        'flow',
        'font',
        'font-display',
        'font-family',
        'font-feature-settings',
        'font-kerning',
        'font-language-override',
        'font-size',
        'font-size-adjust',
        'font-smoothing',
        'font-stretch',
        'font-style',
        'font-synthesis',
        'font-variant',
        'font-variant-caps',
        'font-variant-east-asian',
        'font-variant-ligatures',
        'font-variant-numeric',
        'font-variant-position',
        'font-variation-settings',
        'font-weight',
        'gap',
        'glyph-orientation-vertical',
        'grid',
        'grid-area',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-auto-rows',
        'grid-column',
        'grid-column-end',
        'grid-column-start',
        'grid-gap',
        'grid-row',
        'grid-row-end',
        'grid-row-start',
        'grid-template',
        'grid-template-areas',
        'grid-template-columns',
        'grid-template-rows',
        'hanging-punctuation',
        'height',
        'hyphens',
        'icon',
        'image-orientation',
        'image-rendering',
        'image-resolution',
        'ime-mode',
        'inline-size',
        'isolation',
        'justify-content',
        'left',
        'letter-spacing',
        'line-break',
        'line-height',
        'list-style',
        'list-style-image',
        'list-style-position',
        'list-style-type',
        'margin',
        'margin-block',
        'margin-block-end',
        'margin-block-start',
        'margin-bottom',
        'margin-inline',
        'margin-inline-end',
        'margin-inline-start',
        'margin-left',
        'margin-right',
        'margin-top',
        'marks',
        'mask',
        'mask-border',
        'mask-border-mode',
        'mask-border-outset',
        'mask-border-repeat',
        'mask-border-slice',
        'mask-border-source',
        'mask-border-width',
        'mask-clip',
        'mask-composite',
        'mask-image',
        'mask-mode',
        'mask-origin',
        'mask-position',
        'mask-repeat',
        'mask-size',
        'mask-type',
        'max-block-size',
        'max-height',
        'max-inline-size',
        'max-width',
        'min-block-size',
        'min-height',
        'min-inline-size',
        'min-width',
        'mix-blend-mode',
        'nav-down',
        'nav-index',
        'nav-left',
        'nav-right',
        'nav-up',
        'none',
        'normal',
        'object-fit',
        'object-position',
        'opacity',
        'order',
        'orphans',
        'outline',
        'outline-color',
        'outline-offset',
        'outline-style',
        'outline-width',
        'overflow',
        'overflow-wrap',
        'overflow-x',
        'overflow-y',
        'padding',
        'padding-block',
        'padding-block-end',
        'padding-block-start',
        'padding-bottom',
        'padding-inline',
        'padding-inline-end',
        'padding-inline-start',
        'padding-left',
        'padding-right',
        'padding-top',
        'page-break-after',
        'page-break-before',
        'page-break-inside',
        'pause',
        'pause-after',
        'pause-before',
        'perspective',
        'perspective-origin',
        'pointer-events',
        'position',
        'quotes',
        'resize',
        'rest',
        'rest-after',
        'rest-before',
        'right',
        'row-gap',
        'scroll-margin',
        'scroll-margin-block',
        'scroll-margin-block-end',
        'scroll-margin-block-start',
        'scroll-margin-bottom',
        'scroll-margin-inline',
        'scroll-margin-inline-end',
        'scroll-margin-inline-start',
        'scroll-margin-left',
        'scroll-margin-right',
        'scroll-margin-top',
        'scroll-padding',
        'scroll-padding-block',
        'scroll-padding-block-end',
        'scroll-padding-block-start',
        'scroll-padding-bottom',
        'scroll-padding-inline',
        'scroll-padding-inline-end',
        'scroll-padding-inline-start',
        'scroll-padding-left',
        'scroll-padding-right',
        'scroll-padding-top',
        'scroll-snap-align',
        'scroll-snap-stop',
        'scroll-snap-type',
        'scrollbar-color',
        'scrollbar-gutter',
        'scrollbar-width',
        'shape-image-threshold',
        'shape-margin',
        'shape-outside',
        'speak',
        'speak-as',
        'src',
        'tab-size',
        'table-layout',
        'text-align',
        'text-align-all',
        'text-align-last',
        'text-combine-upright',
        'text-decoration',
        'text-decoration-color',
        'text-decoration-line',
        'text-decoration-style',
        'text-emphasis',
        'text-emphasis-color',
        'text-emphasis-position',
        'text-emphasis-style',
        'text-indent',
        'text-justify',
        'text-orientation',
        'text-overflow',
        'text-rendering',
        'text-shadow',
        'text-transform',
        'text-underline-position',
        'top',
        'transform',
        'transform-box',
        'transform-origin',
        'transform-style',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function',
        'unicode-bidi',
        'vertical-align',
        'visibility',
        'voice-balance',
        'voice-duration',
        'voice-family',
        'voice-pitch',
        'voice-range',
        'voice-rate',
        'voice-stress',
        'voice-volume',
        'white-space',
        'widows',
        'width',
        'will-change',
        'word-break',
        'word-spacing',
        'word-wrap',
        'writing-mode',
        'z-index',
    ].reverse();
function Bx(t) {
    let e = t.regex,
        n = aF(t),
        r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
        i = 'and or not only',
        o = /@-?\w[\w]*(-\w+)*/,
        s = '[a-zA-Z-][a-zA-Z0-9_-]*',
        l = [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE];
    return {
        name: 'CSS',
        case_insensitive: !0,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: 'from to' },
        classNameAliases: { keyframePosition: 'selector-tag' },
        contains: [
            n.BLOCK_COMMENT,
            r,
            n.CSS_NUMBER_MODE,
            { className: 'selector-id', begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
            { className: 'selector-class', begin: '\\.' + s, relevance: 0 },
            n.ATTRIBUTE_SELECTOR_MODE,
            {
                className: 'selector-pseudo',
                variants: [{ begin: ':(' + uF.join('|') + ')' }, { begin: ':(:)?(' + dF.join('|') + ')' }],
            },
            n.CSS_VARIABLE,
            { className: 'attribute', begin: '\\b(' + fF.join('|') + ')\\b' },
            {
                begin: /:/,
                end: /[;}{]/,
                contains: [
                    n.BLOCK_COMMENT,
                    n.HEXCOLOR,
                    n.IMPORTANT,
                    n.CSS_NUMBER_MODE,
                    ...l,
                    {
                        begin: /(url|data-uri)\(/,
                        end: /\)/,
                        relevance: 0,
                        keywords: { built_in: 'url data-uri' },
                        contains: [...l, { className: 'string', begin: /[^)]/, endsWithParent: !0, excludeEnd: !0 }],
                    },
                    n.FUNCTION_DISPATCH,
                ],
            },
            {
                begin: e.lookahead(/@/),
                end: '[{;]',
                relevance: 0,
                illegal: /:/,
                contains: [
                    { className: 'keyword', begin: o },
                    {
                        begin: /\s/,
                        endsWithParent: !0,
                        excludeEnd: !0,
                        relevance: 0,
                        keywords: { $pattern: /[a-z-]+/, keyword: i, attribute: cF.join(' ') },
                        contains: [{ begin: /[a-z-]+(?=:)/, className: 'attribute' }, ...l, n.CSS_NUMBER_MODE],
                    },
                ],
            },
            { className: 'selector-tag', begin: '\\b(' + lF.join('|') + ')\\b' },
        ],
    };
}
function Fx(t) {
    let e = t.regex;
    return {
        name: 'Diff',
        aliases: ['patch'],
        contains: [
            {
                className: 'meta',
                relevance: 10,
                match: e.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/),
            },
            {
                className: 'comment',
                variants: [
                    {
                        begin: e.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
                        end: /$/,
                    },
                    { match: /^\*{15}$/ },
                ],
            },
            { className: 'addition', begin: /^\+/, end: /$/ },
            { className: 'deletion', begin: /^-/, end: /$/ },
            { className: 'addition', begin: /^!/, end: /$/ },
        ],
    };
}
function Hx(t) {
    let o = {
        keyword: [
            'break',
            'case',
            'chan',
            'const',
            'continue',
            'default',
            'defer',
            'else',
            'fallthrough',
            'for',
            'func',
            'go',
            'goto',
            'if',
            'import',
            'interface',
            'map',
            'package',
            'range',
            'return',
            'select',
            'struct',
            'switch',
            'type',
            'var',
        ],
        type: [
            'bool',
            'byte',
            'complex64',
            'complex128',
            'error',
            'float32',
            'float64',
            'int8',
            'int16',
            'int32',
            'int64',
            'string',
            'uint8',
            'uint16',
            'uint32',
            'uint64',
            'int',
            'uint',
            'uintptr',
            'rune',
        ],
        literal: ['true', 'false', 'iota', 'nil'],
        built_in: [
            'append',
            'cap',
            'close',
            'complex',
            'copy',
            'imag',
            'len',
            'make',
            'new',
            'panic',
            'print',
            'println',
            'real',
            'recover',
            'delete',
        ],
    };
    return {
        name: 'Go',
        aliases: ['golang'],
        keywords: o,
        illegal: '</',
        contains: [
            t.C_LINE_COMMENT_MODE,
            t.C_BLOCK_COMMENT_MODE,
            { className: 'string', variants: [t.QUOTE_STRING_MODE, t.APOS_STRING_MODE, { begin: '`', end: '`' }] },
            { className: 'number', variants: [{ begin: t.C_NUMBER_RE + '[i]', relevance: 1 }, t.C_NUMBER_MODE] },
            { begin: /:=/ },
            {
                className: 'function',
                beginKeywords: 'func',
                end: '\\s*(\\{|$)',
                excludeEnd: !0,
                contains: [
                    t.TITLE_MODE,
                    { className: 'params', begin: /\(/, end: /\)/, endsParent: !0, keywords: o, illegal: /["']/ },
                ],
            },
        ],
    };
}
function zx(t) {
    let e = t.regex,
        n = /[_A-Za-z][_0-9A-Za-z]*/;
    return {
        name: 'GraphQL',
        aliases: ['gql'],
        case_insensitive: !0,
        disableAutodetect: !1,
        keywords: {
            keyword: [
                'query',
                'mutation',
                'subscription',
                'type',
                'input',
                'schema',
                'directive',
                'interface',
                'union',
                'scalar',
                'fragment',
                'enum',
                'on',
            ],
            literal: ['true', 'false', 'null'],
        },
        contains: [
            t.HASH_COMMENT_MODE,
            t.QUOTE_STRING_MODE,
            t.NUMBER_MODE,
            { scope: 'punctuation', match: /[.]{3}/, relevance: 0 },
            { scope: 'punctuation', begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/, relevance: 0 },
            { scope: 'variable', begin: /\$/, end: /\W/, excludeEnd: !0, relevance: 0 },
            { scope: 'meta', match: /@\w+/, excludeEnd: !0 },
            { scope: 'symbol', begin: e.concat(n, e.lookahead(/\s*:/)), relevance: 0 },
        ],
        illegal: [/[;<']/, /BEGIN/],
    };
}
function $x(t) {
    let e = t.regex,
        n = {
            className: 'number',
            relevance: 0,
            variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: t.NUMBER_RE }],
        },
        r = t.COMMENT();
    r.variants = [
        { begin: /;/, end: /$/ },
        { begin: /#/, end: /$/ },
    ];
    let i = { className: 'variable', variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }] },
        o = { className: 'literal', begin: /\bon|off|true|false|yes|no\b/ },
        s = {
            className: 'string',
            contains: [t.BACKSLASH_ESCAPE],
            variants: [
                { begin: "'''", end: "'''", relevance: 10 },
                { begin: '"""', end: '"""', relevance: 10 },
                { begin: '"', end: '"' },
                { begin: "'", end: "'" },
            ],
        },
        l = { begin: /\[/, end: /\]/, contains: [r, o, i, s, n, 'self'], relevance: 0 },
        u = /[A-Za-z0-9_-]+/,
        d = /"(\\"|[^"])*"/,
        f = /'[^']*'/,
        h = e.either(u, d, f),
        m = e.concat(h, '(\\s*\\.\\s*', h, ')*', e.lookahead(/\s*=\s*[^#\s]/));
    return {
        name: 'TOML, also INI',
        aliases: ['toml'],
        case_insensitive: !0,
        illegal: /\S/,
        contains: [
            r,
            { className: 'section', begin: /\[+/, end: /\]+/ },
            { begin: m, className: 'attr', starts: { end: /$/, contains: [r, l, o, i, s, n] } },
        ],
    };
}
var as = '[0-9](_*[0-9])*',
    pu = `\\.(${as})`,
    hu = '[0-9a-fA-F](_*[0-9a-fA-F])*',
    Ux = {
        className: 'number',
        variants: [
            { begin: `(\\b(${as})((${pu})|\\.)?|(${pu}))[eE][+-]?(${as})[fFdD]?\\b` },
            { begin: `\\b(${as})((${pu})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
            { begin: `(${pu})[fFdD]?\\b` },
            { begin: `\\b(${as})[fFdD]\\b` },
            { begin: `\\b0[xX]((${hu})\\.?|(${hu})?\\.(${hu}))[pP][+-]?(${as})[fFdD]?\\b` },
            { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
            { begin: `\\b0[xX](${hu})[lL]?\\b` },
            { begin: '\\b0(_*[0-7])*[lL]?\\b' },
            { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
        ],
        relevance: 0,
    };
function Wx(t, e, n) {
    return n === -1 ? '' : t.replace(e, (r) => Wx(t, e, n - 1));
}
function Kx(t) {
    let e = t.regex,
        n = '[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*',
        r = n + Wx('(?:<' + n + '~~~(?:\\s*,\\s*' + n + '~~~)*>)?', /~~~/g, 2),
        u = {
            keyword: [
                'synchronized',
                'abstract',
                'private',
                'var',
                'static',
                'if',
                'const ',
                'for',
                'while',
                'strictfp',
                'finally',
                'protected',
                'import',
                'native',
                'final',
                'void',
                'enum',
                'else',
                'break',
                'transient',
                'catch',
                'instanceof',
                'volatile',
                'case',
                'assert',
                'package',
                'default',
                'public',
                'try',
                'switch',
                'continue',
                'throws',
                'protected',
                'public',
                'private',
                'module',
                'requires',
                'exports',
                'do',
                'sealed',
                'yield',
                'permits',
            ],
            literal: ['false', 'true', 'null'],
            type: ['char', 'boolean', 'long', 'float', 'int', 'byte', 'short', 'double'],
            built_in: ['super', 'this'],
        },
        d = { className: 'meta', begin: '@' + n, contains: [{ begin: /\(/, end: /\)/, contains: ['self'] }] },
        f = {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            keywords: u,
            relevance: 0,
            contains: [t.C_BLOCK_COMMENT_MODE],
            endsParent: !0,
        };
    return {
        name: 'Java',
        aliases: ['jsp'],
        keywords: u,
        illegal: /<\/|#/,
        contains: [
            t.COMMENT('/\\*\\*', '\\*/', {
                relevance: 0,
                contains: [
                    { begin: /\w+@/, relevance: 0 },
                    { className: 'doctag', begin: '@[A-Za-z]+' },
                ],
            }),
            { begin: /import java\.[a-z]+\./, keywords: 'import', relevance: 2 },
            t.C_LINE_COMMENT_MODE,
            t.C_BLOCK_COMMENT_MODE,
            { begin: /"""/, end: /"""/, className: 'string', contains: [t.BACKSLASH_ESCAPE] },
            t.APOS_STRING_MODE,
            t.QUOTE_STRING_MODE,
            {
                match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, n],
                className: { 1: 'keyword', 3: 'title.class' },
            },
            { match: /non-sealed/, scope: 'keyword' },
            {
                begin: [e.concat(/(?!else)/, n), /\s+/, n, /\s+/, /=(?!=)/],
                className: { 1: 'type', 3: 'variable', 5: 'operator' },
            },
            {
                begin: [/record/, /\s+/, n],
                className: { 1: 'keyword', 3: 'title.class' },
                contains: [f, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE],
            },
            { beginKeywords: 'new throw return else', relevance: 0 },
            {
                begin: ['(?:' + r + '\\s+)', t.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
                className: { 2: 'title.function' },
                keywords: u,
                contains: [
                    {
                        className: 'params',
                        begin: /\(/,
                        end: /\)/,
                        keywords: u,
                        relevance: 0,
                        contains: [d, t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, Ux, t.C_BLOCK_COMMENT_MODE],
                    },
                    t.C_LINE_COMMENT_MODE,
                    t.C_BLOCK_COMMENT_MODE,
                ],
            },
            Ux,
            d,
        ],
    };
}
var Vx = '[A-Za-z$_][0-9A-Za-z$_]*',
    pF = [
        'as',
        'in',
        'of',
        'if',
        'for',
        'while',
        'finally',
        'var',
        'new',
        'function',
        'do',
        'return',
        'void',
        'else',
        'break',
        'catch',
        'instanceof',
        'with',
        'throw',
        'case',
        'default',
        'try',
        'switch',
        'continue',
        'typeof',
        'delete',
        'let',
        'yield',
        'const',
        'class',
        'debugger',
        'async',
        'await',
        'static',
        'import',
        'from',
        'export',
        'extends',
    ],
    hF = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'],
    Gx = [
        'Object',
        'Function',
        'Boolean',
        'Symbol',
        'Math',
        'Date',
        'Number',
        'BigInt',
        'String',
        'RegExp',
        'Array',
        'Float32Array',
        'Float64Array',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Int32Array',
        'Uint16Array',
        'Uint32Array',
        'BigInt64Array',
        'BigUint64Array',
        'Set',
        'Map',
        'WeakSet',
        'WeakMap',
        'ArrayBuffer',
        'SharedArrayBuffer',
        'Atomics',
        'DataView',
        'JSON',
        'Promise',
        'Generator',
        'GeneratorFunction',
        'AsyncFunction',
        'Reflect',
        'Proxy',
        'Intl',
        'WebAssembly',
    ],
    qx = [
        'Error',
        'EvalError',
        'InternalError',
        'RangeError',
        'ReferenceError',
        'SyntaxError',
        'TypeError',
        'URIError',
    ],
    Yx = [
        'setInterval',
        'setTimeout',
        'clearInterval',
        'clearTimeout',
        'require',
        'exports',
        'eval',
        'isFinite',
        'isNaN',
        'parseFloat',
        'parseInt',
        'decodeURI',
        'decodeURIComponent',
        'encodeURI',
        'encodeURIComponent',
        'escape',
        'unescape',
    ],
    mF = [
        'arguments',
        'this',
        'super',
        'console',
        'window',
        'document',
        'localStorage',
        'sessionStorage',
        'module',
        'global',
    ],
    gF = [].concat(Yx, Gx, qx);
function Jx(t) {
    let e = t.regex,
        n = (R, { after: V }) => {
            let Q = '</' + R[0].slice(1);
            return R.input.indexOf(Q, V) !== -1;
        },
        r = Vx,
        i = { begin: '<>', end: '</>' },
        o = /<[A-Za-z0-9\\._:-]+\s*\/>/,
        s = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (R, V) => {
                let Q = R[0].length + R.index,
                    he = R.input[Q];
                if (he === '<' || he === ',') {
                    V.ignoreMatch();
                    return;
                }
                he === '>' && (n(R, { after: Q }) || V.ignoreMatch());
                let xe,
                    Ue = R.input.substring(Q);
                if ((xe = Ue.match(/^\s*=/))) {
                    V.ignoreMatch();
                    return;
                }
                if ((xe = Ue.match(/^\s+extends\s+/)) && xe.index === 0) {
                    V.ignoreMatch();
                    return;
                }
            },
        },
        l = { $pattern: Vx, keyword: pF, literal: hF, built_in: gF, 'variable.language': mF },
        u = '[0-9](_?[0-9])*',
        d = `\\.(${u})`,
        f = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*',
        h = {
            className: 'number',
            variants: [
                { begin: `(\\b(${f})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
                { begin: `\\b(${f})\\b((${d})\\b|\\.)?|(${d})\\b` },
                { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
                { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
                { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
                { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
                { begin: '\\b0[0-7]+n?\\b' },
            ],
            relevance: 0,
        },
        m = { className: 'subst', begin: '\\$\\{', end: '\\}', keywords: l, contains: [] },
        b = {
            begin: 'html`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'xml' },
        },
        y = {
            begin: 'css`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'css' },
        },
        v = {
            begin: 'gql`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'graphql' },
        },
        x = { className: 'string', begin: '`', end: '`', contains: [t.BACKSLASH_ESCAPE, m] },
        D = {
            className: 'comment',
            variants: [
                t.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
                    relevance: 0,
                    contains: [
                        {
                            begin: '(?=@[A-Za-z]+)',
                            relevance: 0,
                            contains: [
                                { className: 'doctag', begin: '@[A-Za-z]+' },
                                {
                                    className: 'type',
                                    begin: '\\{',
                                    end: '\\}',
                                    excludeEnd: !0,
                                    excludeBegin: !0,
                                    relevance: 0,
                                },
                                { className: 'variable', begin: r + '(?=\\s*(-)|$)', endsParent: !0, relevance: 0 },
                                { begin: /(?=[^\n])\s/, relevance: 0 },
                            ],
                        },
                    ],
                }),
                t.C_BLOCK_COMMENT_MODE,
                t.C_LINE_COMMENT_MODE,
            ],
        },
        I = [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, b, y, v, x, { match: /\$\d+/ }, h];
    m.contains = I.concat({ begin: /\{/, end: /\}/, keywords: l, contains: ['self'].concat(I) });
    let S = [].concat(D, m.contains),
        z = S.concat([{ begin: /\(/, end: /\)/, keywords: l, contains: ['self'].concat(S) }]),
        N = { className: 'params', begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: l, contains: z },
        q = {
            variants: [
                {
                    match: [/class/, /\s+/, r, /\s+/, /extends/, /\s+/, e.concat(r, '(', e.concat(/\./, r), ')*')],
                    scope: { 1: 'keyword', 3: 'title.class', 5: 'keyword', 7: 'title.class.inherited' },
                },
                { match: [/class/, /\s+/, r], scope: { 1: 'keyword', 3: 'title.class' } },
            ],
        },
        ne = {
            relevance: 0,
            match: e.either(
                /\bJSON/,
                /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/,
            ),
            className: 'title.class',
            keywords: { _: [...Gx, ...qx] },
        },
        $ = { label: 'use_strict', className: 'meta', relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ },
        oe = {
            variants: [{ match: [/function/, /\s+/, r, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }],
            className: { 1: 'keyword', 3: 'title.function' },
            label: 'func.def',
            contains: [N],
            illegal: /%/,
        },
        me = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' };
    function Te(R) {
        return e.concat('(?!', R.join('|'), ')');
    }
    let ge = {
            match: e.concat(/\b/, Te([...Yx, 'super', 'import']), r, e.lookahead(/\(/)),
            className: 'title.function',
            relevance: 0,
        },
        Me = {
            begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))),
            end: r,
            excludeBegin: !0,
            keywords: 'prototype',
            className: 'property',
            relevance: 0,
        },
        Ee = {
            match: [/get|set/, /\s+/, r, /(?=\()/],
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [{ begin: /\(\)/ }, N],
        },
        P = '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' + t.UNDERSCORE_IDENT_RE + ')\\s*=>',
        O = {
            match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(P)],
            keywords: 'async',
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [N],
        };
    return {
        name: 'JavaScript',
        aliases: ['js', 'jsx', 'mjs', 'cjs'],
        keywords: l,
        exports: { PARAMS_CONTAINS: z, CLASS_REFERENCE: ne },
        illegal: /#(?![$_A-z])/,
        contains: [
            t.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
            $,
            t.APOS_STRING_MODE,
            t.QUOTE_STRING_MODE,
            b,
            y,
            v,
            x,
            D,
            { match: /\$\d+/ },
            h,
            ne,
            { className: 'attr', begin: r + e.lookahead(':'), relevance: 0 },
            O,
            {
                begin: '(' + t.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                keywords: 'return throw case',
                relevance: 0,
                contains: [
                    D,
                    t.REGEXP_MODE,
                    {
                        className: 'function',
                        begin: P,
                        returnBegin: !0,
                        end: '\\s*=>',
                        contains: [
                            {
                                className: 'params',
                                variants: [
                                    { begin: t.UNDERSCORE_IDENT_RE, relevance: 0 },
                                    { className: null, begin: /\(\s*\)/, skip: !0 },
                                    {
                                        begin: /\(/,
                                        end: /\)/,
                                        excludeBegin: !0,
                                        excludeEnd: !0,
                                        keywords: l,
                                        contains: z,
                                    },
                                ],
                            },
                        ],
                    },
                    { begin: /,/, relevance: 0 },
                    { match: /\s+/, relevance: 0 },
                    {
                        variants: [
                            { begin: i.begin, end: i.end },
                            { match: o },
                            { begin: s.begin, 'on:begin': s.isTrulyOpeningTag, end: s.end },
                        ],
                        subLanguage: 'xml',
                        contains: [{ begin: s.begin, end: s.end, skip: !0, contains: ['self'] }],
                    },
                ],
            },
            oe,
            { beginKeywords: 'while if switch catch for' },
            {
                begin:
                    '\\b(?!function)' +
                    t.UNDERSCORE_IDENT_RE +
                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
                returnBegin: !0,
                label: 'func.def',
                contains: [N, t.inherit(t.TITLE_MODE, { begin: r, className: 'title.function' })],
            },
            { match: /\.\.\./, relevance: 0 },
            Me,
            { match: '\\$' + r, relevance: 0 },
            { match: [/\bconstructor(?=\s*\()/], className: { 1: 'title.function' }, contains: [N] },
            ge,
            me,
            q,
            Ee,
            { match: /\$[(.]/ },
        ],
    };
}
function Xx(t) {
    let e = { className: 'attr', begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 },
        n = { match: /[{}[\],:]/, className: 'punctuation', relevance: 0 },
        r = ['true', 'false', 'null'],
        i = { scope: 'literal', beginKeywords: r.join(' ') };
    return {
        name: 'JSON',
        keywords: { literal: r },
        contains: [e, n, t.QUOTE_STRING_MODE, i, t.C_NUMBER_MODE, t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE],
        illegal: '\\S',
    };
}
var ls = '[0-9](_*[0-9])*',
    mu = `\\.(${ls})`,
    gu = '[0-9a-fA-F](_*[0-9a-fA-F])*',
    bF = {
        className: 'number',
        variants: [
            { begin: `(\\b(${ls})((${mu})|\\.)?|(${mu}))[eE][+-]?(${ls})[fFdD]?\\b` },
            { begin: `\\b(${ls})((${mu})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
            { begin: `(${mu})[fFdD]?\\b` },
            { begin: `\\b(${ls})[fFdD]\\b` },
            { begin: `\\b0[xX]((${gu})\\.?|(${gu})?\\.(${gu}))[pP][+-]?(${ls})[fFdD]?\\b` },
            { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
            { begin: `\\b0[xX](${gu})[lL]?\\b` },
            { begin: '\\b0(_*[0-7])*[lL]?\\b' },
            { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
        ],
        relevance: 0,
    };
function Zx(t) {
    let e = {
            keyword:
                'abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual',
            built_in: 'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
            literal: 'true false null',
        },
        n = {
            className: 'keyword',
            begin: /\b(break|continue|return|this)\b/,
            starts: { contains: [{ className: 'symbol', begin: /@\w+/ }] },
        },
        r = { className: 'symbol', begin: t.UNDERSCORE_IDENT_RE + '@' },
        i = { className: 'subst', begin: /\$\{/, end: /\}/, contains: [t.C_NUMBER_MODE] },
        o = { className: 'variable', begin: '\\$' + t.UNDERSCORE_IDENT_RE },
        s = {
            className: 'string',
            variants: [
                { begin: '"""', end: '"""(?=[^"])', contains: [o, i] },
                { begin: "'", end: "'", illegal: /\n/, contains: [t.BACKSLASH_ESCAPE] },
                { begin: '"', end: '"', illegal: /\n/, contains: [t.BACKSLASH_ESCAPE, o, i] },
            ],
        };
    i.contains.push(s);
    let l = {
            className: 'meta',
            begin:
                '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' +
                t.UNDERSCORE_IDENT_RE +
                ')?',
        },
        u = {
            className: 'meta',
            begin: '@' + t.UNDERSCORE_IDENT_RE,
            contains: [{ begin: /\(/, end: /\)/, contains: [t.inherit(s, { className: 'string' }), 'self'] }],
        },
        d = bF,
        f = t.COMMENT('/\\*', '\\*/', { contains: [t.C_BLOCK_COMMENT_MODE] }),
        h = {
            variants: [
                { className: 'type', begin: t.UNDERSCORE_IDENT_RE },
                { begin: /\(/, end: /\)/, contains: [] },
            ],
        },
        m = h;
    return (
        (m.variants[1].contains = [h]),
        (h.variants[1].contains = [m]),
        {
            name: 'Kotlin',
            aliases: ['kt', 'kts'],
            keywords: e,
            contains: [
                t.COMMENT('/\\*\\*', '\\*/', {
                    relevance: 0,
                    contains: [{ className: 'doctag', begin: '@[A-Za-z]+' }],
                }),
                t.C_LINE_COMMENT_MODE,
                f,
                n,
                r,
                l,
                u,
                {
                    className: 'function',
                    beginKeywords: 'fun',
                    end: '[(]|$',
                    returnBegin: !0,
                    excludeEnd: !0,
                    keywords: e,
                    relevance: 5,
                    contains: [
                        {
                            begin: t.UNDERSCORE_IDENT_RE + '\\s*\\(',
                            returnBegin: !0,
                            relevance: 0,
                            contains: [t.UNDERSCORE_TITLE_MODE],
                        },
                        { className: 'type', begin: /</, end: />/, keywords: 'reified', relevance: 0 },
                        {
                            className: 'params',
                            begin: /\(/,
                            end: /\)/,
                            endsParent: !0,
                            keywords: e,
                            relevance: 0,
                            contains: [
                                {
                                    begin: /:/,
                                    end: /[=,\/]/,
                                    endsWithParent: !0,
                                    contains: [h, t.C_LINE_COMMENT_MODE, f],
                                    relevance: 0,
                                },
                                t.C_LINE_COMMENT_MODE,
                                f,
                                l,
                                u,
                                s,
                                t.C_NUMBER_MODE,
                            ],
                        },
                        f,
                    ],
                },
                {
                    begin: [/class|interface|trait/, /\s+/, t.UNDERSCORE_IDENT_RE],
                    beginScope: { 3: 'title.class' },
                    keywords: 'class interface trait',
                    end: /[:\{(]|$/,
                    excludeEnd: !0,
                    illegal: 'extends implements',
                    contains: [
                        { beginKeywords: 'public protected internal private constructor' },
                        t.UNDERSCORE_TITLE_MODE,
                        { className: 'type', begin: /</, end: />/, excludeBegin: !0, excludeEnd: !0, relevance: 0 },
                        { className: 'type', begin: /[,:]\s*/, end: /[<\(,){\s]|$/, excludeBegin: !0, returnEnd: !0 },
                        l,
                        u,
                    ],
                },
                s,
                {
                    className: 'meta',
                    begin: '^#!/usr/bin/env',
                    end: '$',
                    illegal: `
`,
                },
                d,
            ],
        }
    );
}
var yF = (t) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
            scope: 'selector-attr',
            begin: /\[/,
            end: /\]/,
            illegal: '$',
            contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
            scope: 'number',
            begin:
                t.NUMBER_RE +
                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
            relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ },
    }),
    EF = [
        'a',
        'abbr',
        'address',
        'article',
        'aside',
        'audio',
        'b',
        'blockquote',
        'body',
        'button',
        'canvas',
        'caption',
        'cite',
        'code',
        'dd',
        'del',
        'details',
        'dfn',
        'div',
        'dl',
        'dt',
        'em',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'header',
        'hgroup',
        'html',
        'i',
        'iframe',
        'img',
        'input',
        'ins',
        'kbd',
        'label',
        'legend',
        'li',
        'main',
        'mark',
        'menu',
        'nav',
        'object',
        'ol',
        'p',
        'q',
        'quote',
        'samp',
        'section',
        'span',
        'strong',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'tr',
        'ul',
        'var',
        'video',
    ],
    vF = [
        'any-hover',
        'any-pointer',
        'aspect-ratio',
        'color',
        'color-gamut',
        'color-index',
        'device-aspect-ratio',
        'device-height',
        'device-width',
        'display-mode',
        'forced-colors',
        'grid',
        'height',
        'hover',
        'inverted-colors',
        'monochrome',
        'orientation',
        'overflow-block',
        'overflow-inline',
        'pointer',
        'prefers-color-scheme',
        'prefers-contrast',
        'prefers-reduced-motion',
        'prefers-reduced-transparency',
        'resolution',
        'scan',
        'scripting',
        'update',
        'width',
        'min-width',
        'max-width',
        'min-height',
        'max-height',
    ],
    jx = [
        'active',
        'any-link',
        'blank',
        'checked',
        'current',
        'default',
        'defined',
        'dir',
        'disabled',
        'drop',
        'empty',
        'enabled',
        'first',
        'first-child',
        'first-of-type',
        'fullscreen',
        'future',
        'focus',
        'focus-visible',
        'focus-within',
        'has',
        'host',
        'host-context',
        'hover',
        'indeterminate',
        'in-range',
        'invalid',
        'is',
        'lang',
        'last-child',
        'last-of-type',
        'left',
        'link',
        'local-link',
        'not',
        'nth-child',
        'nth-col',
        'nth-last-child',
        'nth-last-col',
        'nth-last-of-type',
        'nth-of-type',
        'only-child',
        'only-of-type',
        'optional',
        'out-of-range',
        'past',
        'placeholder-shown',
        'read-only',
        'read-write',
        'required',
        'right',
        'root',
        'scope',
        'target',
        'target-within',
        'user-invalid',
        'valid',
        'visited',
        'where',
    ],
    Qx = [
        'after',
        'backdrop',
        'before',
        'cue',
        'cue-region',
        'first-letter',
        'first-line',
        'grammar-error',
        'marker',
        'part',
        'placeholder',
        'selection',
        'slotted',
        'spelling-error',
    ],
    wF = [
        'align-content',
        'align-items',
        'align-self',
        'all',
        'animation',
        'animation-delay',
        'animation-direction',
        'animation-duration',
        'animation-fill-mode',
        'animation-iteration-count',
        'animation-name',
        'animation-play-state',
        'animation-timing-function',
        'backface-visibility',
        'background',
        'background-attachment',
        'background-blend-mode',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'block-size',
        'border',
        'border-block',
        'border-block-color',
        'border-block-end',
        'border-block-end-color',
        'border-block-end-style',
        'border-block-end-width',
        'border-block-start',
        'border-block-start-color',
        'border-block-start-style',
        'border-block-start-width',
        'border-block-style',
        'border-block-width',
        'border-bottom',
        'border-bottom-color',
        'border-bottom-left-radius',
        'border-bottom-right-radius',
        'border-bottom-style',
        'border-bottom-width',
        'border-collapse',
        'border-color',
        'border-image',
        'border-image-outset',
        'border-image-repeat',
        'border-image-slice',
        'border-image-source',
        'border-image-width',
        'border-inline',
        'border-inline-color',
        'border-inline-end',
        'border-inline-end-color',
        'border-inline-end-style',
        'border-inline-end-width',
        'border-inline-start',
        'border-inline-start-color',
        'border-inline-start-style',
        'border-inline-start-width',
        'border-inline-style',
        'border-inline-width',
        'border-left',
        'border-left-color',
        'border-left-style',
        'border-left-width',
        'border-radius',
        'border-right',
        'border-right-color',
        'border-right-style',
        'border-right-width',
        'border-spacing',
        'border-style',
        'border-top',
        'border-top-color',
        'border-top-left-radius',
        'border-top-right-radius',
        'border-top-style',
        'border-top-width',
        'border-width',
        'bottom',
        'box-decoration-break',
        'box-shadow',
        'box-sizing',
        'break-after',
        'break-before',
        'break-inside',
        'caption-side',
        'caret-color',
        'clear',
        'clip',
        'clip-path',
        'clip-rule',
        'color',
        'column-count',
        'column-fill',
        'column-gap',
        'column-rule',
        'column-rule-color',
        'column-rule-style',
        'column-rule-width',
        'column-span',
        'column-width',
        'columns',
        'contain',
        'content',
        'content-visibility',
        'counter-increment',
        'counter-reset',
        'cue',
        'cue-after',
        'cue-before',
        'cursor',
        'direction',
        'display',
        'empty-cells',
        'filter',
        'flex',
        'flex-basis',
        'flex-direction',
        'flex-flow',
        'flex-grow',
        'flex-shrink',
        'flex-wrap',
        'float',
        'flow',
        'font',
        'font-display',
        'font-family',
        'font-feature-settings',
        'font-kerning',
        'font-language-override',
        'font-size',
        'font-size-adjust',
        'font-smoothing',
        'font-stretch',
        'font-style',
        'font-synthesis',
        'font-variant',
        'font-variant-caps',
        'font-variant-east-asian',
        'font-variant-ligatures',
        'font-variant-numeric',
        'font-variant-position',
        'font-variation-settings',
        'font-weight',
        'gap',
        'glyph-orientation-vertical',
        'grid',
        'grid-area',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-auto-rows',
        'grid-column',
        'grid-column-end',
        'grid-column-start',
        'grid-gap',
        'grid-row',
        'grid-row-end',
        'grid-row-start',
        'grid-template',
        'grid-template-areas',
        'grid-template-columns',
        'grid-template-rows',
        'hanging-punctuation',
        'height',
        'hyphens',
        'icon',
        'image-orientation',
        'image-rendering',
        'image-resolution',
        'ime-mode',
        'inline-size',
        'isolation',
        'justify-content',
        'left',
        'letter-spacing',
        'line-break',
        'line-height',
        'list-style',
        'list-style-image',
        'list-style-position',
        'list-style-type',
        'margin',
        'margin-block',
        'margin-block-end',
        'margin-block-start',
        'margin-bottom',
        'margin-inline',
        'margin-inline-end',
        'margin-inline-start',
        'margin-left',
        'margin-right',
        'margin-top',
        'marks',
        'mask',
        'mask-border',
        'mask-border-mode',
        'mask-border-outset',
        'mask-border-repeat',
        'mask-border-slice',
        'mask-border-source',
        'mask-border-width',
        'mask-clip',
        'mask-composite',
        'mask-image',
        'mask-mode',
        'mask-origin',
        'mask-position',
        'mask-repeat',
        'mask-size',
        'mask-type',
        'max-block-size',
        'max-height',
        'max-inline-size',
        'max-width',
        'min-block-size',
        'min-height',
        'min-inline-size',
        'min-width',
        'mix-blend-mode',
        'nav-down',
        'nav-index',
        'nav-left',
        'nav-right',
        'nav-up',
        'none',
        'normal',
        'object-fit',
        'object-position',
        'opacity',
        'order',
        'orphans',
        'outline',
        'outline-color',
        'outline-offset',
        'outline-style',
        'outline-width',
        'overflow',
        'overflow-wrap',
        'overflow-x',
        'overflow-y',
        'padding',
        'padding-block',
        'padding-block-end',
        'padding-block-start',
        'padding-bottom',
        'padding-inline',
        'padding-inline-end',
        'padding-inline-start',
        'padding-left',
        'padding-right',
        'padding-top',
        'page-break-after',
        'page-break-before',
        'page-break-inside',
        'pause',
        'pause-after',
        'pause-before',
        'perspective',
        'perspective-origin',
        'pointer-events',
        'position',
        'quotes',
        'resize',
        'rest',
        'rest-after',
        'rest-before',
        'right',
        'row-gap',
        'scroll-margin',
        'scroll-margin-block',
        'scroll-margin-block-end',
        'scroll-margin-block-start',
        'scroll-margin-bottom',
        'scroll-margin-inline',
        'scroll-margin-inline-end',
        'scroll-margin-inline-start',
        'scroll-margin-left',
        'scroll-margin-right',
        'scroll-margin-top',
        'scroll-padding',
        'scroll-padding-block',
        'scroll-padding-block-end',
        'scroll-padding-block-start',
        'scroll-padding-bottom',
        'scroll-padding-inline',
        'scroll-padding-inline-end',
        'scroll-padding-inline-start',
        'scroll-padding-left',
        'scroll-padding-right',
        'scroll-padding-top',
        'scroll-snap-align',
        'scroll-snap-stop',
        'scroll-snap-type',
        'scrollbar-color',
        'scrollbar-gutter',
        'scrollbar-width',
        'shape-image-threshold',
        'shape-margin',
        'shape-outside',
        'speak',
        'speak-as',
        'src',
        'tab-size',
        'table-layout',
        'text-align',
        'text-align-all',
        'text-align-last',
        'text-combine-upright',
        'text-decoration',
        'text-decoration-color',
        'text-decoration-line',
        'text-decoration-style',
        'text-emphasis',
        'text-emphasis-color',
        'text-emphasis-position',
        'text-emphasis-style',
        'text-indent',
        'text-justify',
        'text-orientation',
        'text-overflow',
        'text-rendering',
        'text-shadow',
        'text-transform',
        'text-underline-position',
        'top',
        'transform',
        'transform-box',
        'transform-origin',
        'transform-style',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function',
        'unicode-bidi',
        'vertical-align',
        'visibility',
        'voice-balance',
        'voice-duration',
        'voice-family',
        'voice-pitch',
        'voice-range',
        'voice-rate',
        'voice-stress',
        'voice-volume',
        'white-space',
        'widows',
        'width',
        'will-change',
        'word-break',
        'word-spacing',
        'word-wrap',
        'writing-mode',
        'z-index',
    ].reverse(),
    xF = jx.concat(Qx);
function e_(t) {
    let e = yF(t),
        n = xF,
        r = 'and or not only',
        i = '[\\w-]+',
        o = '(' + i + '|@\\{' + i + '\\})',
        s = [],
        l = [],
        u = function (I) {
            return { className: 'string', begin: '~?' + I + '.*?' + I };
        },
        d = function (I, S, z) {
            return { className: I, begin: S, relevance: z };
        },
        f = { $pattern: /[a-z-]+/, keyword: r, attribute: vF.join(' ') },
        h = { begin: '\\(', end: '\\)', contains: l, keywords: f, relevance: 0 };
    l.push(
        t.C_LINE_COMMENT_MODE,
        t.C_BLOCK_COMMENT_MODE,
        u("'"),
        u('"'),
        e.CSS_NUMBER_MODE,
        { begin: '(url|data-uri)\\(', starts: { className: 'string', end: '[\\)\\n]', excludeEnd: !0 } },
        e.HEXCOLOR,
        h,
        d('variable', '@@?' + i, 10),
        d('variable', '@\\{' + i + '\\}'),
        d('built_in', '~?`[^`]*?`'),
        { className: 'attribute', begin: i + '\\s*:', end: ':', returnBegin: !0, excludeEnd: !0 },
        e.IMPORTANT,
        { beginKeywords: 'and not' },
        e.FUNCTION_DISPATCH,
    );
    let m = l.concat({ begin: /\{/, end: /\}/, contains: s }),
        b = { beginKeywords: 'when', endsWithParent: !0, contains: [{ beginKeywords: 'and not' }].concat(l) },
        y = {
            begin: o + '\\s*:',
            returnBegin: !0,
            end: /[;}]/,
            relevance: 0,
            contains: [
                { begin: /-(webkit|moz|ms|o)-/ },
                e.CSS_VARIABLE,
                {
                    className: 'attribute',
                    begin: '\\b(' + wF.join('|') + ')\\b',
                    end: /(?=:)/,
                    starts: { endsWithParent: !0, illegal: '[<=$]', relevance: 0, contains: l },
                },
            ],
        },
        v = {
            className: 'keyword',
            begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
            starts: { end: '[;{}]', keywords: f, returnEnd: !0, contains: l, relevance: 0 },
        },
        x = {
            className: 'variable',
            variants: [{ begin: '@' + i + '\\s*:', relevance: 15 }, { begin: '@' + i }],
            starts: { end: '[;}]', returnEnd: !0, contains: m },
        },
        T = {
            variants: [
                { begin: '[\\.#:&\\[>]', end: '[;{}]' },
                { begin: o, end: /\{/ },
            ],
            returnBegin: !0,
            returnEnd: !0,
            illegal: `[<='$"]`,
            relevance: 0,
            contains: [
                t.C_LINE_COMMENT_MODE,
                t.C_BLOCK_COMMENT_MODE,
                b,
                d('keyword', 'all\\b'),
                d('variable', '@\\{' + i + '\\}'),
                { begin: '\\b(' + EF.join('|') + ')\\b', className: 'selector-tag' },
                e.CSS_NUMBER_MODE,
                d('selector-tag', o, 0),
                d('selector-id', '#' + o),
                d('selector-class', '\\.' + o, 0),
                d('selector-tag', '&', 0),
                e.ATTRIBUTE_SELECTOR_MODE,
                { className: 'selector-pseudo', begin: ':(' + jx.join('|') + ')' },
                { className: 'selector-pseudo', begin: ':(:)?(' + Qx.join('|') + ')' },
                { begin: /\(/, end: /\)/, relevance: 0, contains: m },
                { begin: '!important' },
                e.FUNCTION_DISPATCH,
            ],
        },
        D = { begin: i + `:(:)?(${n.join('|')})`, returnBegin: !0, contains: [T] };
    return (
        s.push(t.C_LINE_COMMENT_MODE, t.C_BLOCK_COMMENT_MODE, v, x, D, y, T, b, e.FUNCTION_DISPATCH),
        { name: 'Less', case_insensitive: !0, illegal: `[=>'/<($"]`, contains: s }
    );
}
function t_(t) {
    let e = '\\[=*\\[',
        n = '\\]=*\\]',
        r = { begin: e, end: n, contains: ['self'] },
        i = [t.COMMENT('--(?!' + e + ')', '$'), t.COMMENT('--' + e, n, { contains: [r], relevance: 10 })];
    return {
        name: 'Lua',
        keywords: {
            $pattern: t.UNDERSCORE_IDENT_RE,
            literal: 'true false nil',
            keyword: 'and break do else elseif end for goto if in local not or repeat return then until while',
            built_in:
                '_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove',
        },
        contains: i.concat([
            {
                className: 'function',
                beginKeywords: 'function',
                end: '\\)',
                contains: [
                    t.inherit(t.TITLE_MODE, { begin: '([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*' }),
                    { className: 'params', begin: '\\(', endsWithParent: !0, contains: i },
                ].concat(i),
            },
            t.C_NUMBER_MODE,
            t.APOS_STRING_MODE,
            t.QUOTE_STRING_MODE,
            { className: 'string', begin: e, end: n, contains: [r], relevance: 5 },
        ]),
    };
}
function n_(t) {
    let e = {
            className: 'variable',
            variants: [
                { begin: '\\$\\(' + t.UNDERSCORE_IDENT_RE + '\\)', contains: [t.BACKSLASH_ESCAPE] },
                { begin: /\$[@%<?\^\+\*]/ },
            ],
        },
        n = { className: 'string', begin: /"/, end: /"/, contains: [t.BACKSLASH_ESCAPE, e] },
        r = {
            className: 'variable',
            begin: /\$\([\w-]+\s/,
            end: /\)/,
            keywords: {
                built_in:
                    'subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value',
            },
            contains: [e],
        },
        i = { begin: '^' + t.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)' },
        o = { className: 'meta', begin: /^\.PHONY:/, end: /$/, keywords: { $pattern: /[\.\w]+/, keyword: '.PHONY' } },
        s = { className: 'section', begin: /^[^\s]+:/, end: /$/, contains: [e] };
    return {
        name: 'Makefile',
        aliases: ['mk', 'mak', 'make'],
        keywords: {
            $pattern: /[\w-]+/,
            keyword:
                'define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath',
        },
        contains: [t.HASH_COMMENT_MODE, e, n, r, i, o, s],
    };
}
function r_(t) {
    let e = t.regex,
        n = { begin: /<\/?[A-Za-z_]/, end: '>', subLanguage: 'xml', relevance: 0 },
        r = { begin: '^[-\\*]{3,}', end: '$' },
        i = {
            className: 'code',
            variants: [
                { begin: '(`{3,})[^`](.|\\n)*?\\1`*[ ]*' },
                { begin: '(~{3,})[^~](.|\\n)*?\\1~*[ ]*' },
                { begin: '```', end: '```+[ ]*$' },
                { begin: '~~~', end: '~~~+[ ]*$' },
                { begin: '`.+?`' },
                { begin: '(?=^( {4}|\\t))', contains: [{ begin: '^( {4}|\\t)', end: '(\\n)$' }], relevance: 0 },
            ],
        },
        o = { className: 'bullet', begin: '^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)', end: '\\s+', excludeEnd: !0 },
        s = {
            begin: /^\[[^\n]+\]:/,
            returnBegin: !0,
            contains: [
                { className: 'symbol', begin: /\[/, end: /\]/, excludeBegin: !0, excludeEnd: !0 },
                { className: 'link', begin: /:\s*/, end: /$/, excludeBegin: !0 },
            ],
        },
        l = /[A-Za-z][A-Za-z0-9+.-]*/,
        u = {
            variants: [
                { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
                { begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 },
                { begin: e.concat(/\[.+?\]\(/, l, /:\/\/.*?\)/), relevance: 2 },
                { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
                { begin: /\[.*?\]\(.*?\)/, relevance: 0 },
            ],
            returnBegin: !0,
            contains: [
                { match: /\[(?=\])/ },
                { className: 'string', relevance: 0, begin: '\\[', end: '\\]', excludeBegin: !0, returnEnd: !0 },
                { className: 'link', relevance: 0, begin: '\\]\\(', end: '\\)', excludeBegin: !0, excludeEnd: !0 },
                { className: 'symbol', relevance: 0, begin: '\\]\\[', end: '\\]', excludeBegin: !0, excludeEnd: !0 },
            ],
        },
        d = {
            className: 'strong',
            contains: [],
            variants: [
                { begin: /_{2}(?!\s)/, end: /_{2}/ },
                { begin: /\*{2}(?!\s)/, end: /\*{2}/ },
            ],
        },
        f = {
            className: 'emphasis',
            contains: [],
            variants: [
                { begin: /\*(?![*\s])/, end: /\*/ },
                { begin: /_(?![_\s])/, end: /_/, relevance: 0 },
            ],
        },
        h = t.inherit(d, { contains: [] }),
        m = t.inherit(f, { contains: [] });
    d.contains.push(m), f.contains.push(h);
    let b = [n, u];
    return (
        [d, f, h, m].forEach((x) => {
            x.contains = x.contains.concat(b);
        }),
        (b = b.concat(d, f)),
        {
            name: 'Markdown',
            aliases: ['md', 'mkdown', 'mkd'],
            contains: [
                {
                    className: 'section',
                    variants: [
                        { begin: '^#{1,6}', end: '$', contains: b },
                        {
                            begin: '(?=^.+?\\n[=-]{2,}$)',
                            contains: [{ begin: '^[=-]*$' }, { begin: '^', end: '\\n', contains: b }],
                        },
                    ],
                },
                n,
                o,
                d,
                f,
                { className: 'quote', begin: '^>\\s+', contains: b, end: '$' },
                i,
                r,
                u,
                s,
            ],
        }
    );
}
function i_(t) {
    let e = { className: 'built_in', begin: '\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+' },
        n = /[a-zA-Z@][a-zA-Z0-9_]*/,
        l = {
            'variable.language': ['this', 'super'],
            $pattern: n,
            keyword: [
                'while',
                'export',
                'sizeof',
                'typedef',
                'const',
                'struct',
                'for',
                'union',
                'volatile',
                'static',
                'mutable',
                'if',
                'do',
                'return',
                'goto',
                'enum',
                'else',
                'break',
                'extern',
                'asm',
                'case',
                'default',
                'register',
                'explicit',
                'typename',
                'switch',
                'continue',
                'inline',
                'readonly',
                'assign',
                'readwrite',
                'self',
                '@synchronized',
                'id',
                'typeof',
                'nonatomic',
                'IBOutlet',
                'IBAction',
                'strong',
                'weak',
                'copy',
                'in',
                'out',
                'inout',
                'bycopy',
                'byref',
                'oneway',
                '__strong',
                '__weak',
                '__block',
                '__autoreleasing',
                '@private',
                '@protected',
                '@public',
                '@try',
                '@property',
                '@end',
                '@throw',
                '@catch',
                '@finally',
                '@autoreleasepool',
                '@synthesize',
                '@dynamic',
                '@selector',
                '@optional',
                '@required',
                '@encode',
                '@package',
                '@import',
                '@defs',
                '@compatibility_alias',
                '__bridge',
                '__bridge_transfer',
                '__bridge_retained',
                '__bridge_retain',
                '__covariant',
                '__contravariant',
                '__kindof',
                '_Nonnull',
                '_Nullable',
                '_Null_unspecified',
                '__FUNCTION__',
                '__PRETTY_FUNCTION__',
                '__attribute__',
                'getter',
                'setter',
                'retain',
                'unsafe_unretained',
                'nonnull',
                'nullable',
                'null_unspecified',
                'null_resettable',
                'class',
                'instancetype',
                'NS_DESIGNATED_INITIALIZER',
                'NS_UNAVAILABLE',
                'NS_REQUIRES_SUPER',
                'NS_RETURNS_INNER_POINTER',
                'NS_INLINE',
                'NS_AVAILABLE',
                'NS_DEPRECATED',
                'NS_ENUM',
                'NS_OPTIONS',
                'NS_SWIFT_UNAVAILABLE',
                'NS_ASSUME_NONNULL_BEGIN',
                'NS_ASSUME_NONNULL_END',
                'NS_REFINED_FOR_SWIFT',
                'NS_SWIFT_NAME',
                'NS_SWIFT_NOTHROW',
                'NS_DURING',
                'NS_HANDLER',
                'NS_ENDHANDLER',
                'NS_VALUERETURN',
                'NS_VOIDRETURN',
            ],
            literal: ['false', 'true', 'FALSE', 'TRUE', 'nil', 'YES', 'NO', 'NULL'],
            built_in: ['dispatch_once_t', 'dispatch_queue_t', 'dispatch_sync', 'dispatch_async', 'dispatch_once'],
            type: [
                'int',
                'float',
                'char',
                'unsigned',
                'signed',
                'short',
                'long',
                'double',
                'wchar_t',
                'unichar',
                'void',
                'bool',
                'BOOL',
                'id|0',
                '_Bool',
            ],
        },
        u = { $pattern: n, keyword: ['@interface', '@class', '@protocol', '@implementation'] };
    return {
        name: 'Objective-C',
        aliases: ['mm', 'objc', 'obj-c', 'obj-c++', 'objective-c++'],
        keywords: l,
        illegal: '</',
        contains: [
            e,
            t.C_LINE_COMMENT_MODE,
            t.C_BLOCK_COMMENT_MODE,
            t.C_NUMBER_MODE,
            t.QUOTE_STRING_MODE,
            t.APOS_STRING_MODE,
            {
                className: 'string',
                variants: [{ begin: '@"', end: '"', illegal: '\\n', contains: [t.BACKSLASH_ESCAPE] }],
            },
            {
                className: 'meta',
                begin: /#\s*[a-z]+\b/,
                end: /$/,
                keywords: { keyword: 'if else elif endif define undef warning error line pragma ifdef ifndef include' },
                contains: [
                    { begin: /\\\n/, relevance: 0 },
                    t.inherit(t.QUOTE_STRING_MODE, { className: 'string' }),
                    { className: 'string', begin: /<.*?>/, end: /$/, illegal: '\\n' },
                    t.C_LINE_COMMENT_MODE,
                    t.C_BLOCK_COMMENT_MODE,
                ],
            },
            {
                className: 'class',
                begin: '(' + u.keyword.join('|') + ')\\b',
                end: /(\{|$)/,
                excludeEnd: !0,
                keywords: u,
                contains: [t.UNDERSCORE_TITLE_MODE],
            },
            { begin: '\\.' + t.UNDERSCORE_IDENT_RE, relevance: 0 },
        ],
    };
}
function o_(t) {
    let e = t.regex,
        n = [
            'abs',
            'accept',
            'alarm',
            'and',
            'atan2',
            'bind',
            'binmode',
            'bless',
            'break',
            'caller',
            'chdir',
            'chmod',
            'chomp',
            'chop',
            'chown',
            'chr',
            'chroot',
            'close',
            'closedir',
            'connect',
            'continue',
            'cos',
            'crypt',
            'dbmclose',
            'dbmopen',
            'defined',
            'delete',
            'die',
            'do',
            'dump',
            'each',
            'else',
            'elsif',
            'endgrent',
            'endhostent',
            'endnetent',
            'endprotoent',
            'endpwent',
            'endservent',
            'eof',
            'eval',
            'exec',
            'exists',
            'exit',
            'exp',
            'fcntl',
            'fileno',
            'flock',
            'for',
            'foreach',
            'fork',
            'format',
            'formline',
            'getc',
            'getgrent',
            'getgrgid',
            'getgrnam',
            'gethostbyaddr',
            'gethostbyname',
            'gethostent',
            'getlogin',
            'getnetbyaddr',
            'getnetbyname',
            'getnetent',
            'getpeername',
            'getpgrp',
            'getpriority',
            'getprotobyname',
            'getprotobynumber',
            'getprotoent',
            'getpwent',
            'getpwnam',
            'getpwuid',
            'getservbyname',
            'getservbyport',
            'getservent',
            'getsockname',
            'getsockopt',
            'given',
            'glob',
            'gmtime',
            'goto',
            'grep',
            'gt',
            'hex',
            'if',
            'index',
            'int',
            'ioctl',
            'join',
            'keys',
            'kill',
            'last',
            'lc',
            'lcfirst',
            'length',
            'link',
            'listen',
            'local',
            'localtime',
            'log',
            'lstat',
            'lt',
            'ma',
            'map',
            'mkdir',
            'msgctl',
            'msgget',
            'msgrcv',
            'msgsnd',
            'my',
            'ne',
            'next',
            'no',
            'not',
            'oct',
            'open',
            'opendir',
            'or',
            'ord',
            'our',
            'pack',
            'package',
            'pipe',
            'pop',
            'pos',
            'print',
            'printf',
            'prototype',
            'push',
            'q|0',
            'qq',
            'quotemeta',
            'qw',
            'qx',
            'rand',
            'read',
            'readdir',
            'readline',
            'readlink',
            'readpipe',
            'recv',
            'redo',
            'ref',
            'rename',
            'require',
            'reset',
            'return',
            'reverse',
            'rewinddir',
            'rindex',
            'rmdir',
            'say',
            'scalar',
            'seek',
            'seekdir',
            'select',
            'semctl',
            'semget',
            'semop',
            'send',
            'setgrent',
            'sethostent',
            'setnetent',
            'setpgrp',
            'setpriority',
            'setprotoent',
            'setpwent',
            'setservent',
            'setsockopt',
            'shift',
            'shmctl',
            'shmget',
            'shmread',
            'shmwrite',
            'shutdown',
            'sin',
            'sleep',
            'socket',
            'socketpair',
            'sort',
            'splice',
            'split',
            'sprintf',
            'sqrt',
            'srand',
            'stat',
            'state',
            'study',
            'sub',
            'substr',
            'symlink',
            'syscall',
            'sysopen',
            'sysread',
            'sysseek',
            'system',
            'syswrite',
            'tell',
            'telldir',
            'tie',
            'tied',
            'time',
            'times',
            'tr',
            'truncate',
            'uc',
            'ucfirst',
            'umask',
            'undef',
            'unless',
            'unlink',
            'unpack',
            'unshift',
            'untie',
            'until',
            'use',
            'utime',
            'values',
            'vec',
            'wait',
            'waitpid',
            'wantarray',
            'warn',
            'when',
            'while',
            'write',
            'x|0',
            'xor',
            'y|0',
        ],
        r = /[dualxmsipngr]{0,12}/,
        i = { $pattern: /[\w.]+/, keyword: n.join(' ') },
        o = { className: 'subst', begin: '[$@]\\{', end: '\\}', keywords: i },
        s = { begin: /->\{/, end: /\}/ },
        l = {
            variants: [
                { begin: /\$\d/ },
                { begin: e.concat(/[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, '(?![A-Za-z])(?![@$%])') },
                { begin: /[$%@][^\s\w{]/, relevance: 0 },
            ],
        },
        u = [t.BACKSLASH_ESCAPE, o, l],
        d = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/],
        f = (b, y, v = '\\1') => {
            let x = v === '\\1' ? v : e.concat(v, y);
            return e.concat(e.concat('(?:', b, ')'), y, /(?:\\.|[^\\\/])*?/, x, /(?:\\.|[^\\\/])*?/, v, r);
        },
        h = (b, y, v) => e.concat(e.concat('(?:', b, ')'), y, /(?:\\.|[^\\\/])*?/, v, r),
        m = [
            l,
            t.HASH_COMMENT_MODE,
            t.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
            s,
            {
                className: 'string',
                contains: u,
                variants: [
                    { begin: 'q[qwxr]?\\s*\\(', end: '\\)', relevance: 5 },
                    { begin: 'q[qwxr]?\\s*\\[', end: '\\]', relevance: 5 },
                    { begin: 'q[qwxr]?\\s*\\{', end: '\\}', relevance: 5 },
                    { begin: 'q[qwxr]?\\s*\\|', end: '\\|', relevance: 5 },
                    { begin: 'q[qwxr]?\\s*<', end: '>', relevance: 5 },
                    { begin: 'qw\\s+q', end: 'q', relevance: 5 },
                    { begin: "'", end: "'", contains: [t.BACKSLASH_ESCAPE] },
                    { begin: '"', end: '"' },
                    { begin: '`', end: '`', contains: [t.BACKSLASH_ESCAPE] },
                    { begin: /\{\w+\}/, relevance: 0 },
                    { begin: '-?\\w+\\s*=>', relevance: 0 },
                ],
            },
            {
                className: 'number',
                begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
                relevance: 0,
            },
            {
                begin: '(\\/\\/|' + t.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
                keywords: 'split return print reverse grep',
                relevance: 0,
                contains: [
                    t.HASH_COMMENT_MODE,
                    {
                        className: 'regexp',
                        variants: [
                            { begin: f('s|tr|y', e.either(...d, { capture: !0 })) },
                            { begin: f('s|tr|y', '\\(', '\\)') },
                            { begin: f('s|tr|y', '\\[', '\\]') },
                            { begin: f('s|tr|y', '\\{', '\\}') },
                        ],
                        relevance: 2,
                    },
                    {
                        className: 'regexp',
                        variants: [
                            { begin: /(m|qr)\/\//, relevance: 0 },
                            { begin: h('(?:m|qr)?', /\//, /\//) },
                            { begin: h('m|qr', e.either(...d, { capture: !0 }), /\1/) },
                            { begin: h('m|qr', /\(/, /\)/) },
                            { begin: h('m|qr', /\[/, /\]/) },
                            { begin: h('m|qr', /\{/, /\}/) },
                        ],
                    },
                ],
            },
            {
                className: 'function',
                beginKeywords: 'sub',
                end: '(\\s*\\(.*?\\))?[;{]',
                excludeEnd: !0,
                relevance: 5,
                contains: [t.TITLE_MODE],
            },
            { begin: '-\\w\\b', relevance: 0 },
            {
                begin: '^__DATA__$',
                end: '^__END__$',
                subLanguage: 'mojolicious',
                contains: [{ begin: '^@@.*', end: '$', className: 'comment' }],
            },
        ];
    return (o.contains = m), (s.contains = m), { name: 'Perl', aliases: ['pl', 'pm'], keywords: i, contains: m };
}
function s_(t) {
    let e = t.regex,
        n = /(?![A-Za-z0-9])(?![$])/,
        r = e.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, n),
        i = e.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, n),
        o = { scope: 'variable', match: '\\$+' + r },
        s = {
            scope: 'meta',
            variants: [
                { begin: /<\?php/, relevance: 10 },
                { begin: /<\?=/ },
                { begin: /<\?/, relevance: 0.1 },
                { begin: /\?>/ },
            ],
        },
        l = { scope: 'subst', variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] },
        u = t.inherit(t.APOS_STRING_MODE, { illegal: null }),
        d = t.inherit(t.QUOTE_STRING_MODE, { illegal: null, contains: t.QUOTE_STRING_MODE.contains.concat(l) }),
        f = {
            begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
            end: /[ \t]*(\w+)\b/,
            contains: t.QUOTE_STRING_MODE.contains.concat(l),
            'on:begin': (ge, Me) => {
                Me.data._beginMatch = ge[1] || ge[2];
            },
            'on:end': (ge, Me) => {
                Me.data._beginMatch !== ge[1] && Me.ignoreMatch();
            },
        },
        h = t.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*'(\w+)'\n/, end: /[ \t]*(\w+)\b/ }),
        m = `[ 	
]`,
        b = { scope: 'string', variants: [d, u, f, h] },
        y = {
            scope: 'number',
            variants: [
                { begin: '\\b0[bB][01]+(?:_[01]+)*\\b' },
                { begin: '\\b0[oO][0-7]+(?:_[0-7]+)*\\b' },
                { begin: '\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b' },
                { begin: '(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?' },
            ],
            relevance: 0,
        },
        v = ['false', 'null', 'true'],
        x = [
            '__CLASS__',
            '__DIR__',
            '__FILE__',
            '__FUNCTION__',
            '__COMPILER_HALT_OFFSET__',
            '__LINE__',
            '__METHOD__',
            '__NAMESPACE__',
            '__TRAIT__',
            'die',
            'echo',
            'exit',
            'include',
            'include_once',
            'print',
            'require',
            'require_once',
            'array',
            'abstract',
            'and',
            'as',
            'binary',
            'bool',
            'boolean',
            'break',
            'callable',
            'case',
            'catch',
            'class',
            'clone',
            'const',
            'continue',
            'declare',
            'default',
            'do',
            'double',
            'else',
            'elseif',
            'empty',
            'enddeclare',
            'endfor',
            'endforeach',
            'endif',
            'endswitch',
            'endwhile',
            'enum',
            'eval',
            'extends',
            'final',
            'finally',
            'float',
            'for',
            'foreach',
            'from',
            'global',
            'goto',
            'if',
            'implements',
            'instanceof',
            'insteadof',
            'int',
            'integer',
            'interface',
            'isset',
            'iterable',
            'list',
            'match|0',
            'mixed',
            'new',
            'never',
            'object',
            'or',
            'private',
            'protected',
            'public',
            'readonly',
            'real',
            'return',
            'string',
            'switch',
            'throw',
            'trait',
            'try',
            'unset',
            'use',
            'var',
            'void',
            'while',
            'xor',
            'yield',
        ],
        T = [
            'Error|0',
            'AppendIterator',
            'ArgumentCountError',
            'ArithmeticError',
            'ArrayIterator',
            'ArrayObject',
            'AssertionError',
            'BadFunctionCallException',
            'BadMethodCallException',
            'CachingIterator',
            'CallbackFilterIterator',
            'CompileError',
            'Countable',
            'DirectoryIterator',
            'DivisionByZeroError',
            'DomainException',
            'EmptyIterator',
            'ErrorException',
            'Exception',
            'FilesystemIterator',
            'FilterIterator',
            'GlobIterator',
            'InfiniteIterator',
            'InvalidArgumentException',
            'IteratorIterator',
            'LengthException',
            'LimitIterator',
            'LogicException',
            'MultipleIterator',
            'NoRewindIterator',
            'OutOfBoundsException',
            'OutOfRangeException',
            'OuterIterator',
            'OverflowException',
            'ParentIterator',
            'ParseError',
            'RangeException',
            'RecursiveArrayIterator',
            'RecursiveCachingIterator',
            'RecursiveCallbackFilterIterator',
            'RecursiveDirectoryIterator',
            'RecursiveFilterIterator',
            'RecursiveIterator',
            'RecursiveIteratorIterator',
            'RecursiveRegexIterator',
            'RecursiveTreeIterator',
            'RegexIterator',
            'RuntimeException',
            'SeekableIterator',
            'SplDoublyLinkedList',
            'SplFileInfo',
            'SplFileObject',
            'SplFixedArray',
            'SplHeap',
            'SplMaxHeap',
            'SplMinHeap',
            'SplObjectStorage',
            'SplObserver',
            'SplPriorityQueue',
            'SplQueue',
            'SplStack',
            'SplSubject',
            'SplTempFileObject',
            'TypeError',
            'UnderflowException',
            'UnexpectedValueException',
            'UnhandledMatchError',
            'ArrayAccess',
            'BackedEnum',
            'Closure',
            'Fiber',
            'Generator',
            'Iterator',
            'IteratorAggregate',
            'Serializable',
            'Stringable',
            'Throwable',
            'Traversable',
            'UnitEnum',
            'WeakReference',
            'WeakMap',
            'Directory',
            '__PHP_Incomplete_Class',
            'parent',
            'php_user_filter',
            'self',
            'static',
            'stdClass',
        ],
        I = {
            keyword: x,
            literal: ((ge) => {
                let Me = [];
                return (
                    ge.forEach((Ee) => {
                        Me.push(Ee), Ee.toLowerCase() === Ee ? Me.push(Ee.toUpperCase()) : Me.push(Ee.toLowerCase());
                    }),
                    Me
                );
            })(v),
            built_in: T,
        },
        S = (ge) => ge.map((Me) => Me.replace(/\|\d+$/, '')),
        z = {
            variants: [
                {
                    match: [/new/, e.concat(m, '+'), e.concat('(?!', S(T).join('\\b|'), '\\b)'), i],
                    scope: { 1: 'keyword', 4: 'title.class' },
                },
            ],
        },
        N = e.concat(r, '\\b(?!\\()'),
        q = {
            variants: [
                { match: [e.concat(/::/, e.lookahead(/(?!class\b)/)), N], scope: { 2: 'variable.constant' } },
                { match: [/::/, /class/], scope: { 2: 'variable.language' } },
                {
                    match: [i, e.concat(/::/, e.lookahead(/(?!class\b)/)), N],
                    scope: { 1: 'title.class', 3: 'variable.constant' },
                },
                { match: [i, e.concat('::', e.lookahead(/(?!class\b)/))], scope: { 1: 'title.class' } },
                { match: [i, /::/, /class/], scope: { 1: 'title.class', 3: 'variable.language' } },
            ],
        },
        ne = { scope: 'attr', match: e.concat(r, e.lookahead(':'), e.lookahead(/(?!::)/)) },
        $ = {
            relevance: 0,
            begin: /\(/,
            end: /\)/,
            keywords: I,
            contains: [ne, o, q, t.C_BLOCK_COMMENT_MODE, b, y, z],
        },
        oe = {
            relevance: 0,
            match: [
                /\b/,
                e.concat('(?!fn\\b|function\\b|', S(x).join('\\b|'), '|', S(T).join('\\b|'), '\\b)'),
                r,
                e.concat(m, '*'),
                e.lookahead(/(?=\()/),
            ],
            scope: { 3: 'title.function.invoke' },
            contains: [$],
        };
    $.contains.push(oe);
    let me = [ne, q, t.C_BLOCK_COMMENT_MODE, b, y, z],
        Te = {
            begin: e.concat(/#\[\s*/, i),
            beginScope: 'meta',
            end: /]/,
            endScope: 'meta',
            keywords: { literal: v, keyword: ['new', 'array'] },
            contains: [
                {
                    begin: /\[/,
                    end: /]/,
                    keywords: { literal: v, keyword: ['new', 'array'] },
                    contains: ['self', ...me],
                },
                ...me,
                { scope: 'meta', match: i },
            ],
        };
    return {
        case_insensitive: !1,
        keywords: I,
        contains: [
            Te,
            t.HASH_COMMENT_MODE,
            t.COMMENT('//', '$'),
            t.COMMENT('/\\*', '\\*/', { contains: [{ scope: 'doctag', match: '@[A-Za-z]+' }] }),
            {
                match: /__halt_compiler\(\);/,
                keywords: '__halt_compiler',
                starts: {
                    scope: 'comment',
                    end: t.MATCH_NOTHING_RE,
                    contains: [{ match: /\?>/, scope: 'meta', endsParent: !0 }],
                },
            },
            s,
            { scope: 'variable.language', match: /\$this\b/ },
            o,
            oe,
            q,
            { match: [/const/, /\s/, r], scope: { 1: 'keyword', 3: 'variable.constant' } },
            z,
            {
                scope: 'function',
                relevance: 0,
                beginKeywords: 'fn function',
                end: /[;{]/,
                excludeEnd: !0,
                illegal: '[$%\\[]',
                contains: [
                    { beginKeywords: 'use' },
                    t.UNDERSCORE_TITLE_MODE,
                    { begin: '=>', endsParent: !0 },
                    {
                        scope: 'params',
                        begin: '\\(',
                        end: '\\)',
                        excludeBegin: !0,
                        excludeEnd: !0,
                        keywords: I,
                        contains: ['self', o, q, t.C_BLOCK_COMMENT_MODE, b, y],
                    },
                ],
            },
            {
                scope: 'class',
                variants: [
                    { beginKeywords: 'enum', illegal: /[($"]/ },
                    { beginKeywords: 'class interface trait', illegal: /[:($"]/ },
                ],
                relevance: 0,
                end: /\{/,
                excludeEnd: !0,
                contains: [{ beginKeywords: 'extends implements' }, t.UNDERSCORE_TITLE_MODE],
            },
            {
                beginKeywords: 'namespace',
                relevance: 0,
                end: ';',
                illegal: /[.']/,
                contains: [t.inherit(t.UNDERSCORE_TITLE_MODE, { scope: 'title.class' })],
            },
            {
                beginKeywords: 'use',
                relevance: 0,
                end: ';',
                contains: [{ match: /\b(as|const|function)\b/, scope: 'keyword' }, t.UNDERSCORE_TITLE_MODE],
            },
            b,
            y,
        ],
    };
}
function a_(t) {
    return {
        name: 'PHP template',
        subLanguage: 'xml',
        contains: [
            {
                begin: /<\?(php|=)?/,
                end: /\?>/,
                subLanguage: 'php',
                contains: [
                    { begin: '/\\*', end: '\\*/', skip: !0 },
                    { begin: 'b"', end: '"', skip: !0 },
                    { begin: "b'", end: "'", skip: !0 },
                    t.inherit(t.APOS_STRING_MODE, { illegal: null, className: null, contains: null, skip: !0 }),
                    t.inherit(t.QUOTE_STRING_MODE, { illegal: null, className: null, contains: null, skip: !0 }),
                ],
            },
        ],
    };
}
function l_(t) {
    return { name: 'Plain text', aliases: ['text', 'txt'], disableAutodetect: !0 };
}
function c_(t) {
    let e = t.regex,
        n = /[\p{XID_Start}_]\p{XID_Continue}*/u,
        r = [
            'and',
            'as',
            'assert',
            'async',
            'await',
            'break',
            'case',
            'class',
            'continue',
            'def',
            'del',
            'elif',
            'else',
            'except',
            'finally',
            'for',
            'from',
            'global',
            'if',
            'import',
            'in',
            'is',
            'lambda',
            'match',
            'nonlocal|10',
            'not',
            'or',
            'pass',
            'raise',
            'return',
            'try',
            'while',
            'with',
            'yield',
        ],
        l = {
            $pattern: /[A-Za-z]\w+|__\w+__/,
            keyword: r,
            built_in: [
                '__import__',
                'abs',
                'all',
                'any',
                'ascii',
                'bin',
                'bool',
                'breakpoint',
                'bytearray',
                'bytes',
                'callable',
                'chr',
                'classmethod',
                'compile',
                'complex',
                'delattr',
                'dict',
                'dir',
                'divmod',
                'enumerate',
                'eval',
                'exec',
                'filter',
                'float',
                'format',
                'frozenset',
                'getattr',
                'globals',
                'hasattr',
                'hash',
                'help',
                'hex',
                'id',
                'input',
                'int',
                'isinstance',
                'issubclass',
                'iter',
                'len',
                'list',
                'locals',
                'map',
                'max',
                'memoryview',
                'min',
                'next',
                'object',
                'oct',
                'open',
                'ord',
                'pow',
                'print',
                'property',
                'range',
                'repr',
                'reversed',
                'round',
                'set',
                'setattr',
                'slice',
                'sorted',
                'staticmethod',
                'str',
                'sum',
                'super',
                'tuple',
                'type',
                'vars',
                'zip',
            ],
            literal: ['__debug__', 'Ellipsis', 'False', 'None', 'NotImplemented', 'True'],
            type: [
                'Any',
                'Callable',
                'Coroutine',
                'Dict',
                'List',
                'Literal',
                'Generic',
                'Optional',
                'Sequence',
                'Set',
                'Tuple',
                'Type',
                'Union',
            ],
        },
        u = { className: 'meta', begin: /^(>>>|\.\.\.) / },
        d = { className: 'subst', begin: /\{/, end: /\}/, keywords: l, illegal: /#/ },
        f = { begin: /\{\{/, relevance: 0 },
        h = {
            className: 'string',
            contains: [t.BACKSLASH_ESCAPE],
            variants: [
                {
                    begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
                    end: /'''/,
                    contains: [t.BACKSLASH_ESCAPE, u],
                    relevance: 10,
                },
                {
                    begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
                    end: /"""/,
                    contains: [t.BACKSLASH_ESCAPE, u],
                    relevance: 10,
                },
                { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [t.BACKSLASH_ESCAPE, u, f, d] },
                { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [t.BACKSLASH_ESCAPE, u, f, d] },
                { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
                { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
                { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
                { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
                { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [t.BACKSLASH_ESCAPE, f, d] },
                { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [t.BACKSLASH_ESCAPE, f, d] },
                t.APOS_STRING_MODE,
                t.QUOTE_STRING_MODE,
            ],
        },
        m = '[0-9](_?[0-9])*',
        b = `(\\b(${m}))?\\.(${m})|\\b(${m})\\.`,
        y = `\\b|${r.join('|')}`,
        v = {
            className: 'number',
            relevance: 0,
            variants: [
                { begin: `(\\b(${m})|(${b}))[eE][+-]?(${m})[jJ]?(?=${y})` },
                { begin: `(${b})[jJ]?` },
                { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${y})` },
                { begin: `\\b0[bB](_?[01])+[lL]?(?=${y})` },
                { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${y})` },
                { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${y})` },
                { begin: `\\b(${m})[jJ](?=${y})` },
            ],
        },
        x = {
            className: 'comment',
            begin: e.lookahead(/# type:/),
            end: /$/,
            keywords: l,
            contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }],
        },
        T = {
            className: 'params',
            variants: [
                { className: '', begin: /\(\s*\)/, skip: !0 },
                {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: l,
                    contains: ['self', u, v, h, t.HASH_COMMENT_MODE],
                },
            ],
        };
    return (
        (d.contains = [h, v, u]),
        {
            name: 'Python',
            aliases: ['py', 'gyp', 'ipython'],
            unicodeRegex: !0,
            keywords: l,
            illegal: /(<\/|\?)|=>/,
            contains: [
                u,
                v,
                { begin: /\bself\b/ },
                { beginKeywords: 'if', relevance: 0 },
                h,
                x,
                t.HASH_COMMENT_MODE,
                { match: [/\bdef/, /\s+/, n], scope: { 1: 'keyword', 3: 'title.function' }, contains: [T] },
                {
                    variants: [
                        { match: [/\bclass/, /\s+/, n, /\s*/, /\(\s*/, n, /\s*\)/] },
                        { match: [/\bclass/, /\s+/, n] },
                    ],
                    scope: { 1: 'keyword', 3: 'title.class', 6: 'title.class.inherited' },
                },
                { className: 'meta', begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [v, T, h] },
            ],
        }
    );
}
function u_(t) {
    return {
        aliases: ['pycon'],
        contains: [
            {
                className: 'meta.prompt',
                starts: { end: / |$/, starts: { end: '$', subLanguage: 'python' } },
                variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }],
            },
        ],
    };
}
function d_(t) {
    let e = t.regex,
        n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,
        r = e.either(
            /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
            /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
            /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/,
        ),
        i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,
        o = e.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
    return {
        name: 'R',
        keywords: {
            $pattern: n,
            keyword: 'function if in break next repeat else for while',
            literal: 'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10',
            built_in:
                'LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm',
        },
        contains: [
            t.COMMENT(/#'/, /$/, {
                contains: [
                    {
                        scope: 'doctag',
                        match: /@examples/,
                        starts: { end: e.lookahead(e.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)), endsParent: !0 },
                    },
                    {
                        scope: 'doctag',
                        begin: '@param',
                        end: /$/,
                        contains: [
                            {
                                scope: 'variable',
                                variants: [{ match: n }, { match: /`(?:\\.|[^`\\])+`/ }],
                                endsParent: !0,
                            },
                        ],
                    },
                    { scope: 'doctag', match: /@[a-zA-Z]+/ },
                    { scope: 'keyword', match: /\\[a-zA-Z]+/ },
                ],
            }),
            t.HASH_COMMENT_MODE,
            {
                scope: 'string',
                contains: [t.BACKSLASH_ESCAPE],
                variants: [
                    t.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
                    t.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
                    t.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
                    t.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
                    t.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
                    t.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
                    { begin: '"', end: '"', relevance: 0 },
                    { begin: "'", end: "'", relevance: 0 },
                ],
            },
            {
                relevance: 0,
                variants: [
                    { scope: { 1: 'operator', 2: 'number' }, match: [i, r] },
                    { scope: { 1: 'operator', 2: 'number' }, match: [/%[^%]*%/, r] },
                    { scope: { 1: 'punctuation', 2: 'number' }, match: [o, r] },
                    { scope: { 2: 'number' }, match: [/[^a-zA-Z0-9._]|^/, r] },
                ],
            },
            { scope: { 3: 'operator' }, match: [n, /\s+/, /<-/, /\s+/] },
            { scope: 'operator', relevance: 0, variants: [{ match: i }, { match: /%[^%]*%/ }] },
            { scope: 'punctuation', relevance: 0, match: o },
            { begin: '`', end: '`', contains: [{ begin: /\\./ }] },
        ],
    };
}
function f_(t) {
    let e = t.regex,
        n = '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)',
        r = e.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/),
        i = e.concat(r, /(::\w+)*/),
        s = {
            'variable.constant': ['__FILE__', '__LINE__', '__ENCODING__'],
            'variable.language': ['self', 'super'],
            keyword: [
                'alias',
                'and',
                'begin',
                'BEGIN',
                'break',
                'case',
                'class',
                'defined',
                'do',
                'else',
                'elsif',
                'end',
                'END',
                'ensure',
                'for',
                'if',
                'in',
                'module',
                'next',
                'not',
                'or',
                'redo',
                'require',
                'rescue',
                'retry',
                'return',
                'then',
                'undef',
                'unless',
                'until',
                'when',
                'while',
                'yield',
                ...['include', 'extend', 'prepend', 'public', 'private', 'protected', 'raise', 'throw'],
            ],
            built_in: [
                'proc',
                'lambda',
                'attr_accessor',
                'attr_reader',
                'attr_writer',
                'define_method',
                'private_constant',
                'module_function',
            ],
            literal: ['true', 'false', 'nil'],
        },
        l = { className: 'doctag', begin: '@[A-Za-z]+' },
        u = { begin: '#<', end: '>' },
        d = [
            t.COMMENT('#', '$', { contains: [l] }),
            t.COMMENT('^=begin', '^=end', { contains: [l], relevance: 10 }),
            t.COMMENT('^__END__', t.MATCH_NOTHING_RE),
        ],
        f = { className: 'subst', begin: /#\{/, end: /\}/, keywords: s },
        h = {
            className: 'string',
            contains: [t.BACKSLASH_ESCAPE, f],
            variants: [
                { begin: /'/, end: /'/ },
                { begin: /"/, end: /"/ },
                { begin: /`/, end: /`/ },
                { begin: /%[qQwWx]?\(/, end: /\)/ },
                { begin: /%[qQwWx]?\[/, end: /\]/ },
                { begin: /%[qQwWx]?\{/, end: /\}/ },
                { begin: /%[qQwWx]?</, end: />/ },
                { begin: /%[qQwWx]?\//, end: /\// },
                { begin: /%[qQwWx]?%/, end: /%/ },
                { begin: /%[qQwWx]?-/, end: /-/ },
                { begin: /%[qQwWx]?\|/, end: /\|/ },
                { begin: /\B\?(\\\d{1,3})/ },
                { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
                { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
                { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
                { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
                { begin: /\B\?\\?\S/ },
                {
                    begin: e.concat(/<<[-~]?'?/, e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
                    contains: [
                        t.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, contains: [t.BACKSLASH_ESCAPE, f] }),
                    ],
                },
            ],
        },
        m = '[1-9](_?[0-9])*|0',
        b = '[0-9](_?[0-9])*',
        y = {
            className: 'number',
            relevance: 0,
            variants: [
                { begin: `\\b(${m})(\\.(${b}))?([eE][+-]?(${b})|r)?i?\\b` },
                { begin: '\\b0[dD][0-9](_?[0-9])*r?i?\\b' },
                { begin: '\\b0[bB][0-1](_?[0-1])*r?i?\\b' },
                { begin: '\\b0[oO][0-7](_?[0-7])*r?i?\\b' },
                { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b' },
                { begin: '\\b0(_?[0-7])+r?i?\\b' },
            ],
        },
        v = {
            variants: [
                { match: /\(\)/ },
                { className: 'params', begin: /\(/, end: /(?=\))/, excludeBegin: !0, endsParent: !0, keywords: s },
            ],
        },
        N = [
            h,
            {
                variants: [{ match: [/class\s+/, i, /\s+<\s+/, i] }, { match: [/\b(class|module)\s+/, i] }],
                scope: { 2: 'title.class', 4: 'title.class.inherited' },
                keywords: s,
            },
            { match: [/(include|extend)\s+/, i], scope: { 2: 'title.class' }, keywords: s },
            { relevance: 0, match: [i, /\.new[. (]/], scope: { 1: 'title.class' } },
            { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' },
            { relevance: 0, match: r, scope: 'title.class' },
            { match: [/def/, /\s+/, n], scope: { 1: 'keyword', 3: 'title.function' }, contains: [v] },
            { begin: t.IDENT_RE + '::' },
            { className: 'symbol', begin: t.UNDERSCORE_IDENT_RE + '(!|\\?)?:', relevance: 0 },
            { className: 'symbol', begin: ':(?!\\s)', contains: [h, { begin: n }], relevance: 0 },
            y,
            { className: 'variable', begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])" },
            {
                className: 'params',
                begin: /\|/,
                end: /\|/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
                keywords: s,
            },
            {
                begin: '(' + t.RE_STARTERS_RE + '|unless)\\s*',
                keywords: 'unless',
                contains: [
                    {
                        className: 'regexp',
                        contains: [t.BACKSLASH_ESCAPE, f],
                        illegal: /\n/,
                        variants: [
                            { begin: '/', end: '/[a-z]*' },
                            { begin: /%r\{/, end: /\}[a-z]*/ },
                            { begin: '%r\\(', end: '\\)[a-z]*' },
                            { begin: '%r!', end: '![a-z]*' },
                            { begin: '%r\\[', end: '\\][a-z]*' },
                        ],
                    },
                ].concat(u, d),
                relevance: 0,
            },
        ].concat(u, d);
    (f.contains = N), (v.contains = N);
    let oe = [
        { begin: /^\s*=>/, starts: { end: '$', contains: N } },
        {
            className: 'meta.prompt',
            begin:
                '^(' +
                '[>?]>' +
                '|' +
                '[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]' +
                '|' +
                '(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>' +
                ')(?=[ ])',
            starts: { end: '$', keywords: s, contains: N },
        },
    ];
    return (
        d.unshift(u),
        {
            name: 'Ruby',
            aliases: ['rb', 'gemspec', 'podspec', 'thor', 'irb'],
            keywords: s,
            illegal: /\/\*/,
            contains: [t.SHEBANG({ binary: 'ruby' })].concat(oe).concat(d).concat(N),
        }
    );
}
function p_(t) {
    let e = t.regex,
        n = {
            className: 'title.function.invoke',
            relevance: 0,
            begin: e.concat(/\b/, /(?!let\b)/, t.IDENT_RE, e.lookahead(/\s*\(/)),
        },
        r = '([ui](8|16|32|64|128|size)|f(32|64))?',
        i = [
            'abstract',
            'as',
            'async',
            'await',
            'become',
            'box',
            'break',
            'const',
            'continue',
            'crate',
            'do',
            'dyn',
            'else',
            'enum',
            'extern',
            'false',
            'final',
            'fn',
            'for',
            'if',
            'impl',
            'in',
            'let',
            'loop',
            'macro',
            'match',
            'mod',
            'move',
            'mut',
            'override',
            'priv',
            'pub',
            'ref',
            'return',
            'self',
            'Self',
            'static',
            'struct',
            'super',
            'trait',
            'true',
            'try',
            'type',
            'typeof',
            'unsafe',
            'unsized',
            'use',
            'virtual',
            'where',
            'while',
            'yield',
        ],
        o = ['true', 'false', 'Some', 'None', 'Ok', 'Err'],
        s = [
            'drop ',
            'Copy',
            'Send',
            'Sized',
            'Sync',
            'Drop',
            'Fn',
            'FnMut',
            'FnOnce',
            'ToOwned',
            'Clone',
            'Debug',
            'PartialEq',
            'PartialOrd',
            'Eq',
            'Ord',
            'AsRef',
            'AsMut',
            'Into',
            'From',
            'Default',
            'Iterator',
            'Extend',
            'IntoIterator',
            'DoubleEndedIterator',
            'ExactSizeIterator',
            'SliceConcatExt',
            'ToString',
            'assert!',
            'assert_eq!',
            'bitflags!',
            'bytes!',
            'cfg!',
            'col!',
            'concat!',
            'concat_idents!',
            'debug_assert!',
            'debug_assert_eq!',
            'env!',
            'panic!',
            'file!',
            'format!',
            'format_args!',
            'include_bytes!',
            'include_str!',
            'line!',
            'local_data_key!',
            'module_path!',
            'option_env!',
            'print!',
            'println!',
            'select!',
            'stringify!',
            'try!',
            'unimplemented!',
            'unreachable!',
            'vec!',
            'write!',
            'writeln!',
            'macro_rules!',
            'assert_ne!',
            'debug_assert_ne!',
        ],
        l = [
            'i8',
            'i16',
            'i32',
            'i64',
            'i128',
            'isize',
            'u8',
            'u16',
            'u32',
            'u64',
            'u128',
            'usize',
            'f32',
            'f64',
            'str',
            'char',
            'bool',
            'Box',
            'Option',
            'Result',
            'String',
            'Vec',
        ];
    return {
        name: 'Rust',
        aliases: ['rs'],
        keywords: { $pattern: t.IDENT_RE + '!?', type: l, keyword: i, literal: o, built_in: s },
        illegal: '</',
        contains: [
            t.C_LINE_COMMENT_MODE,
            t.COMMENT('/\\*', '\\*/', { contains: ['self'] }),
            t.inherit(t.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
            {
                className: 'string',
                variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }],
            },
            { className: 'symbol', begin: /'[a-zA-Z_][a-zA-Z0-9_]*/ },
            {
                className: 'number',
                variants: [
                    { begin: '\\b0b([01_]+)' + r },
                    { begin: '\\b0o([0-7_]+)' + r },
                    { begin: '\\b0x([A-Fa-f0-9_]+)' + r },
                    { begin: '\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)' + r },
                ],
                relevance: 0,
            },
            { begin: [/fn/, /\s+/, t.UNDERSCORE_IDENT_RE], className: { 1: 'keyword', 3: 'title.function' } },
            {
                className: 'meta',
                begin: '#!?\\[',
                end: '\\]',
                contains: [{ className: 'string', begin: /"/, end: /"/ }],
            },
            {
                begin: [/let/, /\s+/, /(?:mut\s+)?/, t.UNDERSCORE_IDENT_RE],
                className: { 1: 'keyword', 3: 'keyword', 4: 'variable' },
            },
            {
                begin: [/for/, /\s+/, t.UNDERSCORE_IDENT_RE, /\s+/, /in/],
                className: { 1: 'keyword', 3: 'variable', 5: 'keyword' },
            },
            { begin: [/type/, /\s+/, t.UNDERSCORE_IDENT_RE], className: { 1: 'keyword', 3: 'title.class' } },
            {
                begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, t.UNDERSCORE_IDENT_RE],
                className: { 1: 'keyword', 3: 'title.class' },
            },
            { begin: t.IDENT_RE + '::', keywords: { keyword: 'Self', built_in: s, type: l } },
            { className: 'punctuation', begin: '->' },
            n,
        ],
    };
}
var _F = (t) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
            scope: 'selector-attr',
            begin: /\[/,
            end: /\]/,
            illegal: '$',
            contains: [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
            scope: 'number',
            begin:
                t.NUMBER_RE +
                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
            relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z][A-Za-z0-9_-]*/ },
    }),
    SF = [
        'a',
        'abbr',
        'address',
        'article',
        'aside',
        'audio',
        'b',
        'blockquote',
        'body',
        'button',
        'canvas',
        'caption',
        'cite',
        'code',
        'dd',
        'del',
        'details',
        'dfn',
        'div',
        'dl',
        'dt',
        'em',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'header',
        'hgroup',
        'html',
        'i',
        'iframe',
        'img',
        'input',
        'ins',
        'kbd',
        'label',
        'legend',
        'li',
        'main',
        'mark',
        'menu',
        'nav',
        'object',
        'ol',
        'p',
        'q',
        'quote',
        'samp',
        'section',
        'span',
        'strong',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'tr',
        'ul',
        'var',
        'video',
    ],
    TF = [
        'any-hover',
        'any-pointer',
        'aspect-ratio',
        'color',
        'color-gamut',
        'color-index',
        'device-aspect-ratio',
        'device-height',
        'device-width',
        'display-mode',
        'forced-colors',
        'grid',
        'height',
        'hover',
        'inverted-colors',
        'monochrome',
        'orientation',
        'overflow-block',
        'overflow-inline',
        'pointer',
        'prefers-color-scheme',
        'prefers-contrast',
        'prefers-reduced-motion',
        'prefers-reduced-transparency',
        'resolution',
        'scan',
        'scripting',
        'update',
        'width',
        'min-width',
        'max-width',
        'min-height',
        'max-height',
    ],
    MF = [
        'active',
        'any-link',
        'blank',
        'checked',
        'current',
        'default',
        'defined',
        'dir',
        'disabled',
        'drop',
        'empty',
        'enabled',
        'first',
        'first-child',
        'first-of-type',
        'fullscreen',
        'future',
        'focus',
        'focus-visible',
        'focus-within',
        'has',
        'host',
        'host-context',
        'hover',
        'indeterminate',
        'in-range',
        'invalid',
        'is',
        'lang',
        'last-child',
        'last-of-type',
        'left',
        'link',
        'local-link',
        'not',
        'nth-child',
        'nth-col',
        'nth-last-child',
        'nth-last-col',
        'nth-last-of-type',
        'nth-of-type',
        'only-child',
        'only-of-type',
        'optional',
        'out-of-range',
        'past',
        'placeholder-shown',
        'read-only',
        'read-write',
        'required',
        'right',
        'root',
        'scope',
        'target',
        'target-within',
        'user-invalid',
        'valid',
        'visited',
        'where',
    ],
    AF = [
        'after',
        'backdrop',
        'before',
        'cue',
        'cue-region',
        'first-letter',
        'first-line',
        'grammar-error',
        'marker',
        'part',
        'placeholder',
        'selection',
        'slotted',
        'spelling-error',
    ],
    CF = [
        'align-content',
        'align-items',
        'align-self',
        'all',
        'animation',
        'animation-delay',
        'animation-direction',
        'animation-duration',
        'animation-fill-mode',
        'animation-iteration-count',
        'animation-name',
        'animation-play-state',
        'animation-timing-function',
        'backface-visibility',
        'background',
        'background-attachment',
        'background-blend-mode',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'block-size',
        'border',
        'border-block',
        'border-block-color',
        'border-block-end',
        'border-block-end-color',
        'border-block-end-style',
        'border-block-end-width',
        'border-block-start',
        'border-block-start-color',
        'border-block-start-style',
        'border-block-start-width',
        'border-block-style',
        'border-block-width',
        'border-bottom',
        'border-bottom-color',
        'border-bottom-left-radius',
        'border-bottom-right-radius',
        'border-bottom-style',
        'border-bottom-width',
        'border-collapse',
        'border-color',
        'border-image',
        'border-image-outset',
        'border-image-repeat',
        'border-image-slice',
        'border-image-source',
        'border-image-width',
        'border-inline',
        'border-inline-color',
        'border-inline-end',
        'border-inline-end-color',
        'border-inline-end-style',
        'border-inline-end-width',
        'border-inline-start',
        'border-inline-start-color',
        'border-inline-start-style',
        'border-inline-start-width',
        'border-inline-style',
        'border-inline-width',
        'border-left',
        'border-left-color',
        'border-left-style',
        'border-left-width',
        'border-radius',
        'border-right',
        'border-right-color',
        'border-right-style',
        'border-right-width',
        'border-spacing',
        'border-style',
        'border-top',
        'border-top-color',
        'border-top-left-radius',
        'border-top-right-radius',
        'border-top-style',
        'border-top-width',
        'border-width',
        'bottom',
        'box-decoration-break',
        'box-shadow',
        'box-sizing',
        'break-after',
        'break-before',
        'break-inside',
        'caption-side',
        'caret-color',
        'clear',
        'clip',
        'clip-path',
        'clip-rule',
        'color',
        'column-count',
        'column-fill',
        'column-gap',
        'column-rule',
        'column-rule-color',
        'column-rule-style',
        'column-rule-width',
        'column-span',
        'column-width',
        'columns',
        'contain',
        'content',
        'content-visibility',
        'counter-increment',
        'counter-reset',
        'cue',
        'cue-after',
        'cue-before',
        'cursor',
        'direction',
        'display',
        'empty-cells',
        'filter',
        'flex',
        'flex-basis',
        'flex-direction',
        'flex-flow',
        'flex-grow',
        'flex-shrink',
        'flex-wrap',
        'float',
        'flow',
        'font',
        'font-display',
        'font-family',
        'font-feature-settings',
        'font-kerning',
        'font-language-override',
        'font-size',
        'font-size-adjust',
        'font-smoothing',
        'font-stretch',
        'font-style',
        'font-synthesis',
        'font-variant',
        'font-variant-caps',
        'font-variant-east-asian',
        'font-variant-ligatures',
        'font-variant-numeric',
        'font-variant-position',
        'font-variation-settings',
        'font-weight',
        'gap',
        'glyph-orientation-vertical',
        'grid',
        'grid-area',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-auto-rows',
        'grid-column',
        'grid-column-end',
        'grid-column-start',
        'grid-gap',
        'grid-row',
        'grid-row-end',
        'grid-row-start',
        'grid-template',
        'grid-template-areas',
        'grid-template-columns',
        'grid-template-rows',
        'hanging-punctuation',
        'height',
        'hyphens',
        'icon',
        'image-orientation',
        'image-rendering',
        'image-resolution',
        'ime-mode',
        'inline-size',
        'isolation',
        'justify-content',
        'left',
        'letter-spacing',
        'line-break',
        'line-height',
        'list-style',
        'list-style-image',
        'list-style-position',
        'list-style-type',
        'margin',
        'margin-block',
        'margin-block-end',
        'margin-block-start',
        'margin-bottom',
        'margin-inline',
        'margin-inline-end',
        'margin-inline-start',
        'margin-left',
        'margin-right',
        'margin-top',
        'marks',
        'mask',
        'mask-border',
        'mask-border-mode',
        'mask-border-outset',
        'mask-border-repeat',
        'mask-border-slice',
        'mask-border-source',
        'mask-border-width',
        'mask-clip',
        'mask-composite',
        'mask-image',
        'mask-mode',
        'mask-origin',
        'mask-position',
        'mask-repeat',
        'mask-size',
        'mask-type',
        'max-block-size',
        'max-height',
        'max-inline-size',
        'max-width',
        'min-block-size',
        'min-height',
        'min-inline-size',
        'min-width',
        'mix-blend-mode',
        'nav-down',
        'nav-index',
        'nav-left',
        'nav-right',
        'nav-up',
        'none',
        'normal',
        'object-fit',
        'object-position',
        'opacity',
        'order',
        'orphans',
        'outline',
        'outline-color',
        'outline-offset',
        'outline-style',
        'outline-width',
        'overflow',
        'overflow-wrap',
        'overflow-x',
        'overflow-y',
        'padding',
        'padding-block',
        'padding-block-end',
        'padding-block-start',
        'padding-bottom',
        'padding-inline',
        'padding-inline-end',
        'padding-inline-start',
        'padding-left',
        'padding-right',
        'padding-top',
        'page-break-after',
        'page-break-before',
        'page-break-inside',
        'pause',
        'pause-after',
        'pause-before',
        'perspective',
        'perspective-origin',
        'pointer-events',
        'position',
        'quotes',
        'resize',
        'rest',
        'rest-after',
        'rest-before',
        'right',
        'row-gap',
        'scroll-margin',
        'scroll-margin-block',
        'scroll-margin-block-end',
        'scroll-margin-block-start',
        'scroll-margin-bottom',
        'scroll-margin-inline',
        'scroll-margin-inline-end',
        'scroll-margin-inline-start',
        'scroll-margin-left',
        'scroll-margin-right',
        'scroll-margin-top',
        'scroll-padding',
        'scroll-padding-block',
        'scroll-padding-block-end',
        'scroll-padding-block-start',
        'scroll-padding-bottom',
        'scroll-padding-inline',
        'scroll-padding-inline-end',
        'scroll-padding-inline-start',
        'scroll-padding-left',
        'scroll-padding-right',
        'scroll-padding-top',
        'scroll-snap-align',
        'scroll-snap-stop',
        'scroll-snap-type',
        'scrollbar-color',
        'scrollbar-gutter',
        'scrollbar-width',
        'shape-image-threshold',
        'shape-margin',
        'shape-outside',
        'speak',
        'speak-as',
        'src',
        'tab-size',
        'table-layout',
        'text-align',
        'text-align-all',
        'text-align-last',
        'text-combine-upright',
        'text-decoration',
        'text-decoration-color',
        'text-decoration-line',
        'text-decoration-style',
        'text-emphasis',
        'text-emphasis-color',
        'text-emphasis-position',
        'text-emphasis-style',
        'text-indent',
        'text-justify',
        'text-orientation',
        'text-overflow',
        'text-rendering',
        'text-shadow',
        'text-transform',
        'text-underline-position',
        'top',
        'transform',
        'transform-box',
        'transform-origin',
        'transform-style',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function',
        'unicode-bidi',
        'vertical-align',
        'visibility',
        'voice-balance',
        'voice-duration',
        'voice-family',
        'voice-pitch',
        'voice-range',
        'voice-rate',
        'voice-stress',
        'voice-volume',
        'white-space',
        'widows',
        'width',
        'will-change',
        'word-break',
        'word-spacing',
        'word-wrap',
        'writing-mode',
        'z-index',
    ].reverse();
function h_(t) {
    let e = _F(t),
        n = AF,
        r = MF,
        i = '@[a-z-]+',
        o = 'and or not only',
        l = { className: 'variable', begin: '(\\$' + '[a-zA-Z-][a-zA-Z0-9_-]*' + ')\\b', relevance: 0 };
    return {
        name: 'SCSS',
        case_insensitive: !0,
        illegal: "[=/|']",
        contains: [
            t.C_LINE_COMMENT_MODE,
            t.C_BLOCK_COMMENT_MODE,
            e.CSS_NUMBER_MODE,
            { className: 'selector-id', begin: '#[A-Za-z0-9_-]+', relevance: 0 },
            { className: 'selector-class', begin: '\\.[A-Za-z0-9_-]+', relevance: 0 },
            e.ATTRIBUTE_SELECTOR_MODE,
            { className: 'selector-tag', begin: '\\b(' + SF.join('|') + ')\\b', relevance: 0 },
            { className: 'selector-pseudo', begin: ':(' + r.join('|') + ')' },
            { className: 'selector-pseudo', begin: ':(:)?(' + n.join('|') + ')' },
            l,
            { begin: /\(/, end: /\)/, contains: [e.CSS_NUMBER_MODE] },
            e.CSS_VARIABLE,
            { className: 'attribute', begin: '\\b(' + CF.join('|') + ')\\b' },
            {
                begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b',
            },
            {
                begin: /:/,
                end: /[;}{]/,
                relevance: 0,
                contains: [
                    e.BLOCK_COMMENT,
                    l,
                    e.HEXCOLOR,
                    e.CSS_NUMBER_MODE,
                    t.QUOTE_STRING_MODE,
                    t.APOS_STRING_MODE,
                    e.IMPORTANT,
                    e.FUNCTION_DISPATCH,
                ],
            },
            { begin: '@(page|font-face)', keywords: { $pattern: i, keyword: '@page @font-face' } },
            {
                begin: '@',
                end: '[{;]',
                returnBegin: !0,
                keywords: { $pattern: /[a-z-]+/, keyword: o, attribute: TF.join(' ') },
                contains: [
                    { begin: i, className: 'keyword' },
                    { begin: /[a-z-]+(?=:)/, className: 'attribute' },
                    l,
                    t.QUOTE_STRING_MODE,
                    t.APOS_STRING_MODE,
                    e.HEXCOLOR,
                    e.CSS_NUMBER_MODE,
                ],
            },
            e.FUNCTION_DISPATCH,
        ],
    };
}
function m_(t) {
    return {
        name: 'Shell Session',
        aliases: ['console', 'shellsession'],
        contains: [
            {
                className: 'meta.prompt',
                begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
                starts: { end: /[^\\](?=\s*$)/, subLanguage: 'bash' },
            },
        ],
    };
}
function g_(t) {
    let e = t.regex,
        n = t.COMMENT('--', '$'),
        r = { className: 'string', variants: [{ begin: /'/, end: /'/, contains: [{ begin: /''/ }] }] },
        i = { begin: /"/, end: /"/, contains: [{ begin: /""/ }] },
        o = ['true', 'false', 'unknown'],
        s = ['double precision', 'large object', 'with timezone', 'without timezone'],
        l = [
            'bigint',
            'binary',
            'blob',
            'boolean',
            'char',
            'character',
            'clob',
            'date',
            'dec',
            'decfloat',
            'decimal',
            'float',
            'int',
            'integer',
            'interval',
            'nchar',
            'nclob',
            'national',
            'numeric',
            'real',
            'row',
            'smallint',
            'time',
            'timestamp',
            'varchar',
            'varying',
            'varbinary',
        ],
        u = ['add', 'asc', 'collation', 'desc', 'final', 'first', 'last', 'view'],
        d = [
            'abs',
            'acos',
            'all',
            'allocate',
            'alter',
            'and',
            'any',
            'are',
            'array',
            'array_agg',
            'array_max_cardinality',
            'as',
            'asensitive',
            'asin',
            'asymmetric',
            'at',
            'atan',
            'atomic',
            'authorization',
            'avg',
            'begin',
            'begin_frame',
            'begin_partition',
            'between',
            'bigint',
            'binary',
            'blob',
            'boolean',
            'both',
            'by',
            'call',
            'called',
            'cardinality',
            'cascaded',
            'case',
            'cast',
            'ceil',
            'ceiling',
            'char',
            'char_length',
            'character',
            'character_length',
            'check',
            'classifier',
            'clob',
            'close',
            'coalesce',
            'collate',
            'collect',
            'column',
            'commit',
            'condition',
            'connect',
            'constraint',
            'contains',
            'convert',
            'copy',
            'corr',
            'corresponding',
            'cos',
            'cosh',
            'count',
            'covar_pop',
            'covar_samp',
            'create',
            'cross',
            'cube',
            'cume_dist',
            'current',
            'current_catalog',
            'current_date',
            'current_default_transform_group',
            'current_path',
            'current_role',
            'current_row',
            'current_schema',
            'current_time',
            'current_timestamp',
            'current_path',
            'current_role',
            'current_transform_group_for_type',
            'current_user',
            'cursor',
            'cycle',
            'date',
            'day',
            'deallocate',
            'dec',
            'decimal',
            'decfloat',
            'declare',
            'default',
            'define',
            'delete',
            'dense_rank',
            'deref',
            'describe',
            'deterministic',
            'disconnect',
            'distinct',
            'double',
            'drop',
            'dynamic',
            'each',
            'element',
            'else',
            'empty',
            'end',
            'end_frame',
            'end_partition',
            'end-exec',
            'equals',
            'escape',
            'every',
            'except',
            'exec',
            'execute',
            'exists',
            'exp',
            'external',
            'extract',
            'false',
            'fetch',
            'filter',
            'first_value',
            'float',
            'floor',
            'for',
            'foreign',
            'frame_row',
            'free',
            'from',
            'full',
            'function',
            'fusion',
            'get',
            'global',
            'grant',
            'group',
            'grouping',
            'groups',
            'having',
            'hold',
            'hour',
            'identity',
            'in',
            'indicator',
            'initial',
            'inner',
            'inout',
            'insensitive',
            'insert',
            'int',
            'integer',
            'intersect',
            'intersection',
            'interval',
            'into',
            'is',
            'join',
            'json_array',
            'json_arrayagg',
            'json_exists',
            'json_object',
            'json_objectagg',
            'json_query',
            'json_table',
            'json_table_primitive',
            'json_value',
            'lag',
            'language',
            'large',
            'last_value',
            'lateral',
            'lead',
            'leading',
            'left',
            'like',
            'like_regex',
            'listagg',
            'ln',
            'local',
            'localtime',
            'localtimestamp',
            'log',
            'log10',
            'lower',
            'match',
            'match_number',
            'match_recognize',
            'matches',
            'max',
            'member',
            'merge',
            'method',
            'min',
            'minute',
            'mod',
            'modifies',
            'module',
            'month',
            'multiset',
            'national',
            'natural',
            'nchar',
            'nclob',
            'new',
            'no',
            'none',
            'normalize',
            'not',
            'nth_value',
            'ntile',
            'null',
            'nullif',
            'numeric',
            'octet_length',
            'occurrences_regex',
            'of',
            'offset',
            'old',
            'omit',
            'on',
            'one',
            'only',
            'open',
            'or',
            'order',
            'out',
            'outer',
            'over',
            'overlaps',
            'overlay',
            'parameter',
            'partition',
            'pattern',
            'per',
            'percent',
            'percent_rank',
            'percentile_cont',
            'percentile_disc',
            'period',
            'portion',
            'position',
            'position_regex',
            'power',
            'precedes',
            'precision',
            'prepare',
            'primary',
            'procedure',
            'ptf',
            'range',
            'rank',
            'reads',
            'real',
            'recursive',
            'ref',
            'references',
            'referencing',
            'regr_avgx',
            'regr_avgy',
            'regr_count',
            'regr_intercept',
            'regr_r2',
            'regr_slope',
            'regr_sxx',
            'regr_sxy',
            'regr_syy',
            'release',
            'result',
            'return',
            'returns',
            'revoke',
            'right',
            'rollback',
            'rollup',
            'row',
            'row_number',
            'rows',
            'running',
            'savepoint',
            'scope',
            'scroll',
            'search',
            'second',
            'seek',
            'select',
            'sensitive',
            'session_user',
            'set',
            'show',
            'similar',
            'sin',
            'sinh',
            'skip',
            'smallint',
            'some',
            'specific',
            'specifictype',
            'sql',
            'sqlexception',
            'sqlstate',
            'sqlwarning',
            'sqrt',
            'start',
            'static',
            'stddev_pop',
            'stddev_samp',
            'submultiset',
            'subset',
            'substring',
            'substring_regex',
            'succeeds',
            'sum',
            'symmetric',
            'system',
            'system_time',
            'system_user',
            'table',
            'tablesample',
            'tan',
            'tanh',
            'then',
            'time',
            'timestamp',
            'timezone_hour',
            'timezone_minute',
            'to',
            'trailing',
            'translate',
            'translate_regex',
            'translation',
            'treat',
            'trigger',
            'trim',
            'trim_array',
            'true',
            'truncate',
            'uescape',
            'union',
            'unique',
            'unknown',
            'unnest',
            'update',
            'upper',
            'user',
            'using',
            'value',
            'values',
            'value_of',
            'var_pop',
            'var_samp',
            'varbinary',
            'varchar',
            'varying',
            'versioning',
            'when',
            'whenever',
            'where',
            'width_bucket',
            'window',
            'with',
            'within',
            'without',
            'year',
        ],
        f = [
            'abs',
            'acos',
            'array_agg',
            'asin',
            'atan',
            'avg',
            'cast',
            'ceil',
            'ceiling',
            'coalesce',
            'corr',
            'cos',
            'cosh',
            'count',
            'covar_pop',
            'covar_samp',
            'cume_dist',
            'dense_rank',
            'deref',
            'element',
            'exp',
            'extract',
            'first_value',
            'floor',
            'json_array',
            'json_arrayagg',
            'json_exists',
            'json_object',
            'json_objectagg',
            'json_query',
            'json_table',
            'json_table_primitive',
            'json_value',
            'lag',
            'last_value',
            'lead',
            'listagg',
            'ln',
            'log',
            'log10',
            'lower',
            'max',
            'min',
            'mod',
            'nth_value',
            'ntile',
            'nullif',
            'percent_rank',
            'percentile_cont',
            'percentile_disc',
            'position',
            'position_regex',
            'power',
            'rank',
            'regr_avgx',
            'regr_avgy',
            'regr_count',
            'regr_intercept',
            'regr_r2',
            'regr_slope',
            'regr_sxx',
            'regr_sxy',
            'regr_syy',
            'row_number',
            'sin',
            'sinh',
            'sqrt',
            'stddev_pop',
            'stddev_samp',
            'substring',
            'substring_regex',
            'sum',
            'tan',
            'tanh',
            'translate',
            'translate_regex',
            'treat',
            'trim',
            'trim_array',
            'unnest',
            'upper',
            'value_of',
            'var_pop',
            'var_samp',
            'width_bucket',
        ],
        h = [
            'current_catalog',
            'current_date',
            'current_default_transform_group',
            'current_path',
            'current_role',
            'current_schema',
            'current_transform_group_for_type',
            'current_user',
            'session_user',
            'system_time',
            'system_user',
            'current_time',
            'localtime',
            'current_timestamp',
            'localtimestamp',
        ],
        m = [
            'create table',
            'insert into',
            'primary key',
            'foreign key',
            'not null',
            'alter table',
            'add constraint',
            'grouping sets',
            'on overflow',
            'character set',
            'respect nulls',
            'ignore nulls',
            'nulls first',
            'nulls last',
            'depth first',
            'breadth first',
        ],
        b = f,
        y = [...d, ...u].filter((I) => !f.includes(I)),
        v = { className: 'variable', begin: /@[a-z0-9][a-z0-9_]*/ },
        x = { className: 'operator', begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/, relevance: 0 },
        T = { begin: e.concat(/\b/, e.either(...b), /\s*\(/), relevance: 0, keywords: { built_in: b } };
    function D(I, { exceptions: S, when: z } = {}) {
        let N = z;
        return (S = S || []), I.map((q) => (q.match(/\|\d+$/) || S.includes(q) ? q : N(q) ? `${q}|0` : q));
    }
    return {
        name: 'SQL',
        case_insensitive: !0,
        illegal: /[{}]|<\//,
        keywords: {
            $pattern: /\b[\w\.]+/,
            keyword: D(y, { when: (I) => I.length < 3 }),
            literal: o,
            type: l,
            built_in: h,
        },
        contains: [
            {
                begin: e.either(...m),
                relevance: 0,
                keywords: { $pattern: /[\w\.]+/, keyword: y.concat(m), literal: o, type: l },
            },
            { className: 'type', begin: e.either(...s) },
            T,
            v,
            r,
            i,
            t.C_NUMBER_MODE,
            t.C_BLOCK_COMMENT_MODE,
            n,
            x,
        ],
    };
}
function v_(t) {
    return t ? (typeof t == 'string' ? t : t.source) : null;
}
function bu(t) {
    return ot('(?=', t, ')');
}
function ot(...t) {
    return t.map((n) => v_(n)).join('');
}
function kF(t) {
    let e = t[t.length - 1];
    return typeof e == 'object' && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function _n(...t) {
    return '(' + (kF(t).capture ? '' : '?:') + t.map((r) => v_(r)).join('|') + ')';
}
var vm = (t) => ot(/\b/, t, /\w$/.test(t) ? /\b/ : /\B/),
    NF = ['Protocol', 'Type'].map(vm),
    b_ = ['init', 'self'].map(vm),
    OF = ['Any', 'Self'],
    bm = [
        'actor',
        'any',
        'associatedtype',
        'async',
        'await',
        /as\?/,
        /as!/,
        'as',
        'break',
        'case',
        'catch',
        'class',
        'continue',
        'convenience',
        'default',
        'defer',
        'deinit',
        'didSet',
        'distributed',
        'do',
        'dynamic',
        'else',
        'enum',
        'extension',
        'fallthrough',
        /fileprivate\(set\)/,
        'fileprivate',
        'final',
        'for',
        'func',
        'get',
        'guard',
        'if',
        'import',
        'indirect',
        'infix',
        /init\?/,
        /init!/,
        'inout',
        /internal\(set\)/,
        'internal',
        'in',
        'is',
        'isolated',
        'nonisolated',
        'lazy',
        'let',
        'mutating',
        'nonmutating',
        /open\(set\)/,
        'open',
        'operator',
        'optional',
        'override',
        'postfix',
        'precedencegroup',
        'prefix',
        /private\(set\)/,
        'private',
        'protocol',
        /public\(set\)/,
        'public',
        'repeat',
        'required',
        'rethrows',
        'return',
        'set',
        'some',
        'static',
        'struct',
        'subscript',
        'super',
        'switch',
        'throws',
        'throw',
        /try\?/,
        /try!/,
        'try',
        'typealias',
        /unowned\(safe\)/,
        /unowned\(unsafe\)/,
        'unowned',
        'var',
        'weak',
        'where',
        'while',
        'willSet',
    ],
    y_ = ['false', 'nil', 'true'],
    RF = ['assignment', 'associativity', 'higherThan', 'left', 'lowerThan', 'none', 'right'],
    IF = [
        '#colorLiteral',
        '#column',
        '#dsohandle',
        '#else',
        '#elseif',
        '#endif',
        '#error',
        '#file',
        '#fileID',
        '#fileLiteral',
        '#filePath',
        '#function',
        '#if',
        '#imageLiteral',
        '#keyPath',
        '#line',
        '#selector',
        '#sourceLocation',
        '#warn_unqualified_access',
        '#warning',
    ],
    E_ = [
        'abs',
        'all',
        'any',
        'assert',
        'assertionFailure',
        'debugPrint',
        'dump',
        'fatalError',
        'getVaList',
        'isKnownUniquelyReferenced',
        'max',
        'min',
        'numericCast',
        'pointwiseMax',
        'pointwiseMin',
        'precondition',
        'preconditionFailure',
        'print',
        'readLine',
        'repeatElement',
        'sequence',
        'stride',
        'swap',
        'swift_unboxFromSwiftValueWithType',
        'transcode',
        'type',
        'unsafeBitCast',
        'unsafeDowncast',
        'withExtendedLifetime',
        'withUnsafeMutablePointer',
        'withUnsafePointer',
        'withVaList',
        'withoutActuallyEscaping',
        'zip',
    ],
    w_ = _n(
        /[/=\-+!*%<>&|^~?]/,
        /[\u00A1-\u00A7]/,
        /[\u00A9\u00AB]/,
        /[\u00AC\u00AE]/,
        /[\u00B0\u00B1]/,
        /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
        /[\u2016-\u2017]/,
        /[\u2020-\u2027]/,
        /[\u2030-\u203E]/,
        /[\u2041-\u2053]/,
        /[\u2055-\u205E]/,
        /[\u2190-\u23FF]/,
        /[\u2500-\u2775]/,
        /[\u2794-\u2BFF]/,
        /[\u2E00-\u2E7F]/,
        /[\u3001-\u3003]/,
        /[\u3008-\u3020]/,
        /[\u3030]/,
    ),
    x_ = _n(w_, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/),
    ym = ot(w_, x_, '*'),
    __ = _n(
        /[a-zA-Z_]/,
        /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
        /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
        /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
        /[\u1E00-\u1FFF]/,
        /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
        /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
        /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
        /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
        /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
        /[\uFE47-\uFEFE\uFF00-\uFFFD]/,
    ),
    yu = _n(__, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),
    Gr = ot(__, yu, '*'),
    Em = ot(/[A-Z]/, yu, '*'),
    LF = [
        'autoclosure',
        ot(/convention\(/, _n('swift', 'block', 'c'), /\)/),
        'discardableResult',
        'dynamicCallable',
        'dynamicMemberLookup',
        'escaping',
        'frozen',
        'GKInspectable',
        'IBAction',
        'IBDesignable',
        'IBInspectable',
        'IBOutlet',
        'IBSegueAction',
        'inlinable',
        'main',
        'nonobjc',
        'NSApplicationMain',
        'NSCopying',
        'NSManaged',
        ot(/objc\(/, Gr, /\)/),
        'objc',
        'objcMembers',
        'propertyWrapper',
        'requires_stored_property_inits',
        'resultBuilder',
        'testable',
        'UIApplicationMain',
        'unknown',
        'usableFromInline',
    ],
    DF = [
        'iOS',
        'iOSApplicationExtension',
        'macOS',
        'macOSApplicationExtension',
        'macCatalyst',
        'macCatalystApplicationExtension',
        'watchOS',
        'watchOSApplicationExtension',
        'tvOS',
        'tvOSApplicationExtension',
        'swift',
    ];
function S_(t) {
    let e = { match: /\s+/, relevance: 0 },
        n = t.COMMENT('/\\*', '\\*/', { contains: ['self'] }),
        r = [t.C_LINE_COMMENT_MODE, n],
        i = { match: [/\./, _n(...NF, ...b_)], className: { 2: 'keyword' } },
        o = { match: ot(/\./, _n(...bm)), relevance: 0 },
        s = bm.filter((De) => typeof De == 'string').concat(['_|0']),
        l = bm
            .filter((De) => typeof De != 'string')
            .concat(OF)
            .map(vm),
        u = { variants: [{ className: 'keyword', match: _n(...l, ...b_) }] },
        d = { $pattern: _n(/\b\w+/, /#\w+/), keyword: s.concat(IF), literal: y_ },
        f = [i, o, u],
        h = { match: ot(/\./, _n(...E_)), relevance: 0 },
        m = { className: 'built_in', match: ot(/\b/, _n(...E_), /(?=\()/) },
        b = [h, m],
        y = { match: /->/, relevance: 0 },
        v = { className: 'operator', relevance: 0, variants: [{ match: ym }, { match: `\\.(\\.|${x_})+` }] },
        x = [y, v],
        T = '([0-9]_*)+',
        D = '([0-9a-fA-F]_*)+',
        I = {
            className: 'number',
            relevance: 0,
            variants: [
                { match: `\\b(${T})(\\.(${T}))?([eE][+-]?(${T}))?\\b` },
                { match: `\\b0x(${D})(\\.(${D}))?([pP][+-]?(${T}))?\\b` },
                { match: /\b0o([0-7]_*)+\b/ },
                { match: /\b0b([01]_*)+\b/ },
            ],
        },
        S = (De = '') => ({
            className: 'subst',
            variants: [{ match: ot(/\\/, De, /[0\\tnr"']/) }, { match: ot(/\\/, De, /u\{[0-9a-fA-F]{1,8}\}/) }],
        }),
        z = (De = '') => ({ className: 'subst', match: ot(/\\/, De, /[\t ]*(?:[\r\n]|\r\n)/) }),
        N = (De = '') => ({ className: 'subst', label: 'interpol', begin: ot(/\\/, De, /\(/), end: /\)/ }),
        q = (De = '') => ({ begin: ot(De, /"""/), end: ot(/"""/, De), contains: [S(De), z(De), N(De)] }),
        ne = (De = '') => ({ begin: ot(De, /"/), end: ot(/"/, De), contains: [S(De), N(De)] }),
        $ = { className: 'string', variants: [q(), q('#'), q('##'), q('###'), ne(), ne('#'), ne('##'), ne('###')] },
        oe = { match: ot(/`/, Gr, /`/) },
        me = { className: 'variable', match: /\$\d+/ },
        Te = { className: 'variable', match: `\\$${yu}+` },
        ge = [oe, me, Te],
        Me = {
            match: /(@|#(un)?)available/,
            className: 'keyword',
            starts: { contains: [{ begin: /\(/, end: /\)/, keywords: DF, contains: [...x, I, $] }] },
        },
        Ee = { className: 'keyword', match: ot(/@/, _n(...LF)) },
        P = { className: 'meta', match: ot(/@/, Gr) },
        O = [Me, Ee, P],
        R = {
            match: bu(/\b[A-Z]/),
            relevance: 0,
            contains: [
                {
                    className: 'type',
                    match: ot(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, yu, '+'),
                },
                { className: 'type', match: Em, relevance: 0 },
                { match: /[?!]+/, relevance: 0 },
                { match: /\.\.\./, relevance: 0 },
                { match: ot(/\s+&\s+/, bu(Em)), relevance: 0 },
            ],
        },
        V = { begin: /</, end: />/, keywords: d, contains: [...r, ...f, ...O, y, R] };
    R.contains.push(V);
    let Q = { match: ot(Gr, /\s*:/), keywords: '_|0', relevance: 0 },
        he = {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            keywords: d,
            contains: ['self', Q, ...r, ...f, ...b, ...x, I, $, ...ge, ...O, R],
        },
        xe = { begin: /</, end: />/, contains: [...r, R] },
        Ue = {
            begin: _n(bu(ot(Gr, /\s*:/)), bu(ot(Gr, /\s+/, Gr, /\s*:/))),
            end: /:/,
            relevance: 0,
            contains: [
                { className: 'keyword', match: /\b_\b/ },
                { className: 'params', match: Gr },
            ],
        },
        We = {
            begin: /\(/,
            end: /\)/,
            keywords: d,
            contains: [Ue, ...r, ...f, ...x, I, $, ...O, R, he],
            endsParent: !0,
            illegal: /["']/,
        },
        He = {
            match: [/func/, /\s+/, _n(oe.match, Gr, ym)],
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [xe, We, e],
            illegal: [/\[/, /%/],
        },
        Xe = {
            match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
            className: { 1: 'keyword' },
            contains: [xe, We, e],
            illegal: /\[|%/,
        },
        xt = { match: [/operator/, /\s+/, ym], className: { 1: 'keyword', 3: 'title' } },
        Pt = {
            begin: [/precedencegroup/, /\s+/, Em],
            className: { 1: 'keyword', 3: 'title' },
            contains: [R],
            keywords: [...RF, ...y_],
            end: /}/,
        };
    for (let De of $.variants) {
        let _t = De.contains.find((st) => st.label === 'interpol');
        _t.keywords = d;
        let Zt = [...f, ...b, ...x, I, $, ...ge];
        _t.contains = [...Zt, { begin: /\(/, end: /\)/, contains: ['self', ...Zt] }];
    }
    return {
        name: 'Swift',
        keywords: d,
        contains: [
            ...r,
            He,
            Xe,
            {
                beginKeywords: 'struct protocol class extension enum actor',
                end: '\\{',
                excludeEnd: !0,
                keywords: d,
                contains: [
                    t.inherit(t.TITLE_MODE, {
                        className: 'title.class',
                        begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/,
                    }),
                    ...f,
                ],
            },
            xt,
            Pt,
            { beginKeywords: 'import', end: /$/, contains: [...r], relevance: 0 },
            ...f,
            ...b,
            ...x,
            I,
            $,
            ...ge,
            ...O,
            R,
            he,
        ],
    };
}
var Eu = '[A-Za-z$_][0-9A-Za-z$_]*',
    T_ = [
        'as',
        'in',
        'of',
        'if',
        'for',
        'while',
        'finally',
        'var',
        'new',
        'function',
        'do',
        'return',
        'void',
        'else',
        'break',
        'catch',
        'instanceof',
        'with',
        'throw',
        'case',
        'default',
        'try',
        'switch',
        'continue',
        'typeof',
        'delete',
        'let',
        'yield',
        'const',
        'class',
        'debugger',
        'async',
        'await',
        'static',
        'import',
        'from',
        'export',
        'extends',
    ],
    M_ = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'],
    A_ = [
        'Object',
        'Function',
        'Boolean',
        'Symbol',
        'Math',
        'Date',
        'Number',
        'BigInt',
        'String',
        'RegExp',
        'Array',
        'Float32Array',
        'Float64Array',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Int32Array',
        'Uint16Array',
        'Uint32Array',
        'BigInt64Array',
        'BigUint64Array',
        'Set',
        'Map',
        'WeakSet',
        'WeakMap',
        'ArrayBuffer',
        'SharedArrayBuffer',
        'Atomics',
        'DataView',
        'JSON',
        'Promise',
        'Generator',
        'GeneratorFunction',
        'AsyncFunction',
        'Reflect',
        'Proxy',
        'Intl',
        'WebAssembly',
    ],
    C_ = [
        'Error',
        'EvalError',
        'InternalError',
        'RangeError',
        'ReferenceError',
        'SyntaxError',
        'TypeError',
        'URIError',
    ],
    k_ = [
        'setInterval',
        'setTimeout',
        'clearInterval',
        'clearTimeout',
        'require',
        'exports',
        'eval',
        'isFinite',
        'isNaN',
        'parseFloat',
        'parseInt',
        'decodeURI',
        'decodeURIComponent',
        'encodeURI',
        'encodeURIComponent',
        'escape',
        'unescape',
    ],
    N_ = [
        'arguments',
        'this',
        'super',
        'console',
        'window',
        'document',
        'localStorage',
        'sessionStorage',
        'module',
        'global',
    ],
    O_ = [].concat(k_, A_, C_);
function PF(t) {
    let e = t.regex,
        n = (R, { after: V }) => {
            let Q = '</' + R[0].slice(1);
            return R.input.indexOf(Q, V) !== -1;
        },
        r = Eu,
        i = { begin: '<>', end: '</>' },
        o = /<[A-Za-z0-9\\._:-]+\s*\/>/,
        s = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (R, V) => {
                let Q = R[0].length + R.index,
                    he = R.input[Q];
                if (he === '<' || he === ',') {
                    V.ignoreMatch();
                    return;
                }
                he === '>' && (n(R, { after: Q }) || V.ignoreMatch());
                let xe,
                    Ue = R.input.substring(Q);
                if ((xe = Ue.match(/^\s*=/))) {
                    V.ignoreMatch();
                    return;
                }
                if ((xe = Ue.match(/^\s+extends\s+/)) && xe.index === 0) {
                    V.ignoreMatch();
                    return;
                }
            },
        },
        l = { $pattern: Eu, keyword: T_, literal: M_, built_in: O_, 'variable.language': N_ },
        u = '[0-9](_?[0-9])*',
        d = `\\.(${u})`,
        f = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*',
        h = {
            className: 'number',
            variants: [
                { begin: `(\\b(${f})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
                { begin: `\\b(${f})\\b((${d})\\b|\\.)?|(${d})\\b` },
                { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
                { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
                { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
                { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
                { begin: '\\b0[0-7]+n?\\b' },
            ],
            relevance: 0,
        },
        m = { className: 'subst', begin: '\\$\\{', end: '\\}', keywords: l, contains: [] },
        b = {
            begin: 'html`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'xml' },
        },
        y = {
            begin: 'css`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'css' },
        },
        v = {
            begin: 'gql`',
            end: '',
            starts: { end: '`', returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, m], subLanguage: 'graphql' },
        },
        x = { className: 'string', begin: '`', end: '`', contains: [t.BACKSLASH_ESCAPE, m] },
        D = {
            className: 'comment',
            variants: [
                t.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
                    relevance: 0,
                    contains: [
                        {
                            begin: '(?=@[A-Za-z]+)',
                            relevance: 0,
                            contains: [
                                { className: 'doctag', begin: '@[A-Za-z]+' },
                                {
                                    className: 'type',
                                    begin: '\\{',
                                    end: '\\}',
                                    excludeEnd: !0,
                                    excludeBegin: !0,
                                    relevance: 0,
                                },
                                { className: 'variable', begin: r + '(?=\\s*(-)|$)', endsParent: !0, relevance: 0 },
                                { begin: /(?=[^\n])\s/, relevance: 0 },
                            ],
                        },
                    ],
                }),
                t.C_BLOCK_COMMENT_MODE,
                t.C_LINE_COMMENT_MODE,
            ],
        },
        I = [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, b, y, v, x, { match: /\$\d+/ }, h];
    m.contains = I.concat({ begin: /\{/, end: /\}/, keywords: l, contains: ['self'].concat(I) });
    let S = [].concat(D, m.contains),
        z = S.concat([{ begin: /\(/, end: /\)/, keywords: l, contains: ['self'].concat(S) }]),
        N = { className: 'params', begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: l, contains: z },
        q = {
            variants: [
                {
                    match: [/class/, /\s+/, r, /\s+/, /extends/, /\s+/, e.concat(r, '(', e.concat(/\./, r), ')*')],
                    scope: { 1: 'keyword', 3: 'title.class', 5: 'keyword', 7: 'title.class.inherited' },
                },
                { match: [/class/, /\s+/, r], scope: { 1: 'keyword', 3: 'title.class' } },
            ],
        },
        ne = {
            relevance: 0,
            match: e.either(
                /\bJSON/,
                /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/,
            ),
            className: 'title.class',
            keywords: { _: [...A_, ...C_] },
        },
        $ = { label: 'use_strict', className: 'meta', relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ },
        oe = {
            variants: [{ match: [/function/, /\s+/, r, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }],
            className: { 1: 'keyword', 3: 'title.function' },
            label: 'func.def',
            contains: [N],
            illegal: /%/,
        },
        me = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' };
    function Te(R) {
        return e.concat('(?!', R.join('|'), ')');
    }
    let ge = {
            match: e.concat(/\b/, Te([...k_, 'super', 'import']), r, e.lookahead(/\(/)),
            className: 'title.function',
            relevance: 0,
        },
        Me = {
            begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))),
            end: r,
            excludeBegin: !0,
            keywords: 'prototype',
            className: 'property',
            relevance: 0,
        },
        Ee = {
            match: [/get|set/, /\s+/, r, /(?=\()/],
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [{ begin: /\(\)/ }, N],
        },
        P = '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' + t.UNDERSCORE_IDENT_RE + ')\\s*=>',
        O = {
            match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(P)],
            keywords: 'async',
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [N],
        };
    return {
        name: 'JavaScript',
        aliases: ['js', 'jsx', 'mjs', 'cjs'],
        keywords: l,
        exports: { PARAMS_CONTAINS: z, CLASS_REFERENCE: ne },
        illegal: /#(?![$_A-z])/,
        contains: [
            t.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
            $,
            t.APOS_STRING_MODE,
            t.QUOTE_STRING_MODE,
            b,
            y,
            v,
            x,
            D,
            { match: /\$\d+/ },
            h,
            ne,
            { className: 'attr', begin: r + e.lookahead(':'), relevance: 0 },
            O,
            {
                begin: '(' + t.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                keywords: 'return throw case',
                relevance: 0,
                contains: [
                    D,
                    t.REGEXP_MODE,
                    {
                        className: 'function',
                        begin: P,
                        returnBegin: !0,
                        end: '\\s*=>',
                        contains: [
                            {
                                className: 'params',
                                variants: [
                                    { begin: t.UNDERSCORE_IDENT_RE, relevance: 0 },
                                    { className: null, begin: /\(\s*\)/, skip: !0 },
                                    {
                                        begin: /\(/,
                                        end: /\)/,
                                        excludeBegin: !0,
                                        excludeEnd: !0,
                                        keywords: l,
                                        contains: z,
                                    },
                                ],
                            },
                        ],
                    },
                    { begin: /,/, relevance: 0 },
                    { match: /\s+/, relevance: 0 },
                    {
                        variants: [
                            { begin: i.begin, end: i.end },
                            { match: o },
                            { begin: s.begin, 'on:begin': s.isTrulyOpeningTag, end: s.end },
                        ],
                        subLanguage: 'xml',
                        contains: [{ begin: s.begin, end: s.end, skip: !0, contains: ['self'] }],
                    },
                ],
            },
            oe,
            { beginKeywords: 'while if switch catch for' },
            {
                begin:
                    '\\b(?!function)' +
                    t.UNDERSCORE_IDENT_RE +
                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
                returnBegin: !0,
                label: 'func.def',
                contains: [N, t.inherit(t.TITLE_MODE, { begin: r, className: 'title.function' })],
            },
            { match: /\.\.\./, relevance: 0 },
            Me,
            { match: '\\$' + r, relevance: 0 },
            { match: [/\bconstructor(?=\s*\()/], className: { 1: 'title.function' }, contains: [N] },
            ge,
            me,
            q,
            Ee,
            { match: /\$[(.]/ },
        ],
    };
}
function R_(t) {
    let e = PF(t),
        n = Eu,
        r = ['any', 'void', 'number', 'boolean', 'string', 'object', 'never', 'symbol', 'bigint', 'unknown'],
        i = { beginKeywords: 'namespace', end: /\{/, excludeEnd: !0, contains: [e.exports.CLASS_REFERENCE] },
        o = {
            beginKeywords: 'interface',
            end: /\{/,
            excludeEnd: !0,
            keywords: { keyword: 'interface extends', built_in: r },
            contains: [e.exports.CLASS_REFERENCE],
        },
        s = { className: 'meta', relevance: 10, begin: /^\s*['"]use strict['"]/ },
        l = [
            'type',
            'namespace',
            'interface',
            'public',
            'private',
            'protected',
            'implements',
            'declare',
            'abstract',
            'readonly',
            'enum',
            'override',
        ],
        u = { $pattern: Eu, keyword: T_.concat(l), literal: M_, built_in: O_.concat(r), 'variable.language': N_ },
        d = { className: 'meta', begin: '@' + n },
        f = (m, b, y) => {
            let v = m.contains.findIndex((x) => x.label === b);
            if (v === -1) throw new Error('can not find mode to replace');
            m.contains.splice(v, 1, y);
        };
    Object.assign(e.keywords, u),
        e.exports.PARAMS_CONTAINS.push(d),
        (e.contains = e.contains.concat([d, i, o])),
        f(e, 'shebang', t.SHEBANG()),
        f(e, 'use_strict', s);
    let h = e.contains.find((m) => m.label === 'func.def');
    return (h.relevance = 0), Object.assign(e, { name: 'TypeScript', aliases: ['ts', 'tsx', 'mts', 'cts'] }), e;
}
function I_(t) {
    let e = t.regex,
        n = { className: 'string', begin: /"(""|[^/n])"C\b/ },
        r = { className: 'string', begin: /"/, end: /"/, illegal: /\n/, contains: [{ begin: /""/ }] },
        i = /\d{1,2}\/\d{1,2}\/\d{4}/,
        o = /\d{4}-\d{1,2}-\d{1,2}/,
        s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/,
        l = /\d{1,2}(:\d{1,2}){1,2}/,
        u = {
            className: 'literal',
            variants: [
                { begin: e.concat(/# */, e.either(o, i), / *#/) },
                { begin: e.concat(/# */, l, / *#/) },
                { begin: e.concat(/# */, s, / *#/) },
                { begin: e.concat(/# */, e.either(o, i), / +/, e.either(s, l), / *#/) },
            ],
        },
        d = {
            className: 'number',
            relevance: 0,
            variants: [
                { begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/ },
                { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
                { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
                { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
                { begin: /&B[01_]+((U?[SIL])|[%&])?/ },
            ],
        },
        f = { className: 'label', begin: /^\w+:/ },
        h = t.COMMENT(/'''/, /$/, { contains: [{ className: 'doctag', begin: /<\/?/, end: />/ }] }),
        m = t.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] });
    return {
        name: 'Visual Basic .NET',
        aliases: ['vb'],
        case_insensitive: !0,
        classNameAliases: { label: 'symbol' },
        keywords: {
            keyword:
                'addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield',
            built_in:
                'addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort',
            type: 'boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort',
            literal: 'true false nothing',
        },
        illegal: '//|\\{|\\}|endif|gosub|variant|wend|^\\$ ',
        contains: [
            n,
            r,
            u,
            d,
            f,
            h,
            m,
            {
                className: 'meta',
                begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
                end: /$/,
                keywords: { keyword: 'const disable else elseif enable end externalsource if region then' },
                contains: [m],
            },
        ],
    };
}
function L_(t) {
    t.regex;
    let e = t.COMMENT(/\(;/, /;\)/);
    e.contains.push('self');
    let n = t.COMMENT(/;;/, /$/),
        r = [
            'anyfunc',
            'block',
            'br',
            'br_if',
            'br_table',
            'call',
            'call_indirect',
            'data',
            'drop',
            'elem',
            'else',
            'end',
            'export',
            'func',
            'global.get',
            'global.set',
            'local.get',
            'local.set',
            'local.tee',
            'get_global',
            'get_local',
            'global',
            'if',
            'import',
            'local',
            'loop',
            'memory',
            'memory.grow',
            'memory.size',
            'module',
            'mut',
            'nop',
            'offset',
            'param',
            'result',
            'return',
            'select',
            'set_global',
            'set_local',
            'start',
            'table',
            'tee_local',
            'then',
            'type',
            'unreachable',
        ],
        i = {
            begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
            className: { 1: 'keyword', 3: 'title.function' },
        },
        o = { className: 'variable', begin: /\$[\w_]+/ },
        s = { match: /(\((?!;)|\))+/, className: 'punctuation', relevance: 0 },
        l = {
            className: 'number',
            relevance: 0,
            match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
        },
        u = { match: /(i32|i64|f32|f64)(?!\.)/, className: 'type' },
        d = {
            className: 'keyword',
            match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/,
        };
    return {
        name: 'WebAssembly',
        keywords: { $pattern: /[\w.]+/, keyword: r },
        contains: [
            n,
            e,
            { match: [/(?:offset|align)/, /\s*/, /=/], className: { 1: 'keyword', 3: 'operator' } },
            o,
            s,
            i,
            t.QUOTE_STRING_MODE,
            u,
            d,
            l,
        ],
    };
}
function D_(t) {
    let e = t.regex,
        n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u),
        r = /[\p{L}0-9._:-]+/u,
        i = { className: 'symbol', begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ },
        o = { begin: /\s/, contains: [{ className: 'keyword', begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] },
        s = t.inherit(o, { begin: /\(/, end: /\)/ }),
        l = t.inherit(t.APOS_STRING_MODE, { className: 'string' }),
        u = t.inherit(t.QUOTE_STRING_MODE, { className: 'string' }),
        d = {
            endsWithParent: !0,
            illegal: /</,
            relevance: 0,
            contains: [
                { className: 'attr', begin: r, relevance: 0 },
                {
                    begin: /=\s*/,
                    relevance: 0,
                    contains: [
                        {
                            className: 'string',
                            endsParent: !0,
                            variants: [
                                { begin: /"/, end: /"/, contains: [i] },
                                { begin: /'/, end: /'/, contains: [i] },
                                { begin: /[^\s"'=<>`]+/ },
                            ],
                        },
                    ],
                },
            ],
        };
    return {
        name: 'HTML, XML',
        aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist', 'wsf', 'svg'],
        case_insensitive: !0,
        unicodeRegex: !0,
        contains: [
            {
                className: 'meta',
                begin: /<![a-z]/,
                end: />/,
                relevance: 10,
                contains: [
                    o,
                    u,
                    l,
                    s,
                    {
                        begin: /\[/,
                        end: /\]/,
                        contains: [{ className: 'meta', begin: /<![a-z]/, end: />/, contains: [o, s, u, l] }],
                    },
                ],
            },
            t.COMMENT(/<!--/, /-->/, { relevance: 10 }),
            { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
            i,
            {
                className: 'meta',
                end: /\?>/,
                variants: [{ begin: /<\?xml/, relevance: 10, contains: [u] }, { begin: /<\?[a-z][a-z0-9]+/ }],
            },
            {
                className: 'tag',
                begin: /<style(?=\s|>)/,
                end: />/,
                keywords: { name: 'style' },
                contains: [d],
                starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ['css', 'xml'] },
            },
            {
                className: 'tag',
                begin: /<script(?=\s|>)/,
                end: />/,
                keywords: { name: 'script' },
                contains: [d],
                starts: { end: /<\/script>/, returnEnd: !0, subLanguage: ['javascript', 'handlebars', 'xml'] },
            },
            { className: 'tag', begin: /<>|<\/>/ },
            {
                className: 'tag',
                begin: e.concat(/</, e.lookahead(e.concat(n, e.either(/\/>/, />/, /\s/)))),
                end: /\/?>/,
                contains: [{ className: 'name', begin: n, relevance: 0, starts: d }],
            },
            {
                className: 'tag',
                begin: e.concat(/<\//, e.lookahead(e.concat(n, />/))),
                contains: [
                    { className: 'name', begin: n, relevance: 0 },
                    { begin: />/, relevance: 0, endsParent: !0 },
                ],
            },
        ],
    };
}
function P_(t) {
    let e = 'true false yes no null',
        n = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
        r = {
            className: 'attr',
            variants: [
                { begin: '\\w[\\w :\\/.-]*:(?=[ 	]|$)' },
                { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' },
                { begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)" },
            ],
        },
        i = {
            className: 'template-variable',
            variants: [
                { begin: /\{\{/, end: /\}\}/ },
                { begin: /%\{/, end: /\}/ },
            ],
        },
        o = {
            className: 'string',
            relevance: 0,
            variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /\S+/ }],
            contains: [t.BACKSLASH_ESCAPE, i],
        },
        s = t.inherit(o, { variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }] }),
        h = {
            className: 'number',
            begin:
                '\\b' +
                '[0-9]{4}(-[0-9][0-9]){0,2}' +
                '([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?' +
                '(\\.[0-9]*)?' +
                '([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?' +
                '\\b',
        },
        m = { end: ',', endsWithParent: !0, excludeEnd: !0, keywords: e, relevance: 0 },
        b = { begin: /\{/, end: /\}/, contains: [m], illegal: '\\n', relevance: 0 },
        y = { begin: '\\[', end: '\\]', contains: [m], illegal: '\\n', relevance: 0 },
        v = [
            r,
            { className: 'meta', begin: '^---\\s*$', relevance: 10 },
            { className: 'string', begin: '[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*' },
            { begin: '<%[%=-]?', end: '[%-]?%>', subLanguage: 'ruby', excludeBegin: !0, excludeEnd: !0, relevance: 0 },
            { className: 'type', begin: '!\\w+!' + n },
            { className: 'type', begin: '!<' + n + '>' },
            { className: 'type', begin: '!' + n },
            { className: 'type', begin: '!!' + n },
            { className: 'meta', begin: '&' + t.UNDERSCORE_IDENT_RE + '$' },
            { className: 'meta', begin: '\\*' + t.UNDERSCORE_IDENT_RE + '$' },
            { className: 'bullet', begin: '-(?=[ ]|$)', relevance: 0 },
            t.HASH_COMMENT_MODE,
            { beginKeywords: e, keywords: { literal: e } },
            h,
            { className: 'number', begin: t.C_NUMBER_RE + '\\b', relevance: 0 },
            b,
            y,
            o,
        ],
        x = [...v];
    return x.pop(), x.push(s), (m.contains = x), { name: 'YAML', case_insensitive: !0, aliases: ['yml'], contains: v };
}
var rS = Gd(nS(), 1);
var Jn = rS.default;
var oS = Gd(iS(), 1),
    wa = Object.assign(Eo(Error), {
        eval: Eo(EvalError),
        range: Eo(RangeError),
        reference: Eo(ReferenceError),
        syntax: Eo(SyntaxError),
        type: Eo(TypeError),
        uri: Eo(URIError),
    });
function Eo(t) {
    return (e.displayName = t.displayName || t.name), e;
    function e(n, ...r) {
        let i = n && (0, oS.default)(n, ...r);
        return new t(i);
    }
}
var MH = {}.hasOwnProperty,
    sS = 'hljs-';
function aS(t, e, n = {}) {
    let r = n.prefix;
    if (typeof t != 'string') throw wa('Expected `string` for name, got `%s`', t);
    if (!Jn.getLanguage(t)) throw wa('Unknown language: `%s` is not registered', t);
    if (typeof e != 'string') throw wa('Expected `string` for value, got `%s`', e);
    r == null && (r = sS), Jn.configure({ __emitter: Nm, classPrefix: r });
    let i = Jn.highlight(e, { language: t, ignoreIllegals: !0 });
    if ((Jn.configure({}), i.errorRaised)) throw i.errorRaised;
    return (
        (i._emitter.root.data.language = i.language), (i._emitter.root.data.relevance = i.relevance), i._emitter.root
    );
}
function AH(t, e = {}) {
    let n = e.subset || Jn.listLanguages(),
        r = e.prefix,
        i = -1,
        o = { type: 'root', data: { language: null, relevance: 0 }, children: [] };
    if ((r == null && (r = sS), typeof t != 'string')) throw wa('Expected `string` for value, got `%s`', t);
    for (; ++i < n.length; ) {
        let s = n[i];
        if (!Jn.getLanguage(s)) continue;
        let l = aS(s, t, e);
        l.data.relevance > o.data.relevance && (o = l);
    }
    return o;
}
function CH(t, e) {
    Jn.registerLanguage(t, e);
}
var kH = function (t, e) {
    if (typeof t == 'string') Jn.registerAliases(e, { languageName: t });
    else {
        let n;
        for (n in t) MH.call(t, n) && Jn.registerAliases(t[n], { languageName: n });
    }
};
function NH(t) {
    return !!Jn.getLanguage(t);
}
function OH() {
    return Jn.listLanguages();
}
var Nm = class {
        constructor(e) {
            (this.options = e),
                (this.root = { type: 'root', data: { language: null, relevance: 0 }, children: [] }),
                (this.stack = [this.root]);
        }
        addText(e) {
            if (e === '') return;
            let n = this.stack[this.stack.length - 1],
                r = n.children[n.children.length - 1];
            r && r.type === 'text' ? (r.value += e) : n.children.push({ type: 'text', value: e });
        }
        startScope(e) {
            this.openNode(String(e));
        }
        endScope() {
            this.closeNode();
        }
        __addSublanguage(e, n) {
            let r = this.stack[this.stack.length - 1],
                i = e.root.children;
            n
                ? r.children.push({ type: 'element', tagName: 'span', properties: { className: [n] }, children: i })
                : r.children.push(...i);
        }
        openNode(e) {
            let n = e.split('.').map((o, s) => (s ? o + '_'.repeat(s) : this.options.classPrefix + o)),
                r = this.stack[this.stack.length - 1],
                i = { type: 'element', tagName: 'span', properties: { className: n }, children: [] };
            r.children.push(i), this.stack.push(i);
        }
        closeNode() {
            this.stack.pop();
        }
        finalize() {}
        toHTML() {
            return '';
        }
    },
    Le = {
        highlight: aS,
        highlightAuto: AH,
        registerLanguage: CH,
        registered: NH,
        listLanguages: OH,
        registerAlias: kH,
    };
Le.registerLanguage('arduino', Rx);
Le.registerLanguage('bash', Ix);
Le.registerLanguage('c', Lx);
Le.registerLanguage('cpp', Dx);
Le.registerLanguage('csharp', Px);
Le.registerLanguage('css', Bx);
Le.registerLanguage('diff', Fx);
Le.registerLanguage('go', Hx);
Le.registerLanguage('graphql', zx);
Le.registerLanguage('ini', $x);
Le.registerLanguage('java', Kx);
Le.registerLanguage('javascript', Jx);
Le.registerLanguage('json', Xx);
Le.registerLanguage('kotlin', Zx);
Le.registerLanguage('less', e_);
Le.registerLanguage('lua', t_);
Le.registerLanguage('makefile', n_);
Le.registerLanguage('markdown', r_);
Le.registerLanguage('objectivec', i_);
Le.registerLanguage('perl', o_);
Le.registerLanguage('php', s_);
Le.registerLanguage('php-template', a_);
Le.registerLanguage('plaintext', l_);
Le.registerLanguage('python', c_);
Le.registerLanguage('python-repl', u_);
Le.registerLanguage('r', d_);
Le.registerLanguage('ruby', f_);
Le.registerLanguage('rust', p_);
Le.registerLanguage('scss', h_);
Le.registerLanguage('shell', m_);
Le.registerLanguage('sql', g_);
Le.registerLanguage('swift', S_);
Le.registerLanguage('typescript', R_);
Le.registerLanguage('vbnet', I_);
Le.registerLanguage('wasm', L_);
Le.registerLanguage('xml', D_);
Le.registerLanguage('yaml', P_);
var Ti = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t),
    kt = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n;
var Zq = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) },
    lS = (t) => DH(Tu(t)),
    Tu = (t) => (
        t[0] === '#' && (t = t.substring(1)),
        t.length < 6
            ? {
                  r: parseInt(t[0] + t[0], 16),
                  g: parseInt(t[1] + t[1], 16),
                  b: parseInt(t[2] + t[2], 16),
                  a: t.length === 4 ? kt(parseInt(t[3] + t[3], 16) / 255, 2) : 1,
              }
            : {
                  r: parseInt(t.substring(0, 2), 16),
                  g: parseInt(t.substring(2, 4), 16),
                  b: parseInt(t.substring(4, 6), 16),
                  a: t.length === 8 ? kt(parseInt(t.substring(6, 8), 16) / 255, 2) : 1,
              }
    );
var cS = (t) => LH(IH(t)),
    RH = ({ h: t, s: e, v: n, a: r }) => {
        let i = ((200 - e) * n) / 100;
        return {
            h: kt(t),
            s: kt(i > 0 && i < 200 ? ((e * n) / 100 / (i <= 100 ? i : 200 - i)) * 100 : 0),
            l: kt(i / 2),
            a: kt(r, 2),
        };
    };
var xa = (t) => {
    let { h: e, s: n, l: r } = RH(t);
    return `hsl(${e}, ${n}%, ${r}%)`;
};
var IH = ({ h: t, s: e, v: n, a: r }) => {
    (t = (t / 360) * 6), (e = e / 100), (n = n / 100);
    let i = Math.floor(t),
        o = n * (1 - e),
        s = n * (1 - (t - i) * e),
        l = n * (1 - (1 - t + i) * e),
        u = i % 6;
    return {
        r: kt([n, s, o, o, l, n][u] * 255),
        g: kt([l, n, n, s, o, o][u] * 255),
        b: kt([o, o, l, n, n, s][u] * 255),
        a: kt(r, 2),
    };
};
var Su = (t) => {
        let e = t.toString(16);
        return e.length < 2 ? '0' + e : e;
    },
    LH = ({ r: t, g: e, b: n, a: r }) => {
        let i = r < 1 ? Su(kt(r * 255)) : '';
        return '#' + Su(t) + Su(e) + Su(n) + i;
    },
    DH = ({ r: t, g: e, b: n, a: r }) => {
        let i = Math.max(t, e, n),
            o = i - Math.min(t, e, n),
            s = o ? (i === t ? (e - n) / o : i === e ? 2 + (n - t) / o : 4 + (t - e) / o) : 0;
        return { h: kt(60 * (s < 0 ? s + 6 : s)), s: kt(i ? (o / i) * 100 : 0), v: kt((i / 255) * 100), a: r };
    };
var Om = (t, e) => {
    if (t === e) return !0;
    for (let n in t) if (t[n] !== e[n]) return !1;
    return !0;
};
var uS = (t, e) => (t.toLowerCase() === e.toLowerCase() ? !0 : Om(Tu(t), Tu(e)));
var dS = {},
    Mu = (t) => {
        let e = dS[t];
        return e || ((e = document.createElement('template')), (e.innerHTML = t), (dS[t] = e)), e;
    },
    _a = (t, e, n) => {
        t.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: n }));
    };
var ds = !1,
    Rm = (t) => 'touches' in t,
    PH = (t) => (ds && !Rm(t) ? !1 : (ds || (ds = Rm(t)), !0)),
    fS = (t, e) => {
        let n = Rm(e) ? e.touches[0] : e,
            r = t.el.getBoundingClientRect();
        _a(
            t.el,
            'move',
            t.getMove({
                x: Ti((n.pageX - (r.left + window.pageXOffset)) / r.width),
                y: Ti((n.pageY - (r.top + window.pageYOffset)) / r.height),
            }),
        );
    },
    BH = (t, e) => {
        let n = e.keyCode;
        n > 40 ||
            (t.xy && n < 37) ||
            n < 33 ||
            (e.preventDefault(),
            _a(
                t.el,
                'move',
                t.getMove(
                    {
                        x:
                            n === 39
                                ? 0.01
                                : n === 37
                                  ? -0.01
                                  : n === 34
                                    ? 0.05
                                    : n === 33
                                      ? -0.05
                                      : n === 35
                                        ? 1
                                        : n === 36
                                          ? -1
                                          : 0,
                        y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0,
                    },
                    !0,
                ),
            ));
    },
    fs = class {
        constructor(e, n, r, i) {
            let o = Mu(`<div role="slider" tabindex="0" part="${n}" ${r}><div part="${n}-pointer"></div></div>`);
            e.appendChild(o.content.cloneNode(!0));
            let s = e.querySelector(`[part=${n}]`);
            s.addEventListener('mousedown', this),
                s.addEventListener('touchstart', this),
                s.addEventListener('keydown', this),
                (this.el = s),
                (this.xy = i),
                (this.nodes = [s.firstChild, s]);
        }
        set dragging(e) {
            let n = e ? document.addEventListener : document.removeEventListener;
            n(ds ? 'touchmove' : 'mousemove', this), n(ds ? 'touchend' : 'mouseup', this);
        }
        handleEvent(e) {
            switch (e.type) {
                case 'mousedown':
                case 'touchstart':
                    if ((e.preventDefault(), !PH(e) || (!ds && e.button != 0))) return;
                    this.el.focus(), fS(this, e), (this.dragging = !0);
                    break;
                case 'mousemove':
                case 'touchmove':
                    e.preventDefault(), fS(this, e);
                    break;
                case 'mouseup':
                case 'touchend':
                    this.dragging = !1;
                    break;
                case 'keydown':
                    BH(this, e);
                    break;
            }
        }
        style(e) {
            e.forEach((n, r) => {
                for (let i in n) this.nodes[r].style.setProperty(i, n[i]);
            });
        }
    };
var Au = class extends fs {
    constructor(e) {
        super(e, 'hue', 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1);
    }
    update({ h: e }) {
        (this.h = e),
            this.style([{ left: `${(e / 360) * 100}%`, color: xa({ h: e, s: 100, v: 100, a: 1 }) }]),
            this.el.setAttribute('aria-valuenow', `${kt(e)}`);
    }
    getMove(e, n) {
        return { h: n ? Ti(this.h + e.x * 360, 0, 360) : 360 * e.x };
    }
};
var Cu = class extends fs {
    constructor(e) {
        super(e, 'saturation', 'aria-label="Color"', !0);
    }
    update(e) {
        (this.hsva = e),
            this.style([
                { top: `${100 - e.v}%`, left: `${e.s}%`, color: xa(e) },
                { 'background-color': xa({ h: e.h, s: 100, v: 100, a: 1 }) },
            ]),
            this.el.setAttribute('aria-valuetext', `Saturation ${kt(e.s)}%, Brightness ${kt(e.v)}%`);
    }
    getMove(e, n) {
        return {
            s: n ? Ti(this.hsva.s + e.x * 100, 0, 100) : e.x * 100,
            v: n ? Ti(this.hsva.v - e.y * 100, 0, 100) : Math.round(100 - e.y * 100),
        };
    }
};
var pS =
    ':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}';
var hS =
    '[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}';
var mS =
    '[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}';
var ku = Symbol('same'),
    Im = Symbol('color'),
    gS = Symbol('hsva'),
    Lm = Symbol('update'),
    bS = Symbol('parts'),
    yS = Symbol('css'),
    ES = Symbol('sliders'),
    Nu = class extends HTMLElement {
        static get observedAttributes() {
            return ['color'];
        }
        get [yS]() {
            return [pS, hS, mS];
        }
        get [ES]() {
            return [Cu, Au];
        }
        get color() {
            return this[Im];
        }
        set color(e) {
            if (!this[ku](e)) {
                let n = this.colorModel.toHsva(e);
                this[Lm](n), (this[Im] = e);
            }
        }
        constructor() {
            super();
            let e = Mu(`<style>${this[yS].join('')}</style>`),
                n = this.attachShadow({ mode: 'open' });
            n.appendChild(e.content.cloneNode(!0)),
                n.addEventListener('move', this),
                (this[bS] = this[ES].map((r) => new r(n)));
        }
        connectedCallback() {
            if (this.hasOwnProperty('color')) {
                let e = this.color;
                delete this.color, (this.color = e);
            } else this.color || (this.color = this.colorModel.defaultColor);
        }
        attributeChangedCallback(e, n, r) {
            let i = this.colorModel.fromAttr(r);
            this[ku](i) || (this.color = i);
        }
        handleEvent(e) {
            let n = this[gS],
                r = { ...n, ...e.detail };
            this[Lm](r);
            let i;
            !Om(r, n) &&
                !this[ku]((i = this.colorModel.fromHsva(r))) &&
                ((this[Im] = i), _a(this, 'color-changed', { value: i }));
        }
        [ku](e) {
            return this.color && this.colorModel.equal(e, this.color);
        }
        [Lm](e) {
            (this[gS] = e), this[bS].forEach((n) => n.update(e));
        }
    };
var FH = {
        defaultColor: '#000',
        toHsva: lS,
        fromHsva: ({ h: t, s: e, v: n }) => cS({ h: t, s: e, v: n, a: 1 }),
        equal: uS,
        fromAttr: (t) => t,
    },
    Ou = class extends Nu {
        get colorModel() {
            return FH;
        }
    };
var xS = Gd(vS(), 1);
customElements.define('tiptap-hex-color-picker', Ou);
var HH = {
        blockquote: [WE],
        bold: [KE],
        'bullet-list': [qE],
        'checked-list': [fh],
        code: [YE],
        'code-block': [im.configure({ lowlight: Le, HTMLAttributes: { class: 'hljs' } })],
        color: [XE],
        details: [Vh, Gh, qh],
        grid: [Fh, Hh],
        'grid-builder': [am, lm],
        heading: [rv.configure({ levels: [1, 2, 3, 4, 5, 6] })],
        highlight: [Qv],
        hr: [cv],
        hurdle: [om],
        italic: [uv],
        lead: [ph],
        link: [
            Dh.configure({ openOnClick: !1, autolink: !1, HTMLAttributes: { rel: null, hreflang: null, class: null } }),
        ],
        media: [Ph.configure({ inline: !0 })],
        oembed: [$h, Wh, Kh],
        'ordered-list': [pv],
        small: [Bh],
        strike: [mv],
        subscript: [gv],
        superscript: [bv],
        table: [qv.configure({ resizable: !0 }), Jv, Yv, Xv],
        underline: [jv],
    },
    zH = window.TiptapEditorExtensions || {},
    wS = { ...HH, ...zH },
    Ru = document.getElementById('activeLocale');
Ru &&
    Ru.addEventListener('change', () => {
        let t = new CustomEvent('locale-change', { bubbles: !0, detail: { locale: Ru.value } });
        Ru.dispatchEvent(t);
    });
document.addEventListener('livewire:navigating', () => {
    window.filamentTiptapEditors = {};
});
document.addEventListener('dblclick', function (t) {
    ((t.target && (t.target.hasAttribute('data-youtube-video') || t.target.hasAttribute('data-vimeo-video'))) ||
        t.target.hasAttribute('data-native-video')) &&
        (t.target.firstChild.style.pointerEvents = 'all');
});
Livewire.on('insertFromAction', (t) => {
    setTimeout(() => {
        let e = new CustomEvent('insert-content', { bubble: !0, detail: t });
        window.dispatchEvent(e);
    }, 100);
});
Livewire.on('insertBlockFromAction', (t) => {
    setTimeout(() => {
        let e = new CustomEvent('insert-block', { bubble: !0, detail: t });
        window.dispatchEvent(e);
    }, 100);
});
Livewire.on('updateBlockFromAction', (t) => {
    setTimeout(() => {
        let e = new CustomEvent('update-block', { bubble: !0, detail: t });
        window.dispatchEvent(e);
    }, 100);
});
function $H({
    state: t,
    statePath: e,
    tools: n = [],
    disabled: r = !1,
    locale: i = 'en',
    floatingMenuTools: o = [],
    placeholder: s = null,
    mergeTags: l = [],
    uploadingMessage: u,
}) {
    let d = null;
    return {
        id: null,
        modalId: null,
        tools: n,
        state: t,
        statePath: e,
        fullScreenMode: !1,
        updatedAt: Date.now(),
        disabled: r,
        locale: i,
        floatingMenuTools: o,
        getExtensions() {
            let f = this.tools.map((m) => (typeof m == 'string' ? m : m.id)),
                h = [
                    ZE,
                    Zv,
                    lc,
                    QE,
                    tv,
                    nv,
                    lv,
                    JE,
                    um,
                    cm,
                    fm,
                    pm,
                    hm.configure({
                        getFileAttachmentUrl: (m) =>
                            this.$wire.mountFormComponentAction(e, 'getFileAttachmentUrl', { fileKey: m }),
                        statePath: e,
                        upload: this.$wire.upload,
                        uploadingMessage: u,
                    }),
                    mm,
                    gm.configure({ statePath: e }),
                ];
            if ((s && !r && h.push(hv.configure({ placeholder: s })), f.length)) {
                let m = Object.keys(wS),
                    b = [],
                    y = ['paragraph'];
                h.push(
                    Bw.configure({
                        element: this.$refs.bubbleMenu,
                        tippyOptions: {
                            duration: [500, 0],
                            maxWidth: 'none',
                            placement: 'top',
                            theme: 'tiptap-editor-bubble',
                            interactive: !0,
                            appendTo: this.$refs.element,
                            zIndex: 10,
                        },
                        shouldShow: ({ state: v, from: x, to: T }) => {
                            if (zr(v, 'link') || zr(v, 'table') || x !== T) return !0;
                            if (
                                zr(v, 'oembed') ||
                                zr(v, 'vimeo') ||
                                zr(v, 'youtube') ||
                                zr(v, 'video') ||
                                zr(v, 'tiptapBlock')
                            )
                                return !1;
                        },
                    }),
                ),
                    this.floatingMenuTools.length &&
                        (h.push(
                            Fw.configure({
                                element: this.$refs.floatingMenu,
                                tippyOptions: {
                                    duration: [500, 0],
                                    maxWidth: 'none',
                                    theme: 'tiptap-editor-bubble',
                                    interactive: !0,
                                    appendTo: this.$refs.element,
                                    zIndex: 10,
                                },
                            }),
                        ),
                        this.floatingMenuTools.forEach((v) => {
                            f.includes(v) || f.push(v);
                        })),
                    f.forEach((v) => {
                        m.includes(v)
                            ? wS[v].forEach((x) => {
                                  ['ordered-list', 'bullet-list', 'checked-list'].includes(v)
                                      ? (h.push(x), h.includes(Np) || h.push(Np))
                                      : h.push(x);
                              })
                            : ['align-left', 'align-right', 'align-center', 'align-justify'].includes(v) &&
                              (v === 'align-left' && b.push('start'),
                              v === 'align-center' && b.push('center'),
                              v === 'align-right' && b.push('end'),
                              v === 'align-justify' && b.push('justify'),
                              f.includes('heading') && y.push('heading'),
                              typeof h.find((T) => T.name === 'textAlign') > 'u' &&
                                  h.push(sm.configure({ types: y, alignments: b })));
                    });
            }
            return l?.length && h.push(dm.configure({ mergeTags: l })), h;
        },
        init: function () {
            this.modalId = this.$el.closest('[x-ref="modalContainer"]')?.getAttribute('wire:key');
            let f = this.$refs.element.querySelector('.tiptap');
            f && (f.remove(), (d = null)), this.initEditor(this.state);
            let h = this.$el.parentElement.closest('[x-sortable]');
            h &&
                (window.Sortable.utils.on(h, 'start', () => {
                    let m = document.querySelectorAll('.tiptap-wrapper');
                    m.length !== 0 &&
                        m.forEach((b) => {
                            b._x_dataStack[0].editor().setEditable(!1),
                                (b._x_dataStack[0].editor().options.element.style.pointerEvents = 'none');
                        });
                }),
                window.Sortable.utils.on(h, 'end', () => {
                    let m = document.querySelectorAll('.tiptap-wrapper');
                    m.length !== 0 &&
                        m.forEach((b) => {
                            b._x_dataStack[0].editor().setEditable(!0),
                                (b._x_dataStack[0].editor().options.element.style.pointerEvents = 'all');
                        });
                })),
                this.$watch('state', (m, b) => {
                    typeof m < 'u' && ((0, xS.isEqual)(b, Alpine.raw(m)) || this.updateEditorContent(m));
                });
        },
        initEditor(f) {
            let h = this;
            d && ((f = d.getJSON()), (d = null)),
                (d = new Jl({
                    element: h.$refs.element,
                    extensions: h.getExtensions(),
                    editable: !h.disabled,
                    content: f,
                    editorProps: {
                        handlePaste(m, b, y) {
                            y.content.descendants((v) => {
                                v.type.name === 'tiptapBlock' &&
                                    ((v.attrs.statePath = h.statePath), (v.attrs.data = JSON.parse(v.attrs.data)));
                            });
                        },
                    },
                    onCreate({ editor: m }) {
                        h.$store.previous &&
                            m.commands.getStatePath() === h.$store.previous.statePath &&
                            (m
                                .chain()
                                .focus()
                                .setContent(h.$store.previous.editor.getJSON())
                                .setTextSelection(h.$store.previous.editor.state.selection)
                                .run(),
                            (h.updatedAt = Date.now()));
                    },
                    onUpdate({ editor: m }) {
                        (h.updatedAt = Date.now()), (h.state = m.isEmpty ? null : m.getJSON());
                    },
                    onSelectionUpdate() {
                        h.updatedAt = Date.now();
                    },
                    onBlur() {
                        h.updatedAt = Date.now();
                    },
                    onFocus() {
                        h.updatedAt = Date.now();
                    },
                }));
        },
        handleOpenModal() {
            this.modalId &&
                this.$nextTick(() => {
                    this.$store.previous = { statePath: this.statePath, editor: d };
                });
        },
        isActive(f, h = {}) {
            return d.isActive(f, h);
        },
        editor() {
            return d;
        },
        blur() {
            let f = this.$el.querySelectorAll('[data-tippy-content]');
            f && f.forEach((h) => h.destroy()), (this.updatedAt = Date.now());
        },
        updateEditorContent(f) {
            if (d.isEditable) {
                let { from: h, to: m } = d.state.selection;
                d.commands.setContent(f, !0), d.chain().focus().setTextSelection({ from: h, to: m }).run();
            }
        },
        refreshEditorContent() {
            this.$nextTick(() => this.updateEditorContent(this.state));
        },
        updateLocale(f) {
            this.locale = f.detail.locale;
        },
        insertContent(f) {
            if (f.detail.statePath === this.statePath)
                switch (f.detail.type) {
                    case 'media':
                        this.insertMedia(f);
                        return;
                    case 'video':
                        this.insertVideo(f);
                        return;
                    case 'link':
                        this.insertLink(f);
                        return;
                    case 'source':
                        this.insertSource(f);
                        return;
                    case 'grid':
                        this.insertGridBuilder(f);
                        return;
                    default:
                        return;
                }
        },
        insertMedia(f) {
            Array.isArray(f.detail.media)
                ? f.detail.media.forEach((h) => {
                      this.executeMediaInsert(h);
                  })
                : this.executeMediaInsert(f.detail.media);
        },
        executeMediaInsert(f = null) {
            if (!(!f || f?.url === null) && f) {
                let h = f?.url || f?.src,
                    m = ['jpg', 'jpeg', 'svg', 'png', 'webp', 'gif'],
                    y = /.*\.([a-zA-Z]*)\??/.exec(h);
                y !== null && m.includes(y[1])
                    ? d
                          .chain()
                          .focus()
                          .setImage({
                              src: h,
                              alt: f?.alt,
                              title: f?.title,
                              width: f?.width,
                              height: f?.height,
                              id: f?.id,
                          })
                          .run()
                    : d.chain().focus().extendMarkRange('link').setLink({ href: h }).insertContent(f?.link_text).run();
            }
        },
        insertVideo(f) {
            let h = f.detail.video;
            if (!h || h.url === null) return;
            let m = {
                src: h.url,
                width: h.responsive ? h.width * 100 : h.width,
                height: h.responsive ? h.height * 100 : h.height,
                responsive: h.responsive ?? !0,
                'data-aspect-width': h.width,
                'data-aspect-height': h.height,
            };
            h.url.includes('youtube') || h.url.includes('youtu.be')
                ? d
                      .chain()
                      .focus()
                      .setYoutubeVideo({
                          ...m,
                          controls: h.youtube_options.includes('controls'),
                          nocookie: h.youtube_options.includes('nocookie'),
                          start: h.start_at ?? 0,
                      })
                      .run()
                : h.url.includes('vimeo')
                  ? d
                        .chain()
                        .focus()
                        .setVimeoVideo({
                            ...m,
                            autoplay: h.vimeo_options.includes('autoplay'),
                            loop: h.vimeo_options.includes('loop'),
                            title: h.vimeo_options.includes('show_title'),
                            byline: h.vimeo_options.includes('byline'),
                            portrait: h.vimeo_options.includes('portrait'),
                        })
                        .run()
                  : d
                        .chain()
                        .focus()
                        .setVideo({
                            ...m,
                            autoplay: h.native_options.includes('autoplay'),
                            loop: h.native_options.includes('loop'),
                            controls: h.native_options.includes('controls'),
                        })
                        .run();
        },
        insertLink(f) {
            let h = f.detail;
            if (!(h.href === null && h.id === null)) {
                if (h.href === '' && h.id === null) {
                    this.unsetLink();
                    return;
                }
                d.chain()
                    .focus()
                    .extendMarkRange('link')
                    .setLink({
                        href: h.href,
                        id: h.id ?? null,
                        target: h.target ?? null,
                        hreflang: h.hreflang ?? null,
                        rel: h.rel ?? null,
                        referrerpolicy: h.referrerpolicy ?? null,
                        as_button: h.as_button ?? null,
                        button_theme: h.button_theme ?? null,
                    })
                    .selectTextblockEnd()
                    .run();
            }
        },
        unsetLink() {
            d.chain().focus().extendMarkRange('link').unsetLink().selectTextblockEnd().run();
        },
        insertSource(f) {
            this.updateEditorContent(f.detail.source);
        },
        insertGridBuilder(f) {
            let h = f.detail.data,
                m = 'responsive',
                b = parseInt(h.asymmetric_left) ?? null,
                y = parseInt(h.asymmetric_right) ?? null;
            h.fixed && (m = 'fixed'),
                h.asymmetric && (m = 'asymmetric'),
                d
                    .chain()
                    .focus()
                    .insertGridBuilder({
                        cols: h.columns,
                        type: m,
                        stackAt: h.stack_at,
                        asymmetricLeft: b,
                        asymmetricRight: y,
                    })
                    .run();
        },
        insertBlock(f) {
            f.detail.statePath === this.statePath &&
                (d.commands.insertBlock({
                    type: f.detail.type,
                    statePath: f.detail.statePath,
                    data: f.detail.data,
                    preview: f.detail.preview,
                    label: f.detail.label,
                    coordinates: f.detail.coordinates,
                }),
                d.isFocused || d.commands.focus());
        },
        insertMergeTag(f) {
            d.commands.insertMergeTag({ tag: f.detail.tag, coordinates: f.detail.coordinates }),
                d.isFocused || d.commands.focus();
        },
        openBlockSettings(f) {
            f.detail.statePath === this.statePath &&
                this.$wire.dispatchFormEvent('tiptap::updateBlock', this.statePath, f.detail);
        },
        updateBlock(f) {
            f.detail.statePath === this.statePath &&
                (d.commands.updateBlock({
                    type: f.detail.type,
                    statePath: f.detail.statePath,
                    data: f.detail.data,
                    preview: f.detail.preview,
                    label: f.detail.label,
                }),
                d.isFocused || d.commands.focus());
        },
        deleteBlock() {
            d.commands.removeBlock();
        },
    };
}
export { $H as default };
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
