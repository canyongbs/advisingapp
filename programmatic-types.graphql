# File generated by "php artisan lighthouse:ide-helper".
# Do not edit this file directly.
# This file should be ignored by git as it can be autogenerated.

enum AlertSeverity {
  Low
  Medium
  High
}

enum SystemAlertStatusClassification {
  Active
  Resolved
  Canceled
}

enum ConsentAgreementType {
  AzureOpenAI
}

enum NotificationChannel {
  Email
  Sms
  Database
}

enum NotificationDeliveryStatus {
  Processing
  Dispatched
  DispatchFailed
  RateLimited
  BlockedByDemoMode
  Failed
  Successful
}

enum InteractionStatusColorOptions {
  Success
  Danger
  Warning
  Info
  Primary
  Gray
}

enum ProspectStatusColorOptions {
  Success
  Danger
  Warning
  Info
  Primary
  Gray
}

enum SystemProspectClassification {
  New
  Assigned
  InProgress
  Converted
  Recycled
  NotInterested
  Custom
}

"""
The `String` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar String

"""
The `ID` scalar type represents a unique identifier, often used to
refetch an object or as key for a cache. The ID type appears in a JSON
response as a String; however, it is not intended to be human-readable.
When expected as an input type, any string (such as `"4"`) or integer
(such as `4`) input value will be accepted as an ID.
"""
scalar ID

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

"""
The `Int` scalar type represents non-fractional signed whole numeric
values. Int can represent values between -(2^31) and 2^31 - 1. 
"""
scalar Int

"""
The `Float` scalar type represents signed double-precision fractional
values as specified by
[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
"""
scalar Float

type AlertStatus {
  "Unique primary key."
  id: UUID!

  "The Classification of the alert status."
  classification: SystemAlertStatusClassification!

  "The name of the alert status."
  name: String!

  "The order of the alert status."
  order: Int!

  "Whether or not the alert status is the default."
  is_default: Boolean!

  "The created datetime of the alert."
  created_at: DateTime

  "The updated datetime of the alert."
  updated_at: DateTime

  "The deleted datetime of the alert."
  deleted_at: DateTime
}

input AlertStatusesQuery {
  id: UUID
  classification: SystemAlertStatusClassification
  name: String
  order: Int
  is_default: Boolean
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
}

type AlertStatusQueries {
  "Find a single alert status by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): AlertStatus

  "List multiple alert statuses."
  list(
    where: SearchByRootAlertStatusesQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): AlertStatusPaginator!
}

input CreateAlertStatusInput {
  "The name of the alert status."
  name: String!

  "The classification of the alert status."
  classification: SystemAlertStatusClassification!
}

input UpdateAlertStatusInput {
  "The name of the alert status."
  name: String!

  "The classification of the alert status."
  classification: SystemAlertStatusClassification!
}

type AlertStatusMutations {
  "Create an alert status."
  create(input: CreateAlertStatusInput!): AlertStatus!

  "Update an existing alert status."
  update(
    "The identifier of the alert status you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateAlertStatusInput!
  ): AlertStatus!

  "Delete an existing alert status."
  delete(
    "The identifier of the alert status you would like to delete."
    id: UUID!
  ): AlertStatus
}

type Alert {
  "Unique primary key."
  id: UUID!

  "The Concern of the alert."
  concern: Educatable!

  "The description of the alert."
  description: String!

  "The severity of the alert."
  severity: AlertSeverity!

  "The status of the alert."
  status: AlertStatus!

  "The suggested intervention for the alert."
  suggested_intervention: String!

  "The created datetime of the alert."
  created_at: DateTime

  "The updated datetime of the alert."
  updated_at: DateTime

  "The deleted datetime of the alert."
  deleted_at: DateTime
}

input AlertConcernsQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
}

input AlertsQuery {
  id: UUID
  concern: AlertConcernsQuery
  concern_id: EducatableId
  concern_type: EducatableType
  description: String
  severity: AlertSeverity
  status: AlertStatusesQuery
  suggested_intervention: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
}

type AlertQueries {
  "Find a single alert by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): Alert

  "List multiple alerts."
  list(
    where: SearchByRootAlertsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): AlertPaginator!
}

input CreateAlertInput {
  "The Concern related to the alert."
  concern_id: EducatableId!

  "The type of Concern related to the alert."
  concern_type: EducatableType!

  "The description of the alert."
  description: String!

  "The severity of the alert."
  severity: AlertSeverity!

  "The status of the alert."
  status_id: UUID!

  "The suggested intervention for the alert."
  suggested_intervention: String!
}

input UpdateAlertInput {
  "The description of the alert."
  description: String

  "The severity of the alert."
  severity: AlertSeverity

  "The status of the alert."
  status_id: UUID

  "The suggested intervention for the alert."
  suggested_intervention: String
}

type AlertMutations {
  "Create an alert."
  create(input: CreateAlertInput!): Alert!

  "Update an alert."
  update(
    "The identifier of the alert you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateAlertInput!
  ): Alert!

  "Delete an alert."
  delete(
    "The identifier of the alert you would like to delete."
    id: UUID!
  ): Alert
}

union Auditable = Student | Prospect | User | SystemUser | ConsentAgreement | UserConsentAgreement | Engagement

input AuditableablesQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
  user: UsersQuery
  system_user: SystemUsersQuery
  consent_agreement: ConsentAgreementsQuery
  user_consent_agreement: UserConsentAgreementsQuery
  engagement: EngagementsQuery
}

type Audit {
  "Unique primary key."
  id: UUID!

  change_agent_type: String
  change_agent_id: UUID
  event: String!
  old_values: JSON
  new_values: JSON
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
  auditable: Auditable
  user: Authenticatable
}

input AuthenticatablesQuery {
  user: UsersQuery
  system_user: SystemUsersQuery
}

input AuditsQuery {
  id: UUID
  change_agent_type: String
  change_agent_id: UUID
  event: String
  old_values: JSON
  new_values: JSON
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
  auditable: AuditableablesQuery
  user: AuthenticatablesQuery
}

type AuditQueries {
  find(id: UUID!): Audit
  list(
    where: SearchByRootAuditsQuery
    order: [SortByRootAuditsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): AuditPaginator!
}

type CareTeam {
  "Unique primary key."
  id: UUID!

  "The User related to this care team assignment."
  user: User!

  "The Educatable in the user's care team."
  educatable: Educatable!

  "The created datetime of the care team assignment."
  created_at: DateTime

  "The updated datetime of the care team assignment."
  updated_at: DateTime
}

input CareTeamEducatablesQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
}

input CareTeamsQuery {
  id: UUID
  user: UsersQuery
  educatable: CareTeamEducatablesQuery
  educatable_id: EducatableId
  educatable_type: EducatableType
  created_at: DateTime
  updated_at: DateTime
}

type CareTeamQueries {
  "Find a single care team by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): CareTeam

  "List multiple care team assignments."
  list(
    where: SearchByRootCareTeamsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): CareTeamPaginator!
}

input CreateCareTeamInput {
  "The User to add to the Care Team of."
  user_id: UUID!

  "The Educatable to add to the care team."
  educatable_id: EducatableId!

  "The type of Educatable to add to the care team."
  educatable_type: EducatableType!
}

type CareTeamMutations {
  "Assign a User to a Care Team."
  assign(input: CreateCareTeamInput!): CareTeam!

  "Remove a User from a Care Team."
  remove(
    "The primary key of the care team assignment."
    id: UUID!
  ): CareTeam
}

type CaseModel {
  "Unique primary key."
  id: UUID!
}

input CaseModelQuery {
  "Unique primary key."
  id: UUID
}

type CaseAssignment {
  "Unique primary key."
  id: UUID!

  "The case of the assignment."
  case: CaseModel

  "The user of the assignment."
  user: User

  "The created datetime of the assignment."
  created_at: DateTime

  "The updated datetime of the assignment."
  updated_at: DateTime
}

type ConsentAgreement {
  id: UUID!
  type: ConsentAgreementType!
  title: String!
  description: String!
  body: String!
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  audits: [Audit!]
  audits_count: Int
  user_consent_agreements: [UserConsentAgreement!]
  user_consent_agreements_count: Int
  users: [User!]!
  users_count: Int
}

input ConsentAgreementsQuery {
  id: UUID
  type: ConsentAgreementType
  title: String
  description: String
  body: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  user_consent_agreements: UserConsentAgreementsQuery
  users: UsersQuery
  audits: AuditsQuery
}

type ConsentAgreementQueries {
  "Get a specific consent agreement by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ConsentAgreement

  "List multiple consent agreements."
  list(
    "Filter by the consent agreements attributes and relations."
    where: SearchByRootConsentAgreementsQuery

    order: [SortByRootConsentAgreementsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ConsentAgreementPaginator!
}

input UpdateConsentAgreementInput {
  "The title of the consent agreement."
  title: String

  "The description of the consent agreement."
  description: String

  "The body of the consent agreement."
  body: String
  users: UpdateUserConsentAgreementBelongsToManyInput
}

input UpdateUserConsentAgreementBelongsToManyInput {
  consent: [UUID!]
}

type ConsentAgreementMutations {
  "Update an existing consent agreement."
  update(
    "The identifier of the consent agreement you would like to update."
    id: UUID!

    "The attributes to update a consent agreement."
    input: UpdateConsentAgreementInput!
  ): ConsentAgreement!

  "Consent a user to a consent agreement."
  consent(id: UUID!, user_id: UUID!): ConsentAgreement!
}

type UserConsentAgreement {
  id: UUID!
  ip_address: String!
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  user: User!
  consent_agreement: ConsentAgreement!
  audits: [Audit!]
  audits_count: Int
}

input UserConsentAgreementsQuery {
  id: UUID
  ip_address: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  user: UsersQuery
  consent_agreement: ConsentAgreementsQuery
  audits: AuditsQuery
}

type UserConsentAgreementQueries {
  "Get a specific user consent agreement by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): UserConsentAgreement

  "List multiple user consent agreements."
  list(
    "Filter by the user consent agreements attributes and relations."
    where: SearchByRootUserConsentAgreementsQuery

    order: [SortByRootUserConsentAgreementsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): UserConsentAgreementPaginator!
}

type Division {
  "Unique primary key."
  id: UUID!

  "The name of the division."
  name: String!
}

input DivisionQuery {
  "The name of the division."
  name: String
}

type Engagement {
  id: UUID!
  subject: String
  body: String
  scheduled_at: DateTime!
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  recipient: Educatable!
  created_by: User
  audits: [Audit!]
  audits_count: Int
}

input EngagementRecipientsQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
}

input EngagementsQuery {
  id: UUID
  subject: JSON
  body: JSON
  scheduled_at: DateTime
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  recipient: EngagementRecipientsQuery
  created_by: UsersQuery
  audits: AuditsQuery
}

type EngagementQueries {
  find(id: UUID!): Engagement
  list(
    where: SearchByRootEngagementsQuery
    order: [SortByRootEngagementsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): EngagementPaginator!
}

input CreateEngagementSMSInput {
  body: String!
  scheduled_at: DateTime
  recipient_id: EducatableId!
  recipient_type: EducatableType!
  user_id: UUID!
}

input CreateEngagementEmailInput {
  subject: String!
  body: String!
  scheduled_at: DateTime
  recipient_id: EducatableId!
  recipient_type: EducatableType!
  user_id: UUID!
}

input UpdateEngagementSMSInput {
  body: String
  scheduled_at: DateTime
}

input UpdateEngagementEmailInput {
  subject: String
  body: String
  scheduled_at: DateTime
}

type EngagementMutations {
  sendSms(input: CreateEngagementSMSInput!): Engagement!
  updateSms(id: UUID!, input: UpdateEngagementSMSInput!): Engagement
  sendEmail(input: CreateEngagementEmailInput!): Engagement!
  updateEmail(id: UUID!, input: UpdateEngagementEmailInput!): Engagement
  delete(id: UUID!): Engagement
}

union Interactable = Student | Prospect | CaseModel

enum InteractableType {
  Student
  Prospect
  CaseModel
}

"The `InteractableId` scalar type represents a unique identifier of an interactable entity. Due to the differences between some of the educatable entities, the type of the identifier may vary. A Prospect has a UUID, a Student has a sisid, which can be an integer, string, or UUID, and a Service Request has a UUID."
scalar InteractableId

type Interaction {
  "Unique primary key."
  id: UUID!

  "The subject of the interaction."
  subject: String!

  "The description of the interaction."
  description: String!

  "The User related to the interaction."
  user: User

  "The Interactable related to the interaction."
  interactable: Interactable

  "The type of interaction."
  type: InteractionType

  "The relation of the interaction."
  relation: InteractionRelation

  "The driver of the interaction."
  driver: InteractionDriver

  "The initiative of the interaction."
  initiative: InteractionInitiative

  "The status of the interaction."
  status: InteractionStatus

  "The outcome of the interaction."
  outcome: InteractionOutcome

  "The division of the interaction."
  division: Division

  "The start datetime of the interaction."
  start_datetime: DateTime!

  "The end datetime of the interaction."
  end_datetime: DateTime

  "The created datetime of the interaction."
  created_at: DateTime

  "The updated datetime of the interaction."
  updated_at: DateTime
}

input InteractionInteractablesQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
  caseModel: CaseModelQuery
}

input InteractionsQuery {
  id: UUID
  subject: String
  description: String
  user: UsersQuery
  interactable: InteractionInteractablesQuery
  interactable_id: InteractableId
  interactable_type: InteractableType
  relation: InteractionRelationQuery
  driver: InteractionDriverQuery
  initiative: InteractionInitiativeQuery
  status: InteractionStatusesQuery
  outcome: InteractionOutcomeQuery
  division: DivisionQuery
  start_datetime: DateTime
  end_datetime: DateTime
  created_at: DateTime
  updated_at: DateTime
}

type InteractionQueries {
  "Find a single interaction by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): Interaction

  "List multiple interactions."
  list(
    where: SearchByRootInteractionsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): InteractionPaginator!
}

input CreateInteractionInput {
  "The subject of the interaction."
  subject: String!

  "The description of the interaction."
  description: String!

  "The User related to the interaction."
  user_id: UUID!

  "The Interactable related to the interaction."
  interactable_id: InteractableId!

  "The type of Interactable related to the interaction."
  interactable_type: InteractableType!

  "The type of interaction."
  interaction_type_id: UUID!

  "The relation of the interaction."
  interaction_relation_id: UUID!

  "The driver of the interaction."
  interaction_driver_id: UUID!

  "The initiative of the interaction."
  interaction_initiative_id: UUID!

  "The status of the interaction."
  interaction_status_id: UUID!

  "The outcome of the interaction."
  interaction_outcome_id: UUID!

  "The division of the interaction."
  division_id: UUID!

  "The start datetime of the interaction."
  start_datetime: DateTime!

  "The end datetime of the interaction."
  end_datetime: DateTime
}

input UpdateInteractionInput {
  "The subject of the interaction."
  subject: String

  "The description of the interaction."
  description: String

  "The User related to the interaction."
  user_id: UUID

  "The Interactable related to the interaction."
  interactable_id: InteractableId

  "The type of Interactable related to the interaction."
  interactable_type: InteractableType

  "The type of interaction."
  interaction_type_id: UUID

  "The relation of the interaction."
  interaction_relation_id: UUID

  "The driver of the interaction."
  interaction_driver_id: UUID

  "The initiative of the interaction."
  interaction_initiative_id: UUID

  "The status of the interaction."
  interaction_status_id: UUID

  "The outcome of the interaction."
  interaction_outcome_id: UUID

  "The division of the interaction."
  division_id: UUID

  "The start datetime of the interaction."
  start_datetime: DateTime

  "The end datetime of the interaction."
  end_datetime: DateTime
}

type InteractionMutations {
  "Create an interaction."
  create(input: CreateInteractionInput!): Interaction!

  "Update an interaction."
  update(
    "The identifier of the interaction you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionInput!
  ): Interaction!

  "Delete an interaction."
  delete(
    "The identifier of the interaction you would like to delete."
    id: UUID!
  ): Interaction
}

type InteractionInitiative {
  "Unique primary key."
  id: UUID!

  "The name of the interaction initiative."
  name: String!

  "Interactions related to this interaction initiative."
  interactions: [Interaction!]

  "The created date of the interaction initiative."
  created_at: DateTime

  "The updated date of the interaction initiative."
  updated_at: DateTime

  "The deleted date of the interaction initiative."
  deleted_at: DateTime
}

input InteractionInitiativeQuery {
  "The unique primary key of the interaction initiative."
  id: UUID

  "The name of the interaction relation."
  name: String

  "The interactions related to this interaction initiative."
  interactions: InteractionsQuery

  "The created date of the interaction initiative."
  created_at: DateTime

  "The updated date of the interaction initiative."
  updated_at: DateTime

  "The deleted date of the interaction initiative."
  deleted_at: DateTime
}

type InteractionInitiativeQueries {
  "Get a specific interaction initiative by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionInitiative

  "List multiple interactions initiatives."
  list(
    "Filter by the interaction initiatives attributes and relations."
    where: SearchByRootInteractionInitiativeQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionInitiativePaginator!
}

input CreateInteractionInitiativeInput {
  "The name of the interaction initiative."
  name: String!
}

input UpdateInteractionInitiativeInput {
  "The name of the interaction initiative."
  name: String
}

type InteractionInitiativeMutations {
  "Create an interaction initiative."
  create(input: CreateInteractionInitiativeInput!): InteractionInitiative!

  "Update an existing interaction initiative."
  update(
    "The identifier of the interaction initiative you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionInitiativeInput!
  ): InteractionInitiative!

  "Delete an existing interaction initiative."
  delete(
    "The identifier of the interaction initiative you would like to delete."
    id: UUID!
  ): InteractionInitiative
}

type InteractionDriver {
  "Unique primary key."
  id: UUID!

  "The name of the interaction driver."
  name: String!

  "Interactions related to this interaction driver."
  interactions: [Interaction!]

  "The created date of the interaction driver."
  created_at: DateTime

  "The updated date of the interaction driver."
  updated_at: DateTime

  "The deleted date of the interaction driver."
  deleted_at: DateTime
}

input InteractionDriverQuery {
  "The unique primary key of the interaction driver."
  id: UUID

  "The name of the interaction driver."
  name: String

  "The interactions related to this interaction driver."
  interactions: InteractionsQuery

  "The created date of the interaction driver."
  created_at: DateTime

  "The updated date of the interaction driver."
  updated_at: DateTime

  "The deleted date of the interaction driver."
  deleted_at: DateTime
}

type InteractionDriverQueries {
  "Get a specific interaction driver by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionDriver

  "List multiple interactions drivers."
  list(
    "Filter by the interaction drivers attributes and relations."
    where: SearchByRootInteractionDriverQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionDriverPaginator!
}

input CreateInteractionDriverInput {
  "The name of the interaction driver."
  name: String!
}

input UpdateInteractionDriverInput {
  "The name of the interaction driver."
  name: String
}

type InteractionDriverMutations {
  "Create an interaction driver."
  create(input: CreateInteractionDriverInput!): InteractionDriver!

  "Update an existing interaction driver."
  update(
    "The identifier of the interaction driver you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionDriverInput!
  ): InteractionDriver!

  "Delete an existing interaction driver."
  delete(
    "The identifier of the interaction driver you would like to delete."
    id: UUID!
  ): InteractionDriver
}

type InteractionOutcome {
  "Unique primary key."
  id: UUID!

  "The name of the interaction outcome."
  name: String!

  "Interactions related to this interaction outcome."
  interactions: [Interaction!]

  "The created date of the interaction outcome."
  created_at: DateTime

  "The updated date of the interaction outcome."
  updated_at: DateTime

  "The deleted date of the interaction outcome."
  deleted_at: DateTime
}

input InteractionOutcomeQuery {
  "The unique primary key of the interaction outcome."
  id: UUID

  "The name of the interaction outcome."
  name: String

  "The interactions related to this interaction outcome."
  interactions: InteractionsQuery

  "The created date of the interaction outcome."
  created_at: DateTime

  "The updated date of the interaction outcome."
  updated_at: DateTime

  "The deleted date of the interaction outcome."
  deleted_at: DateTime
}

type InteractionOutcomeQueries {
  "Get a specific interaction outcome by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionOutcome

  "List multiple interactions outcomes."
  list(
    "Filter by the interaction outcomes attributes and relations."
    where: SearchByRootInteractionOutcomeQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionOutcomePaginator!
}

input CreateInteractionOutcomeInput {
  "The name of the interaction outcome."
  name: String!
}

input UpdateInteractionOutcomeInput {
  "The name of the interaction outcome."
  name: String
}

type InteractionOutcomeMutations {
  "Create an interaction outcome."
  create(input: CreateInteractionOutcomeInput!): InteractionOutcome!

  "Update an existing interaction outcome."
  update(
    "The identifier of the interaction outcome you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionOutcomeInput!
  ): InteractionOutcome!

  "Delete an existing interaction outcome."
  delete(
    "The identifier of the interaction outcome you would like to delete."
    id: UUID!
  ): InteractionOutcome
}

type InteractionRelation {
  "Unique primary key."
  id: UUID!

  "The name of the interaction relation."
  name: String!

  "Interactions related to this interaction relation."
  interactions: [Interaction!]

  "The created date of the interaction relation."
  created_at: DateTime

  "The updated date of the interaction relation."
  updated_at: DateTime

  "The deleted date of the interaction relation."
  deleted_at: DateTime
}

input InteractionRelationQuery {
  "The unique primary key of the interaction relation."
  id: UUID

  "The name of the interaction relation."
  name: String

  "The interactions related to this interaction relation."
  interactions: InteractionsQuery

  "The created date of the interaction relation."
  created_at: DateTime

  "The updated date of the interaction relation."
  updated_at: DateTime

  "The deleted date of the interaction relation."
  deleted_at: DateTime
}

type InteractionRelationQueries {
  "Get a specific interaction relation by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionRelation

  "List multiple interactions relations."
  list(
    "Filter by the interaction relations attributes and relations."
    where: SearchByRootInteractionRelationQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionRelationPaginator!
}

input CreateInteractionRelationInput {
  "The name of the interaction relation."
  name: String!
}

input UpdateInteractionRelationInput {
  "The name of the interaction relation."
  name: String
}

type InteractionRelationMutations {
  "Create an interaction relation."
  create(input: CreateInteractionRelationInput!): InteractionRelation!

  "Update an existing interaction relation."
  update(
    "The identifier of the interaction relation you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionRelationInput!
  ): InteractionRelation!

  "Delete an existing interaction relation."
  delete(
    "The identifier of the interaction relation you would like to delete."
    id: UUID!
  ): InteractionRelation
}

type InteractionStatus {
  "Unique primary key."
  id: UUID!

  "The name of the interaction status."
  name: String!

  "Interactions related to this interaction status."
  interactions: [Interaction!]

  "The color of the interaction status."
  color: InteractionStatusColorOptions!

  "The created date of the interaction status."
  created_at: DateTime

  "The updated date of the interaction status."
  updated_at: DateTime

  "The deleted date of the interaction status."
  deleted_at: DateTime
}

input InteractionStatusesQuery {
  "The unique primary key of the interaction status."
  id: UUID

  "The name of the interaction status."
  name: String

  "The color of the interaction status."
  color: InteractionStatusColorOptions

  "The interactions related to this interaction status."
  interactions: InteractionsQuery

  "The created date of the interaction status."
  created_at: DateTime

  "The updated date of the interaction status."
  updated_at: DateTime

  "The deleted date of the interaction status."
  deleted_at: DateTime
}

type InteractionStatusQueries {
  "Get a specific interaction status by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionStatus

  "List multiple interactions statuses."
  list(
    "Filter by the interaction statuses attributes and relations."
    where: SearchByRootInteractionStatusesQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionStatusPaginator!
}

input CreateInteractionStatusInput {
  "The name of the interaction status."
  name: String!

  "The color of the interaction status."
  color: InteractionStatusColorOptions!
}

input UpdateInteractionStatusInput {
  "The name of the interaction status."
  name: String

  "The color of the interaction status."
  color: InteractionStatusColorOptions
}

type InteractionStatusMutations {
  "Create an interaction status."
  create(input: CreateInteractionStatusInput!): InteractionStatus!

  "Update an existing interaction status."
  update(
    "The identifier of the interaction status you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionStatusInput!
  ): InteractionStatus!

  "Delete an existing interaction status."
  delete(
    "The identifier of the interaction status you would like to delete."
    id: UUID!
  ): InteractionStatus
}

type InteractionType {
  "Unique primary key."
  id: UUID!

  "The name of the interaction type."
  name: String!

  "Interactions related to this interaction type."
  interactions: [Interaction!]

  "The created date of the interaction type."
  created_at: DateTime

  "The updated date of the interaction type."
  updated_at: DateTime

  "The deleted date of the interaction type."
  deleted_at: DateTime
}

input InteractionTypeQuery {
  "The unique primary key of the interaction type."
  id: UUID

  "The name of the interaction relation."
  name: String

  "The interactions related to this interaction type."
  interactions: InteractionsQuery

  "The created date of the interaction type."
  created_at: DateTime

  "The updated date of the interaction type."
  updated_at: DateTime

  "The deleted date of the interaction type."
  deleted_at: DateTime
}

type InteractionTypeQueries {
  "Get a specific interaction type by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionType

  "List multiple interactions types."
  list(
    "Filter by the interaction types attributes and relations."
    where: SearchByRootInteractionTypeQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): InteractionTypePaginator!
}

input CreateInteractionTypeInput {
  "The name of the interaction type."
  name: String!
}

input UpdateInteractionTypeInput {
  "The name of the interaction type."
  name: String
}

type InteractionTypeMutations {
  "Create an interaction type."
  create(input: CreateInteractionTypeInput!): InteractionType!

  "Update an existing interaction type."
  update(
    "The identifier of the interaction type you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateInteractionTypeInput!
  ): InteractionType!

  "Delete an existing interaction type."
  delete(
    "The identifier of the interaction type you would like to delete."
    id: UUID!
  ): InteractionType
}

type UserSubscription {
  "Unique primary key."
  id: UUID!

  "The User related to this subscription."
  user: User!

  "The Subscribable the User is subscribed to."
  subscribable: Educatable!

  "The created date of the subscription."
  created_at: DateTime

  "The updated date of the subscription."
  updated_at: DateTime
}

input UserSubscriptionSubscribablesQuery {
  student: StudentsQuery
  prospect: ProspectsQuery
}

input SubscriptionsQuery {
  id: UUID
  user: UsersQuery
  subscribable: UserSubscriptionSubscribablesQuery
  subscribable_id: EducatableId
  subscribable_type: EducatableType
  created_at: DateTime
  updated_at: DateTime
}

type UserSubscriptionQueries {
  "Find a single subscription by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): UserSubscription

  "List multiple subscriptions."
  list(
    where: SearchByRootSubscriptionsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): UserSubscriptionPaginator!
}

input CreateUserSubscriptionInput {
  "The user to subscribe."
  user_id: UUID!

  "The subscribable to subscribe to."
  subscribable_id: EducatableId!

  "The type of subscribable to subscribe to."
  subscribable_type: EducatableType!
}

type UserSubscriptionMutations {
  "Subscribe a User to a Subscribable."
  subscribe(input: CreateUserSubscriptionInput!): UserSubscription!

  "Unsubscribe a User from a Subscribable."
  unsubscribe(
    "The primary key of the subscription."
    id: UUID!
  ): UserSubscription
}

type ProspectSource {
  "Unique primary key."
  id: UUID!

  "The name of the prospect source."
  name: String!

  "The created date of the prospect source."
  created_at: DateTime

  "The updated date of the prospect source."
  updated_at: DateTime

  "The deleted date of the prospect source."
  deleted_at: DateTime

  "Prospects related to this prospect source."
  prospects: [Prospect!]

  "The count of prospects related to this prospect source."
  prospects_count: Int

  "The audits related to this prospect source."
  audits: [Audit!]

  "The count of audits related to this prospect source."
  audits_count: Int
}

input ProspectSourcesQuery {
  "The unique primary key of the prospect source."
  id: UUID

  "The name of the prospect source."
  name: String

  "The created date of the prospect source."
  created_at: DateTime

  "The updated date of the prospect source."
  updated_at: DateTime

  "The deleted date of the prospect source."
  deleted_at: DateTime

  "The prospects related to this prospect source."
  prospects: ProspectsQuery

  "The audits related to this prospect source."
  audits: AuditsQuery
}

type ProspectSourceQueries {
  "Get a specific prospect source by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ProspectSource

  "List multiple prospect sources."
  list(
    "Filter by the prospect sources attributes and relations."
    where: SearchByRootProspectSourcesQuery

    order: [SortByRootProspectSourcesQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ProspectSourcePaginator!
}

input CreateProspectSourceInput {
  "The name of the prospect source."
  name: String!
}

input UpdateProspectSourceInput {
  "The name of the prospect source."
  name: String
}

type ProspectSourceMutations {
  "Create an prospect source."
  create(input: CreateProspectSourceInput!): ProspectSource!

  "Update an existing prospect source."
  update(
    "The identifier of the prospect source you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateProspectSourceInput!
  ): ProspectSource!

  "Delete an existing prospect source."
  delete(
    "The identifier of the prospect source you would like to delete."
    id: UUID!
  ): ProspectSource
}

type ProspectStatus {
  "Unique primary key."
  id: UUID!

  "The name of the prospect status."
  name: String!

  "The classification of the prospect status."
  classification: SystemProspectClassification!

  "The color of the prospect status."
  color: ProspectStatusColorOptions!

  "The created date of the prospect status."
  created_at: DateTime

  "The updated date of the prospect status."
  updated_at: DateTime

  "The deleted date of the prospect status."
  deleted_at: DateTime

  "Prospects related to this prospect status."
  prospects: [Prospect!]

  "The count of prospects related to this prospect status."
  prospects_count: Int

  "The audits related to this prospect status."
  audits: [Audit!]

  "The count of audits related to this prospect status."
  audits_count: Int
}

input ProspectStatusesQuery {
  "The unique primary key of the prospect status."
  id: UUID

  "The name of the prospect status."
  name: String

  "The classification of the prospect status."
  classification: SystemProspectClassification

  "The color of the prospect status."
  color: ProspectStatusColorOptions

  "The created date of the prospect status."
  created_at: DateTime

  "The updated date of the prospect status."
  updated_at: DateTime

  "The deleted date of the prospect status."
  deleted_at: DateTime

  "The prospects related to this prospect status."
  prospects: ProspectsQuery

  "The audits related to this prospect status."
  audits: AuditsQuery
}

type ProspectStatusQueries {
  "Get a specific prospect status by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ProspectStatus

  "List multiple prospects statuses."
  list(
    "Filter by the prospect statuses attributes and relations."
    where: SearchByRootProspectStatusesQuery

    order: [SortByRootProspectStatusesQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ProspectStatusPaginator!
}

input CreateProspectStatusInput {
  "The name of the prospect status."
  name: String!

  "The classification of the prospect status."
  classification: SystemProspectClassification!

  "The color of the prospect status."
  color: ProspectStatusColorOptions!
}

input UpdateProspectStatusInput {
  "The name of the prospect status."
  name: String

  "The classification of the prospect status."
  classification: SystemProspectClassification

  "The color of the prospect status."
  color: ProspectStatusColorOptions
}

type ProspectStatusMutations {
  "Create an prospect status."
  create(input: CreateProspectStatusInput!): ProspectStatus!

  "Update an existing prospect status."
  update(
    "The identifier of the prospect status you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateProspectStatusInput!
  ): ProspectStatus!

  "Delete an existing prospect status."
  delete(
    "The identifier of the prospect status you would like to delete."
    id: UUID!
  ): ProspectStatus
}

type Prospect {
  "Unique primary key."
  id: UUID!

  "The status of the prospect."
  status: ProspectStatus!

  "The source of the prospect."
  source: ProspectSource!

  "The first name of the prospect."
  first_name: String

  "The last name of the prospect."
  last_name: String

  "The full name of the prospect."
  full_name: String

  "The preferred name of the prospect."
  preferred: String

  "The display name of the prospect."
  display_name: String

  "The description of the prospect."
  description: String

  "The email of the prospect."
  email: Email

  "The email 2 of the prospect."
  email_2: Email

  "The mobile number of the prospect."
  mobile: String

  "The phone number of the prospect."
  phone: String

  "If the prospect is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the prospect's email bounces."
  email_bounce: Boolean

  "The address of the prospect."
  address: String

  "The address 2 of the prospect."
  address_2: String

  "The address 3 of the prospect."
  address_3: String

  "The city of the prospect."
  city: String

  "The state of the prospect."
  state: String

  "The postal code of the prospect."
  postal: String

  "The birthdate of the prospect."
  birthdate: Date

  "The High School graduation year of the prospect."
  hsgrad: Year

  "The created date of the prospect."
  created_at: DateTime

  "The updated date of the prospect."
  updated_at: DateTime

  "The deleted date of the prospect."
  deleted_at: DateTime

  audits: [Audit!]
  audits_count: Int
  created_by: User
}

input ProspectsQuery {
  "Unique primary key."
  id: UUID

  "The status ID of the prospect."
  status_id: UUID

  "The status of the prospect."
  status: ProspectStatusesQuery

  "The source ID of the prospect."
  source_id: UUID

  "The source of the prospect."
  source: ProspectSourcesQuery

  "The first name of the prospect."
  first_name: String

  "The last name of the prospect."
  last_name: String

  "The full name of the prospect."
  full_name: String

  "The preferred name of the prospect."
  preferred: String

  "The description of the prospect."
  description: String

  "The email of the prospect."
  email: Email

  "The email 2 of the prospect."
  email_2: Email

  "The mobile number of the prospect."
  mobile: String

  "The phone number of the prospect."
  phone: String

  "If the prospect is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the prospect's email bounces."
  email_bounce: Boolean

  "The address of the prospect."
  address: String

  "The address 2 of the prospect."
  address_2: String

  "The address 3 of the prospect."
  address_3: String

  "The city of the prospect."
  city: String

  "The state of the prospect."
  state: String

  "The postal code of the prospect."
  postal: String

  "The birthdate of the prospect."
  birthdate: Date

  "The High School graduation year of the prospect."
  hsgrad: String

  "The created date of the prospect."
  created_at: DateTime

  "The updated date of the prospect."
  updated_at: DateTime

  "The deleted date of the prospect."
  deleted_at: DateTime
  audits: AuditsQuery
  created_by: UsersQuery
}

type ProspectQueries {
  "Find a single prospect by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): Prospect

  "List multiple prospects."
  list(
    where: SearchByRootProspectsQuery
    order: [SortByRootProspectsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): ProspectPaginator!
}

input CreateProspectInput {
  "The status of the prospect."
  status_id: UUID!

  "The source of the prospect."
  source_id: UUID!

  "The first name of the prospect."
  first_name: String!

  "The last name of the prospect."
  last_name: String!

  "The full name of the prospect."
  full_name: String!

  "The preferred name of the prospect."
  preferred: String

  "The description of the prospect."
  description: String

  "The email of the prospect."
  email: Email

  "The email 2 of the prospect."
  email_2: Email

  "The mobile number of the prospect."
  mobile: String

  "The phone number of the prospect."
  phone: String

  "If the prospect is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the prospect's email bounces."
  email_bounce: Boolean

  "The address of the prospect."
  address: String

  "The address 2 of the prospect."
  address_2: String

  "The address 3 of the prospect."
  address_3: String

  "The city of the prospect."
  city: String

  "The state of the prospect."
  state: String

  "The postal code of the prospect."
  postal: String

  "The birthdate of the prospect."
  birthdate: Date

  "The High School graduation year of the prospect."
  hsgrad: Year

  "The user that created the prospect."
  created_by_id: UUID
}

input UpdateProspectInput {
  "The status of the prospect."
  status_id: UUID

  "The source of the prospect."
  source_id: UUID

  "The first name of the prospect."
  first_name: String

  "The last name of the prospect."
  last_name: String

  "The full name of the prospect."
  full_name: String

  "The preferred name of the prospect."
  preferred: String

  "The description of the prospect."
  description: String

  "The email of the prospect."
  email: Email

  "The email 2 of the prospect."
  email_2: Email

  "The mobile number of the prospect."
  mobile: String

  "The phone number of the prospect."
  phone: String

  "If the prospect is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the prospect's email bounces."
  email_bounce: Boolean

  "The address of the prospect."
  address: String

  "The address 2 of the prospect."
  address_2: String

  "The address 3 of the prospect."
  address_3: String

  "The city of the prospect."
  city: String

  "The state of the prospect."
  state: String

  "The postal code of the prospect."
  postal: String

  "The birthdate of the prospect."
  birthdate: Date

  "The High School graduation year of the prospect."
  hsgrad: Year

  "The user that created the prospect."
  created_by_id: UUID
}

type ProspectMutations {
  "Create an prospect."
  create(input: CreateProspectInput!): Prospect!

  "Update an prospect."
  update(
    "The identifier of the prospect you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateProspectInput!
  ): Prospect!

  "Delete an prospect."
  delete(
    "The identifier of the prospect you would like to delete."
    id: UUID!
  ): Prospect
}

type ResourceHubArticle {
  id: UUID!
}

type ResourceHubArticleQueries {
  "Find a single resource hub article by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): ResourceHubArticle

  "Get all resource hub articles."
  list(
    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): ResourceHubArticlePaginator!
}

type Enrollment {
  sisid: String!
  division: String!
  class_nbr: String!
  crse_grade_off: String!
  unt_taken: Int!
  unt_earned: Int!
  last_upd_dt_stmp: DateTime!
  student: Student
}

input EnrollmentsQuery {
  sisid: String
  division: String
  class_nbr: String
  crse_grade_off: String
  unt_taken: Int
  unt_earned: Int
  last_upd_dt_stmp: DateTime
  student: StudentsQuery
}

type EnrollmentQueries {
  "List multiple enrollments."
  list(
    "Filter by the enrollments attributes and relations."
    where: SearchByRootEnrollmentsQuery

    order: [SortByRootEnrollmentsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): EnrollmentPaginator!
}

type Program {
  sisid: String!
  otherid: String!
  acad_career: String!
  division: String!
  acad_plan: String!
  prog_status: String!
  cum_gpa: Float!
  semester: String!
  descr: String!
  foi: String!
  change_dt: DateTime!
  declare_dt: DateTime!
  student: Student
}

input ProgramsQuery {
  sisid: String
  otherid: String
  acad_career: String
  division: String
  acad_plan: String
  prog_status: String
  cum_gpa: Float
  semester: String
  descr: String
  foi: String
  change_dt: DateTime
  declare_dt: DateTime
  student: StudentsQuery
}

type ProgramQueries {
  "List multiple programs."
  list(
    "Filter by the programs attributes and relations."
    where: SearchByRootProgramsQuery

    order: [SortByRootProgramsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): ProgramPaginator!
}

type Student {
  sisid: ID!
  otherid: String
  first: String
  last: String
  full_name: String
  preferred: String
  display_name: String
  email: Email
  email_2: Email
  mobile: String
  sms_opt_out: Boolean
  email_bounce: Boolean
  phone: String
  address: String
  address2: String
  address3: String
  city: String
  state: String
  postal: String
  birthdate: Date
  hsgrad: Year
  dual: Boolean!
  ferpa: Boolean!
  dfw: Date
  sap: Boolean!
  holds: String
  firstgen: Boolean!
  ethnicity: String
  lastlmslogin: DateTime
  f_e_term: String
  mr_e_term: String
  enrollments: [Enrollment!]
  enrollments_count: Int
  programs: [Program!]
  programs_count: Int
  audits: [Audit!]
  audits_count: Int
}

input StudentsQuery {
  sisid: ID
  otherid: String
  first: String
  last: String
  full_name: String
  preferred: String
  email: Email
  email_2: Email
  mobile: String
  sms_opt_out: Boolean
  email_bounce: Boolean
  phone: String
  address: String
  address2: String
  address3: String
  city: String
  state: String
  postal: String
  birthdate: Date
  hsgrad: Year
  dual: Boolean
  ferpa: Boolean
  dfw: Date
  sap: Boolean
  holds: String
  firstgen: Boolean
  ethnicity: String
  lastlmslogin: DateTime
  f_e_term: String
  mr_e_term: String
  enrollments: EnrollmentsQuery
  programs: ProgramsQuery
  audits: AuditsQuery
}

type StudentQueries {
  "Get a specific student by ID."
  find(sisid: ID!): Student

  "List multiple students."
  list(
    "Filter by the students attributes and relations."
    where: SearchByRootStudentsQuery

    order: [SortByRootStudentsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): StudentPaginator!
}

type PromptType {
  id: UUID!
  title: String!
  description: String
  created_at: DateTime
  updated_at: DateTime
  prompts: [Prompt!]
  prompts_count: Int
}

input PromptTypesQuery {
  id: UUID
  title: String
  description: String
  created_at: DateTime
  updated_at: DateTime
  prompts: PromptsQuery
}

type PromptTypeQueries {
  "Get a specific prompt type by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): PromptType

  "List multiple prompt types."
  list(
    "Filter by the prompt types attributes and relations."
    where: SearchByRootPromptTypesQuery

    order: [SortByRootPromptTypesQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): PromptTypePaginator!
}

input CreatePromptTypeInput {
  "The title of the prompt type."
  title: String!

  "The description of the prompt type."
  description: String
}

input UpdatePromptTypeInput {
  "The title of the prompt type."
  title: String

  "The description of the prompt type."
  description: String
}

type PromptTypeMutations {
  "Create a new prompt type."
  create(
    "The attributes to create a prompt type."
    input: CreatePromptTypeInput!
  ): PromptType!

  "Update an existing prompt type."
  update(
    "The identifier of the prompt type you would like to update."
    id: UUID!

    "The attributes to update a prompt type."
    input: UpdatePromptTypeInput!
  ): PromptType!

  "Delete an existing prompt type."
  delete(
    "The identifier of the prompt type you would like to delete."
    id: UUID!
  ): PromptType
}

type Prompt {
  id: UUID!
  title: String!
  description: String
  prompt: String!
  created_at: DateTime
  updated_at: DateTime
  type: PromptType!
}

input PromptsQuery {
  id: UUID
  title: String
  description: String
  prompt: String
  created_at: DateTime
  updated_at: DateTime
  type: PromptTypesQuery
}

type PromptQueries {
  "Get a specific prompt by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): Prompt

  "List multiple prompts."
  list(
    "Filter by the prompts attributes and relations."
    where: SearchByRootPromptsQuery

    order: [SortByRootPromptsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): PromptPaginator!
}

input CreatePromptInput {
  "The title of the prompt."
  title: String!

  "The description of the prompt."
  description: String

  "The text of the prompt."
  prompt: String!

  "The type of the prompt."
  type_id: UUID!
}

input UpdatePromptInput {
  "The title of the prompt."
  title: String

  "The description of the prompt."
  description: String

  "The text of the prompt."
  prompt: String

  "The type of the prompt."
  type_id: UUID
}

type PromptMutations {
  "Create a new prompt."
  create(
    "The attributes to create a prompt."
    input: CreatePromptInput!
  ): Prompt!

  "Update an existing prompt."
  update(
    "The identifier of the prompt you would like to update."
    id: UUID!

    "The attributes to update a prompt."
    input: UpdatePromptInput!
  ): Prompt!

  "Delete an existing prompt."
  delete(
    "The identifier of the prompt you would like to delete."
    id: UUID!
  ): Prompt
}

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
  "Number of items in the current page."
  count: Int!

  "Index of the current page."
  currentPage: Int!

  "Index of the first item in the current page."
  firstItem: Int

  "Are there more pages after this one?"
  hasMorePages: Boolean!

  "Index of the last item in the current page."
  lastItem: Int

  "Index of the last available page."
  lastPage: Int!

  "Number of items per page."
  perPage: Int!

  "Number of total available items."
  total: Int!
}

"A paginated list of User items."
type UserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of User items."
  data: [User!]!
}

"A paginated list of SystemUser items."
type SystemUserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SystemUser items."
  data: [SystemUser!]!
}

"A paginated list of AlertStatus items."
type AlertStatusPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of AlertStatus items."
  data: [AlertStatus!]!
}

"A paginated list of Alert items."
type AlertPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Alert items."
  data: [Alert!]!
}

"A paginated list of Audit items."
type AuditPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Audit items."
  data: [Audit!]!
}

"A paginated list of CareTeam items."
type CareTeamPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of CareTeam items."
  data: [CareTeam!]!
}

"A paginated list of ConsentAgreement items."
type ConsentAgreementPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ConsentAgreement items."
  data: [ConsentAgreement!]!
}

"A paginated list of UserConsentAgreement items."
type UserConsentAgreementPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of UserConsentAgreement items."
  data: [UserConsentAgreement!]!
}

"A paginated list of Engagement items."
type EngagementPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Engagement items."
  data: [Engagement!]!
}

"A paginated list of Interaction items."
type InteractionPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Interaction items."
  data: [Interaction!]!
}

"A paginated list of InteractionInitiative items."
type InteractionInitiativePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionInitiative items."
  data: [InteractionInitiative!]!
}

"A paginated list of InteractionDriver items."
type InteractionDriverPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionDriver items."
  data: [InteractionDriver!]!
}

"A paginated list of InteractionOutcome items."
type InteractionOutcomePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionOutcome items."
  data: [InteractionOutcome!]!
}

"A paginated list of InteractionRelation items."
type InteractionRelationPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionRelation items."
  data: [InteractionRelation!]!
}

"A paginated list of InteractionStatus items."
type InteractionStatusPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionStatus items."
  data: [InteractionStatus!]!
}

"A paginated list of InteractionType items."
type InteractionTypePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of InteractionType items."
  data: [InteractionType!]!
}

"A paginated list of UserSubscription items."
type UserSubscriptionPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of UserSubscription items."
  data: [UserSubscription!]!
}

"A paginated list of ProspectSource items."
type ProspectSourcePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ProspectSource items."
  data: [ProspectSource!]!
}

"A paginated list of ProspectStatus items."
type ProspectStatusPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ProspectStatus items."
  data: [ProspectStatus!]!
}

"A paginated list of Prospect items."
type ProspectPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Prospect items."
  data: [Prospect!]!
}

"A paginated list of ResourceHubArticle items."
type ResourceHubArticlePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ResourceHubArticle items."
  data: [ResourceHubArticle!]!
}

"A paginated list of Enrollment items."
type EnrollmentPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Enrollment items."
  data: [Enrollment!]!
}

"A paginated list of Program items."
type ProgramPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Program items."
  data: [Program!]!
}

"A paginated list of Student items."
type StudentPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Student items."
  data: [Student!]!
}

"A paginated list of PromptType items."
type PromptTypePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of PromptType items."
  data: [PromptType!]!
}

"A paginated list of Prompt items."
type PromptPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Prompt items."
  data: [Prompt!]!
}

enum SearchByTypeFlag {
  Yes
}

"Available operators for `scalar UUID` (only one operator allowed at a time)."
input SearchByScalarUUIDOrNull {
  "Equal (`=`)."
  equal: UUID

  "Not Equal (`!=`)."
  notEqual: UUID

  "Within a set of values."
  in: [UUID!]

  "Outside a set of values."
  notIn: [UUID!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar Email` (only one operator allowed at a time)."
input SearchByScalarEmailOrNull {
  "Equal (`=`)."
  equal: Email

  "Not Equal (`!=`)."
  notEqual: Email

  "Like."
  like: Email

  "Not like."
  notLike: Email

  "Within a set of values."
  in: [Email!]

  "Outside a set of values."
  notIn: [Email!]

  "Contains."
  contains: Email

  "Not contains."
  notContains: Email

  "Starts with a string."
  startsWith: Email

  "Not starts with a string."
  notStartsWith: Email

  "Ends with a string."
  endsWith: Email

  "Not ends with a string."
  notEndsWith: Email

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeInt {
  min: Int!
  max: Int!
}

"Available operators for `scalar Int` (only one operator allowed at a time)."
input SearchByScalarInt {
  "Equal (`=`)."
  equal: Int

  "Not Equal (`!=`)."
  notEqual: Int

  "Less than (`<`)."
  lessThan: Int

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Int

  "Greater than (`>`)."
  greaterThan: Int

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Int

  "Within a set of values."
  in: [Int!]

  "Outside a set of values."
  notIn: [Int!]

  "Within a range."
  between: SearchByTypeRangeInt

  "Outside a range."
  notBetween: SearchByTypeRangeInt

  "Bitwise OR (`|`)."
  bitwiseOr: Int

  "Bitwise XOR (`^`)."
  bitwiseXor: Int

  "Bitwise AND (`&`)."
  bitwiseAnd: Int

  "Bitwise Left shift (`<<`)."
  bitwiseLeftShift: Int

  "Bitwise Right shift (`>>`)."
  bitwiseRightShift: Int
}

"Available operators for `enum ConsentAgreementType` (only one operator allowed at a time)."
input SearchByEnumConsentAgreementTypeOrNull {
  "Equal (`=`)."
  equal: ConsentAgreementType

  "Not Equal (`!=`)."
  notEqual: ConsentAgreementType

  "Within a set of values."
  in: [ConsentAgreementType!]

  "Outside a set of values."
  notIn: [ConsentAgreementType!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar String` (only one operator allowed at a time)."
input SearchByScalarStringOrNull {
  "Equal (`=`)."
  equal: String

  "Not Equal (`!=`)."
  notEqual: String

  "Like."
  like: String

  "Not like."
  notLike: String

  "Within a set of values."
  in: [String!]

  "Outside a set of values."
  notIn: [String!]

  "Contains."
  contains: String

  "Not contains."
  notContains: String

  "Starts with a string."
  startsWith: String

  "Not starts with a string."
  notStartsWith: String

  "Ends with a string."
  endsWith: String

  "Not ends with a string."
  notEndsWith: String

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeDateTime {
  min: DateTime!
  max: DateTime!
}

"Available operators for `scalar DateTime` (only one operator allowed at a time)."
input SearchByScalarDateTimeOrNull {
  "Equal (`=`)."
  equal: DateTime

  "Not Equal (`!=`)."
  notEqual: DateTime

  "Less than (`<`)."
  lessThan: DateTime

  "Less than or equal to (`<=`)."
  lessThanOrEqual: DateTime

  "Greater than (`>`)."
  greaterThan: DateTime

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: DateTime

  "Within a set of values."
  in: [DateTime!]

  "Outside a set of values."
  notIn: [DateTime!]

  "Within a range."
  between: SearchByTypeRangeDateTime

  "Outside a range."
  notBetween: SearchByTypeRangeDateTime

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input UsersQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipUsersQuery {
  "Additional conditions."
  where: SearchByRootUsersQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `scalar JSON` (only one operator allowed at a time)."
input SearchByScalarJSONOrNull {
  "Equal (`=`)."
  equal: JSON

  "Not Equal (`!=`)."
  notEqual: JSON

  "Like."
  like: JSON

  "Not like."
  notLike: JSON

  "Within a set of values."
  in: [JSON!]

  "Outside a set of values."
  notIn: [JSON!]

  "Contains."
  contains: JSON

  "Not contains."
  notContains: JSON

  "Starts with a string."
  startsWith: JSON

  "Not starts with a string."
  notStartsWith: JSON

  "Ends with a string."
  endsWith: JSON

  "Not ends with a string."
  notEndsWith: JSON

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar ID` (only one operator allowed at a time)."
input SearchByScalarIDOrNull {
  "Equal (`=`)."
  equal: ID

  "Not Equal (`!=`)."
  notEqual: ID

  "Within a set of values."
  in: [ID!]

  "Outside a set of values."
  notIn: [ID!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar Boolean` (only one operator allowed at a time)."
input SearchByScalarBooleanOrNull {
  "Equal (`=`)."
  equal: Boolean

  "Not Equal (`!=`)."
  notEqual: Boolean

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeDate {
  min: Date!
  max: Date!
}

"Available operators for `scalar Date` (only one operator allowed at a time)."
input SearchByScalarDateOrNull {
  "Equal (`=`)."
  equal: Date

  "Not Equal (`!=`)."
  notEqual: Date

  "Less than (`<`)."
  lessThan: Date

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Date

  "Greater than (`>`)."
  greaterThan: Date

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Date

  "Within a set of values."
  in: [Date!]

  "Outside a set of values."
  notIn: [Date!]

  "Within a range."
  between: SearchByTypeRangeDate

  "Outside a range."
  notBetween: SearchByTypeRangeDate

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeYear {
  min: Year!
  max: Year!
}

"Available operators for `scalar Year` (only one operator allowed at a time)."
input SearchByScalarYearOrNull {
  "Equal (`=`)."
  equal: Year

  "Not Equal (`!=`)."
  notEqual: Year

  "Less than (`<`)."
  lessThan: Year

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Year

  "Greater than (`>`)."
  greaterThan: Year

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Year

  "Within a set of values."
  in: [Year!]

  "Outside a set of values."
  notIn: [Year!]

  "Within a range."
  between: SearchByTypeRangeYear

  "Outside a range."
  notBetween: SearchByTypeRangeYear

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar Int` (only one operator allowed at a time)."
input SearchByScalarIntOrNull {
  "Equal (`=`)."
  equal: Int

  "Not Equal (`!=`)."
  notEqual: Int

  "Less than (`<`)."
  lessThan: Int

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Int

  "Greater than (`>`)."
  greaterThan: Int

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Int

  "Within a set of values."
  in: [Int!]

  "Outside a set of values."
  notIn: [Int!]

  "Within a range."
  between: SearchByTypeRangeInt

  "Outside a range."
  notBetween: SearchByTypeRangeInt

  "Bitwise OR (`|`)."
  bitwiseOr: Int

  "Bitwise XOR (`^`)."
  bitwiseXor: Int

  "Bitwise AND (`&`)."
  bitwiseAnd: Int

  "Bitwise Left shift (`<<`)."
  bitwiseLeftShift: Int

  "Bitwise Right shift (`>>`)."
  bitwiseRightShift: Int

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input EnrollmentsQuery` (only one field allowed at a time)."
input SearchByConditionEnrollmentsQuery {
  "Field condition."
  sisid: SearchByScalarStringOrNull

  "Field condition."
  division: SearchByScalarStringOrNull

  "Field condition."
  class_nbr: SearchByScalarStringOrNull

  "Field condition."
  crse_grade_off: SearchByScalarStringOrNull

  "Field condition."
  unt_taken: SearchByScalarIntOrNull

  "Field condition."
  unt_earned: SearchByScalarIntOrNull

  "Field condition."
  last_upd_dt_stmp: SearchByScalarDateTimeOrNull

  "Relationship condition."
  student: SearchByRelationshipStudentsQuery
}

"Available conditions for `input EnrollmentsQuery` (only one field allowed at a time)."
input SearchByRootEnrollmentsQuery {
  "Field."
  field: SearchByConditionEnrollmentsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootEnrollmentsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootEnrollmentsQuery!]

  "Not."
  not: SearchByRootEnrollmentsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input EnrollmentsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipEnrollmentsQuery {
  "Additional conditions."
  where: SearchByRootEnrollmentsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

input SearchByTypeRangeFloat {
  min: Float!
  max: Float!
}

"Available operators for `scalar Float` (only one operator allowed at a time)."
input SearchByScalarFloatOrNull {
  "Equal (`=`)."
  equal: Float

  "Not Equal (`!=`)."
  notEqual: Float

  "Less than (`<`)."
  lessThan: Float

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Float

  "Greater than (`>`)."
  greaterThan: Float

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Float

  "Within a set of values."
  in: [Float!]

  "Outside a set of values."
  notIn: [Float!]

  "Within a range."
  between: SearchByTypeRangeFloat

  "Outside a range."
  notBetween: SearchByTypeRangeFloat

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input ProgramsQuery` (only one field allowed at a time)."
input SearchByConditionProgramsQuery {
  "Field condition."
  sisid: SearchByScalarStringOrNull

  "Field condition."
  otherid: SearchByScalarStringOrNull

  "Field condition."
  acad_career: SearchByScalarStringOrNull

  "Field condition."
  division: SearchByScalarStringOrNull

  "Field condition."
  acad_plan: SearchByScalarStringOrNull

  "Field condition."
  prog_status: SearchByScalarStringOrNull

  "Field condition."
  cum_gpa: SearchByScalarFloatOrNull

  "Field condition."
  semester: SearchByScalarStringOrNull

  "Field condition."
  descr: SearchByScalarStringOrNull

  "Field condition."
  foi: SearchByScalarStringOrNull

  "Field condition."
  change_dt: SearchByScalarDateTimeOrNull

  "Field condition."
  declare_dt: SearchByScalarDateTimeOrNull

  "Relationship condition."
  student: SearchByRelationshipStudentsQuery
}

"Available conditions for `input ProgramsQuery` (only one field allowed at a time)."
input SearchByRootProgramsQuery {
  "Field."
  field: SearchByConditionProgramsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootProgramsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootProgramsQuery!]

  "Not."
  not: SearchByRootProgramsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ProgramsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipProgramsQuery {
  "Additional conditions."
  where: SearchByRootProgramsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input StudentsQuery` (only one field allowed at a time)."
input SearchByConditionStudentsQuery {
  "Field condition."
  sisid: SearchByScalarIDOrNull

  "Field condition."
  otherid: SearchByScalarStringOrNull

  "Field condition."
  first: SearchByScalarStringOrNull

  "Field condition."
  last: SearchByScalarStringOrNull

  "Field condition."
  full_name: SearchByScalarStringOrNull

  "Field condition."
  preferred: SearchByScalarStringOrNull

  "Field condition."
  email: SearchByScalarEmailOrNull

  "Field condition."
  email_2: SearchByScalarEmailOrNull

  "Field condition."
  mobile: SearchByScalarStringOrNull

  "Field condition."
  sms_opt_out: SearchByScalarBooleanOrNull

  "Field condition."
  email_bounce: SearchByScalarBooleanOrNull

  "Field condition."
  phone: SearchByScalarStringOrNull

  "Field condition."
  address: SearchByScalarStringOrNull

  "Field condition."
  address2: SearchByScalarStringOrNull

  "Field condition."
  address3: SearchByScalarStringOrNull

  "Field condition."
  city: SearchByScalarStringOrNull

  "Field condition."
  state: SearchByScalarStringOrNull

  "Field condition."
  postal: SearchByScalarStringOrNull

  "Field condition."
  birthdate: SearchByScalarDateOrNull

  "Field condition."
  hsgrad: SearchByScalarYearOrNull

  "Field condition."
  dual: SearchByScalarBooleanOrNull

  "Field condition."
  ferpa: SearchByScalarBooleanOrNull

  "Field condition."
  dfw: SearchByScalarDateOrNull

  "Field condition."
  sap: SearchByScalarBooleanOrNull

  "Field condition."
  holds: SearchByScalarStringOrNull

  "Field condition."
  firstgen: SearchByScalarBooleanOrNull

  "Field condition."
  ethnicity: SearchByScalarStringOrNull

  "Field condition."
  lastlmslogin: SearchByScalarDateTimeOrNull

  "Field condition."
  f_e_term: SearchByScalarStringOrNull

  "Field condition."
  mr_e_term: SearchByScalarStringOrNull

  "Relationship condition."
  enrollments: SearchByRelationshipEnrollmentsQuery

  "Relationship condition."
  programs: SearchByRelationshipProgramsQuery

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input StudentsQuery` (only one field allowed at a time)."
input SearchByRootStudentsQuery {
  "Field."
  field: SearchByConditionStudentsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootStudentsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootStudentsQuery!]

  "Not."
  not: SearchByRootStudentsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input StudentsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipStudentsQuery {
  "Additional conditions."
  where: SearchByRootStudentsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `enum SystemProspectClassification` (only one operator allowed at a time)."
input SearchByEnumSystemProspectClassificationOrNull {
  "Equal (`=`)."
  equal: SystemProspectClassification

  "Not Equal (`!=`)."
  notEqual: SystemProspectClassification

  "Within a set of values."
  in: [SystemProspectClassification!]

  "Outside a set of values."
  notIn: [SystemProspectClassification!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum ProspectStatusColorOptions` (only one operator allowed at a time)."
input SearchByEnumProspectStatusColorOptionsOrNull {
  "Equal (`=`)."
  equal: ProspectStatusColorOptions

  "Not Equal (`!=`)."
  notEqual: ProspectStatusColorOptions

  "Within a set of values."
  in: [ProspectStatusColorOptions!]

  "Outside a set of values."
  notIn: [ProspectStatusColorOptions!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input ProspectStatusesQuery` (only one field allowed at a time)."
input SearchByConditionProspectStatusesQuery {
  "The unique primary key of the prospect status."
  id: SearchByScalarUUIDOrNull

  "The name of the prospect status."
  name: SearchByScalarStringOrNull

  "The classification of the prospect status."
  classification: SearchByEnumSystemProspectClassificationOrNull

  "The color of the prospect status."
  color: SearchByEnumProspectStatusColorOptionsOrNull

  "The created date of the prospect status."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the prospect status."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the prospect status."
  deleted_at: SearchByScalarDateTimeOrNull

  "The prospects related to this prospect status."
  prospects: SearchByRelationshipProspectsQuery

  "The audits related to this prospect status."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input ProspectStatusesQuery` (only one field allowed at a time)."
input SearchByRootProspectStatusesQuery {
  "Field."
  field: SearchByConditionProspectStatusesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootProspectStatusesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootProspectStatusesQuery!]

  "Not."
  not: SearchByRootProspectStatusesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ProspectStatusesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipProspectStatusesQuery {
  "Additional conditions."
  where: SearchByRootProspectStatusesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input ProspectSourcesQuery` (only one field allowed at a time)."
input SearchByConditionProspectSourcesQuery {
  "The unique primary key of the prospect source."
  id: SearchByScalarUUIDOrNull

  "The name of the prospect source."
  name: SearchByScalarStringOrNull

  "The created date of the prospect source."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the prospect source."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the prospect source."
  deleted_at: SearchByScalarDateTimeOrNull

  "The prospects related to this prospect source."
  prospects: SearchByRelationshipProspectsQuery

  "The audits related to this prospect source."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input ProspectSourcesQuery` (only one field allowed at a time)."
input SearchByRootProspectSourcesQuery {
  "Field."
  field: SearchByConditionProspectSourcesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootProspectSourcesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootProspectSourcesQuery!]

  "Not."
  not: SearchByRootProspectSourcesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ProspectSourcesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipProspectSourcesQuery {
  "Additional conditions."
  where: SearchByRootProspectSourcesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input ProspectsQuery` (only one field allowed at a time)."
input SearchByConditionProspectsQuery {
  "Unique primary key."
  id: SearchByScalarUUIDOrNull

  "The status ID of the prospect."
  status_id: SearchByScalarUUIDOrNull

  "The status of the prospect."
  status: SearchByRelationshipProspectStatusesQuery

  "The source ID of the prospect."
  source_id: SearchByScalarUUIDOrNull

  "The source of the prospect."
  source: SearchByRelationshipProspectSourcesQuery

  "The first name of the prospect."
  first_name: SearchByScalarStringOrNull

  "The last name of the prospect."
  last_name: SearchByScalarStringOrNull

  "The full name of the prospect."
  full_name: SearchByScalarStringOrNull

  "The preferred name of the prospect."
  preferred: SearchByScalarStringOrNull

  "The description of the prospect."
  description: SearchByScalarStringOrNull

  "The email of the prospect."
  email: SearchByScalarEmailOrNull

  "The email 2 of the prospect."
  email_2: SearchByScalarEmailOrNull

  "The mobile number of the prospect."
  mobile: SearchByScalarStringOrNull

  "The phone number of the prospect."
  phone: SearchByScalarStringOrNull

  "If the prospect is opted out of SMS messages."
  sms_opt_out: SearchByScalarBooleanOrNull

  "If the prospect's email bounces."
  email_bounce: SearchByScalarBooleanOrNull

  "The address of the prospect."
  address: SearchByScalarStringOrNull

  "The address 2 of the prospect."
  address_2: SearchByScalarStringOrNull

  "The address 3 of the prospect."
  address_3: SearchByScalarStringOrNull

  "The city of the prospect."
  city: SearchByScalarStringOrNull

  "The state of the prospect."
  state: SearchByScalarStringOrNull

  "The postal code of the prospect."
  postal: SearchByScalarStringOrNull

  "The birthdate of the prospect."
  birthdate: SearchByScalarDateOrNull

  "The High School graduation year of the prospect."
  hsgrad: SearchByScalarStringOrNull

  "The created date of the prospect."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the prospect."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the prospect."
  deleted_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery

  "Relationship condition."
  created_by: SearchByRelationshipUsersQuery
}

"Available conditions for `input ProspectsQuery` (only one field allowed at a time)."
input SearchByRootProspectsQuery {
  "Field."
  field: SearchByConditionProspectsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootProspectsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootProspectsQuery!]

  "Not."
  not: SearchByRootProspectsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ProspectsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipProspectsQuery {
  "Additional conditions."
  where: SearchByRootProspectsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input SystemUsersQuery` (only one field allowed at a time)."
input SearchByConditionSystemUsersQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  name: SearchByScalarStringOrNull

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input SystemUsersQuery` (only one field allowed at a time)."
input SearchByRootSystemUsersQuery {
  "Field."
  field: SearchByConditionSystemUsersQuery

  "All of the conditions must be true."
  allOf: [SearchByRootSystemUsersQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootSystemUsersQuery!]

  "Not."
  not: SearchByRootSystemUsersQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input SystemUsersQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipSystemUsersQuery {
  "Additional conditions."
  where: SearchByRootSystemUsersQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input EngagementRecipientsQuery` (only one field allowed at a time)."
input SearchByConditionEngagementRecipientsQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery
}

"Available conditions for `input EngagementRecipientsQuery` (only one field allowed at a time)."
input SearchByRootEngagementRecipientsQuery {
  "Field."
  field: SearchByConditionEngagementRecipientsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootEngagementRecipientsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootEngagementRecipientsQuery!]

  "Not."
  not: SearchByRootEngagementRecipientsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input EngagementRecipientsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipEngagementRecipientsQuery {
  "Additional conditions."
  where: SearchByRootEngagementRecipientsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input EngagementsQuery` (only one field allowed at a time)."
input SearchByConditionEngagementsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  subject: SearchByScalarJSONOrNull

  "Field condition."
  body: SearchByScalarJSONOrNull

  "Field condition."
  scheduled_at: SearchByScalarDateTimeOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  recipient: SearchByRelationshipEngagementRecipientsQuery

  "Relationship condition."
  created_by: SearchByRelationshipUsersQuery

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input EngagementsQuery` (only one field allowed at a time)."
input SearchByRootEngagementsQuery {
  "Field."
  field: SearchByConditionEngagementsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootEngagementsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootEngagementsQuery!]

  "Not."
  not: SearchByRootEngagementsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input EngagementsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipEngagementsQuery {
  "Additional conditions."
  where: SearchByRootEngagementsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuditableablesQuery` (only one field allowed at a time)."
input SearchByConditionAuditableablesQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  system_user: SearchByRelationshipSystemUsersQuery

  "Relationship condition."
  consent_agreement: SearchByRelationshipConsentAgreementsQuery

  "Relationship condition."
  user_consent_agreement: SearchByRelationshipUserConsentAgreementsQuery

  "Relationship condition."
  engagement: SearchByRelationshipEngagementsQuery
}

"Available conditions for `input AuditableablesQuery` (only one field allowed at a time)."
input SearchByRootAuditableablesQuery {
  "Field."
  field: SearchByConditionAuditableablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuditableablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuditableablesQuery!]

  "Not."
  not: SearchByRootAuditableablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuditableablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuditableablesQuery {
  "Additional conditions."
  where: SearchByRootAuditableablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SearchByConditionAuthenticatablesQuery {
  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  system_user: SearchByRelationshipSystemUsersQuery
}

"Available conditions for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SearchByRootAuthenticatablesQuery {
  "Field."
  field: SearchByConditionAuthenticatablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuthenticatablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuthenticatablesQuery!]

  "Not."
  not: SearchByRootAuthenticatablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuthenticatablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuthenticatablesQuery {
  "Additional conditions."
  where: SearchByRootAuthenticatablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuditsQuery` (only one field allowed at a time)."
input SearchByConditionAuditsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  change_agent_type: SearchByScalarStringOrNull

  "Field condition."
  change_agent_id: SearchByScalarUUIDOrNull

  "Field condition."
  event: SearchByScalarStringOrNull

  "Field condition."
  old_values: SearchByScalarJSONOrNull

  "Field condition."
  new_values: SearchByScalarJSONOrNull

  "Field condition."
  url: SearchByScalarStringOrNull

  "Field condition."
  ip_address: SearchByScalarStringOrNull

  "Field condition."
  user_agent: SearchByScalarStringOrNull

  "Field condition."
  tags: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  auditable: SearchByRelationshipAuditableablesQuery

  "Relationship condition."
  user: SearchByRelationshipAuthenticatablesQuery
}

"Available conditions for `input AuditsQuery` (only one field allowed at a time)."
input SearchByRootAuditsQuery {
  "Field."
  field: SearchByConditionAuditsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuditsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuditsQuery!]

  "Not."
  not: SearchByRootAuditsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuditsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuditsQuery {
  "Additional conditions."
  where: SearchByRootAuditsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input UserConsentAgreementsQuery` (only one field allowed at a time)."
input SearchByConditionUserConsentAgreementsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  ip_address: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  consent_agreement: SearchByRelationshipConsentAgreementsQuery

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input UserConsentAgreementsQuery` (only one field allowed at a time)."
input SearchByRootUserConsentAgreementsQuery {
  "Field."
  field: SearchByConditionUserConsentAgreementsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootUserConsentAgreementsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootUserConsentAgreementsQuery!]

  "Not."
  not: SearchByRootUserConsentAgreementsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input UserConsentAgreementsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipUserConsentAgreementsQuery {
  "Additional conditions."
  where: SearchByRootUserConsentAgreementsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input ConsentAgreementsQuery` (only one field allowed at a time)."
input SearchByConditionConsentAgreementsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  type: SearchByEnumConsentAgreementTypeOrNull

  "Field condition."
  title: SearchByScalarStringOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Field condition."
  body: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  user_consent_agreements: SearchByRelationshipUserConsentAgreementsQuery

  "Relationship condition."
  users: SearchByRelationshipUsersQuery

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input ConsentAgreementsQuery` (only one field allowed at a time)."
input SearchByRootConsentAgreementsQuery {
  "Field."
  field: SearchByConditionConsentAgreementsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootConsentAgreementsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootConsentAgreementsQuery!]

  "Not."
  not: SearchByRootConsentAgreementsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ConsentAgreementsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipConsentAgreementsQuery {
  "Additional conditions."
  where: SearchByRootConsentAgreementsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input UsersQuery` (only one field allowed at a time)."
input SearchByConditionUsersQuery {
  "Unique primary key."
  id: SearchByScalarUUIDOrNull

  "Users email address."
  email: SearchByScalarEmailOrNull

  "Relationship condition."
  consent_agreements: SearchByRelationshipConsentAgreementsQuery

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input UsersQuery` (only one field allowed at a time)."
input SearchByRootUsersQuery {
  "Field."
  field: SearchByConditionUsersQuery

  "All of the conditions must be true."
  allOf: [SearchByRootUsersQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootUsersQuery!]

  "Not."
  not: SearchByRootUsersQuery
}

"Available operators for `enum SystemAlertStatusClassification` (only one operator allowed at a time)."
input SearchByEnumSystemAlertStatusClassificationOrNull {
  "Equal (`=`)."
  equal: SystemAlertStatusClassification

  "Not Equal (`!=`)."
  notEqual: SystemAlertStatusClassification

  "Within a set of values."
  in: [SystemAlertStatusClassification!]

  "Outside a set of values."
  notIn: [SystemAlertStatusClassification!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input AlertStatusesQuery` (only one field allowed at a time)."
input SearchByConditionAlertStatusesQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  classification: SearchByEnumSystemAlertStatusClassificationOrNull

  "Field condition."
  name: SearchByScalarStringOrNull

  "Field condition."
  order: SearchByScalarIntOrNull

  "Field condition."
  is_default: SearchByScalarBooleanOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input AlertStatusesQuery` (only one field allowed at a time)."
input SearchByRootAlertStatusesQuery {
  "Field."
  field: SearchByConditionAlertStatusesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAlertStatusesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAlertStatusesQuery!]

  "Not."
  not: SearchByRootAlertStatusesQuery
}

"Available conditions for `input AlertConcernsQuery` (only one field allowed at a time)."
input SearchByConditionAlertConcernsQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery
}

"Available conditions for `input AlertConcernsQuery` (only one field allowed at a time)."
input SearchByRootAlertConcernsQuery {
  "Field."
  field: SearchByConditionAlertConcernsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAlertConcernsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAlertConcernsQuery!]

  "Not."
  not: SearchByRootAlertConcernsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AlertConcernsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAlertConcernsQuery {
  "Additional conditions."
  where: SearchByRootAlertConcernsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `scalar EducatableId` (only one operator allowed at a time)."
input SearchByScalarEducatableIdOrNull {
  "Equal (`=`)."
  equal: EducatableId

  "Not Equal (`!=`)."
  notEqual: EducatableId

  "Within a set of values."
  in: [EducatableId!]

  "Outside a set of values."
  notIn: [EducatableId!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum EducatableType` (only one operator allowed at a time)."
input SearchByEnumEducatableTypeOrNull {
  "Equal (`=`)."
  equal: EducatableType

  "Not Equal (`!=`)."
  notEqual: EducatableType

  "Within a set of values."
  in: [EducatableType!]

  "Outside a set of values."
  notIn: [EducatableType!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum AlertSeverity` (only one operator allowed at a time)."
input SearchByEnumAlertSeverityOrNull {
  "Equal (`=`)."
  equal: AlertSeverity

  "Not Equal (`!=`)."
  notEqual: AlertSeverity

  "Within a set of values."
  in: [AlertSeverity!]

  "Outside a set of values."
  notIn: [AlertSeverity!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AlertStatusesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAlertStatusesQuery {
  "Additional conditions."
  where: SearchByRootAlertStatusesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AlertsQuery` (only one field allowed at a time)."
input SearchByConditionAlertsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Relationship condition."
  concern: SearchByRelationshipAlertConcernsQuery

  "Field condition."
  concern_id: SearchByScalarEducatableIdOrNull

  "Field condition."
  concern_type: SearchByEnumEducatableTypeOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Field condition."
  severity: SearchByEnumAlertSeverityOrNull

  "Relationship condition."
  status: SearchByRelationshipAlertStatusesQuery

  "Field condition."
  suggested_intervention: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input AlertsQuery` (only one field allowed at a time)."
input SearchByRootAlertsQuery {
  "Field."
  field: SearchByConditionAlertsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAlertsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAlertsQuery!]

  "Not."
  not: SearchByRootAlertsQuery
}

"Sort direction."
enum SortByTypeDirection {
  Asc
  Desc
}

"Sort clause for `input EnrollmentsQuery` (only one field allowed at a time)."
input SortByClauseEnrollmentsQuery {
  "Field clause."
  sisid: SortByTypeDirection

  "Field clause."
  division: SortByTypeDirection

  "Field clause."
  class_nbr: SortByTypeDirection

  "Field clause."
  crse_grade_off: SortByTypeDirection

  "Field clause."
  unt_taken: SortByTypeDirection

  "Field clause."
  unt_earned: SortByTypeDirection

  "Field clause."
  last_upd_dt_stmp: SortByTypeDirection

  "Field clause."
  student: SortByClauseStudentsQuery
}

"Sort clause for `input ProgramsQuery` (only one field allowed at a time)."
input SortByClauseProgramsQuery {
  "Field clause."
  sisid: SortByTypeDirection

  "Field clause."
  otherid: SortByTypeDirection

  "Field clause."
  acad_career: SortByTypeDirection

  "Field clause."
  division: SortByTypeDirection

  "Field clause."
  acad_plan: SortByTypeDirection

  "Field clause."
  prog_status: SortByTypeDirection

  "Field clause."
  cum_gpa: SortByTypeDirection

  "Field clause."
  semester: SortByTypeDirection

  "Field clause."
  descr: SortByTypeDirection

  "Field clause."
  foi: SortByTypeDirection

  "Field clause."
  change_dt: SortByTypeDirection

  "Field clause."
  declare_dt: SortByTypeDirection

  "Field clause."
  student: SortByClauseStudentsQuery
}

"Sort clause for `input StudentsQuery` (only one field allowed at a time)."
input SortByClauseStudentsQuery {
  "Field clause."
  sisid: SortByTypeDirection

  "Field clause."
  otherid: SortByTypeDirection

  "Field clause."
  first: SortByTypeDirection

  "Field clause."
  last: SortByTypeDirection

  "Field clause."
  full_name: SortByTypeDirection

  "Field clause."
  preferred: SortByTypeDirection

  "Field clause."
  email: SortByTypeDirection

  "Field clause."
  email_2: SortByTypeDirection

  "Field clause."
  mobile: SortByTypeDirection

  "Field clause."
  sms_opt_out: SortByTypeDirection

  "Field clause."
  email_bounce: SortByTypeDirection

  "Field clause."
  phone: SortByTypeDirection

  "Field clause."
  address: SortByTypeDirection

  "Field clause."
  address2: SortByTypeDirection

  "Field clause."
  address3: SortByTypeDirection

  "Field clause."
  city: SortByTypeDirection

  "Field clause."
  state: SortByTypeDirection

  "Field clause."
  postal: SortByTypeDirection

  "Field clause."
  birthdate: SortByTypeDirection

  "Field clause."
  hsgrad: SortByTypeDirection

  "Field clause."
  dual: SortByTypeDirection

  "Field clause."
  ferpa: SortByTypeDirection

  "Field clause."
  dfw: SortByTypeDirection

  "Field clause."
  sap: SortByTypeDirection

  "Field clause."
  holds: SortByTypeDirection

  "Field clause."
  firstgen: SortByTypeDirection

  "Field clause."
  ethnicity: SortByTypeDirection

  "Field clause."
  lastlmslogin: SortByTypeDirection

  "Field clause."
  f_e_term: SortByTypeDirection

  "Field clause."
  mr_e_term: SortByTypeDirection

  "Field clause."
  enrollments: SortByClauseEnrollmentsQuery

  "Field clause."
  programs: SortByClauseProgramsQuery

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ProspectStatusesQuery` (only one field allowed at a time)."
input SortByClauseProspectStatusesQuery {
  "The unique primary key of the prospect status."
  id: SortByTypeDirection

  "The name of the prospect status."
  name: SortByTypeDirection

  "The classification of the prospect status."
  classification: SortByTypeDirection

  "The color of the prospect status."
  color: SortByTypeDirection

  "The created date of the prospect status."
  created_at: SortByTypeDirection

  "The updated date of the prospect status."
  updated_at: SortByTypeDirection

  "The deleted date of the prospect status."
  deleted_at: SortByTypeDirection

  "The prospects related to this prospect status."
  prospects: SortByClauseProspectsQuery

  "The audits related to this prospect status."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ProspectSourcesQuery` (only one field allowed at a time)."
input SortByClauseProspectSourcesQuery {
  "The unique primary key of the prospect source."
  id: SortByTypeDirection

  "The name of the prospect source."
  name: SortByTypeDirection

  "The created date of the prospect source."
  created_at: SortByTypeDirection

  "The updated date of the prospect source."
  updated_at: SortByTypeDirection

  "The deleted date of the prospect source."
  deleted_at: SortByTypeDirection

  "The prospects related to this prospect source."
  prospects: SortByClauseProspectsQuery

  "The audits related to this prospect source."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input UserConsentAgreementsQuery` (only one field allowed at a time)."
input SortByClauseUserConsentAgreementsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  ip_address: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  deleted_at: SortByTypeDirection

  "Field clause."
  user: SortByClauseUsersQuery

  "Field clause."
  consent_agreement: SortByClauseConsentAgreementsQuery

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ConsentAgreementsQuery` (only one field allowed at a time)."
input SortByClauseConsentAgreementsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  type: SortByTypeDirection

  "Field clause."
  title: SortByTypeDirection

  "Field clause."
  description: SortByTypeDirection

  "Field clause."
  body: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  deleted_at: SortByTypeDirection

  "Field clause."
  user_consent_agreements: SortByClauseUserConsentAgreementsQuery

  "Field clause."
  users: SortByClauseUsersQuery

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input UsersQuery` (only one field allowed at a time)."
input SortByClauseUsersQuery {
  "Unique primary key."
  id: SortByTypeDirection

  "Users email address."
  email: SortByTypeDirection

  "Field clause."
  consent_agreements: SortByClauseConsentAgreementsQuery

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ProspectsQuery` (only one field allowed at a time)."
input SortByClauseProspectsQuery {
  "Unique primary key."
  id: SortByTypeDirection

  "The status ID of the prospect."
  status_id: SortByTypeDirection

  "The status of the prospect."
  status: SortByClauseProspectStatusesQuery

  "The source ID of the prospect."
  source_id: SortByTypeDirection

  "The source of the prospect."
  source: SortByClauseProspectSourcesQuery

  "The first name of the prospect."
  first_name: SortByTypeDirection

  "The last name of the prospect."
  last_name: SortByTypeDirection

  "The full name of the prospect."
  full_name: SortByTypeDirection

  "The preferred name of the prospect."
  preferred: SortByTypeDirection

  "The description of the prospect."
  description: SortByTypeDirection

  "The email of the prospect."
  email: SortByTypeDirection

  "The email 2 of the prospect."
  email_2: SortByTypeDirection

  "The mobile number of the prospect."
  mobile: SortByTypeDirection

  "The phone number of the prospect."
  phone: SortByTypeDirection

  "If the prospect is opted out of SMS messages."
  sms_opt_out: SortByTypeDirection

  "If the prospect's email bounces."
  email_bounce: SortByTypeDirection

  "The address of the prospect."
  address: SortByTypeDirection

  "The address 2 of the prospect."
  address_2: SortByTypeDirection

  "The address 3 of the prospect."
  address_3: SortByTypeDirection

  "The city of the prospect."
  city: SortByTypeDirection

  "The state of the prospect."
  state: SortByTypeDirection

  "The postal code of the prospect."
  postal: SortByTypeDirection

  "The birthdate of the prospect."
  birthdate: SortByTypeDirection

  "The High School graduation year of the prospect."
  hsgrad: SortByTypeDirection

  "The created date of the prospect."
  created_at: SortByTypeDirection

  "The updated date of the prospect."
  updated_at: SortByTypeDirection

  "The deleted date of the prospect."
  deleted_at: SortByTypeDirection

  "Field clause."
  audits: SortByClauseAuditsQuery

  "Field clause."
  created_by: SortByClauseUsersQuery
}

"Sort clause for `input SystemUsersQuery` (only one field allowed at a time)."
input SortByClauseSystemUsersQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  name: SortByTypeDirection

  "Field clause."
  audits: SortByClauseAuditsQuery

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  deleted_at: SortByTypeDirection
}

"Sort clause for `input EngagementRecipientsQuery` (only one field allowed at a time)."
input SortByClauseEngagementRecipientsQuery {
  "Field clause."
  student: SortByClauseStudentsQuery

  "Field clause."
  prospect: SortByClauseProspectsQuery
}

"Sort clause for `input EngagementsQuery` (only one field allowed at a time)."
input SortByClauseEngagementsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  subject: SortByTypeDirection

  "Field clause."
  body: SortByTypeDirection

  "Field clause."
  scheduled_at: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  deleted_at: SortByTypeDirection

  "Field clause."
  recipient: SortByClauseEngagementRecipientsQuery

  "Field clause."
  created_by: SortByClauseUsersQuery

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input AuditableablesQuery` (only one field allowed at a time)."
input SortByClauseAuditableablesQuery {
  "Field clause."
  student: SortByClauseStudentsQuery

  "Field clause."
  prospect: SortByClauseProspectsQuery

  "Field clause."
  user: SortByClauseUsersQuery

  "Field clause."
  system_user: SortByClauseSystemUsersQuery

  "Field clause."
  consent_agreement: SortByClauseConsentAgreementsQuery

  "Field clause."
  user_consent_agreement: SortByClauseUserConsentAgreementsQuery

  "Field clause."
  engagement: SortByClauseEngagementsQuery
}

"Sort clause for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SortByClauseAuthenticatablesQuery {
  "Field clause."
  user: SortByClauseUsersQuery

  "Field clause."
  system_user: SortByClauseSystemUsersQuery
}

"Sort clause for `input AuditsQuery` (only one field allowed at a time)."
input SortByClauseAuditsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  change_agent_type: SortByTypeDirection

  "Field clause."
  change_agent_id: SortByTypeDirection

  "Field clause."
  event: SortByTypeDirection

  "Field clause."
  old_values: SortByTypeDirection

  "Field clause."
  new_values: SortByTypeDirection

  "Field clause."
  url: SortByTypeDirection

  "Field clause."
  ip_address: SortByTypeDirection

  "Field clause."
  user_agent: SortByTypeDirection

  "Field clause."
  tags: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  auditable: SortByClauseAuditableablesQuery

  "Field clause."
  user: SortByClauseAuthenticatablesQuery
}

"Sort clause for `input AuditsQuery` (only one field allowed at a time)."
input SortByRootAuditsQuery {
  "Field."
  field: SortByClauseAuditsQuery

  "NULLs first"
  nullsFirst: SortByClauseAuditsQuery

  "NULLs last"
  nullsLast: SortByClauseAuditsQuery
}

"Available conditions for `input CareTeamEducatablesQuery` (only one field allowed at a time)."
input SearchByConditionCareTeamEducatablesQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery
}

"Available conditions for `input CareTeamEducatablesQuery` (only one field allowed at a time)."
input SearchByRootCareTeamEducatablesQuery {
  "Field."
  field: SearchByConditionCareTeamEducatablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootCareTeamEducatablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootCareTeamEducatablesQuery!]

  "Not."
  not: SearchByRootCareTeamEducatablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input CareTeamEducatablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipCareTeamEducatablesQuery {
  "Additional conditions."
  where: SearchByRootCareTeamEducatablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input CareTeamsQuery` (only one field allowed at a time)."
input SearchByConditionCareTeamsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  educatable: SearchByRelationshipCareTeamEducatablesQuery

  "Field condition."
  educatable_id: SearchByScalarEducatableIdOrNull

  "Field condition."
  educatable_type: SearchByEnumEducatableTypeOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input CareTeamsQuery` (only one field allowed at a time)."
input SearchByRootCareTeamsQuery {
  "Field."
  field: SearchByConditionCareTeamsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootCareTeamsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootCareTeamsQuery!]

  "Not."
  not: SearchByRootCareTeamsQuery
}

"Sort clause for `input ConsentAgreementsQuery` (only one field allowed at a time)."
input SortByRootConsentAgreementsQuery {
  "Field."
  field: SortByClauseConsentAgreementsQuery

  "NULLs first"
  nullsFirst: SortByClauseConsentAgreementsQuery

  "NULLs last"
  nullsLast: SortByClauseConsentAgreementsQuery
}

"Sort clause for `input UserConsentAgreementsQuery` (only one field allowed at a time)."
input SortByRootUserConsentAgreementsQuery {
  "Field."
  field: SortByClauseUserConsentAgreementsQuery

  "NULLs first"
  nullsFirst: SortByClauseUserConsentAgreementsQuery

  "NULLs last"
  nullsLast: SortByClauseUserConsentAgreementsQuery
}

"Sort clause for `input EngagementsQuery` (only one field allowed at a time)."
input SortByRootEngagementsQuery {
  "Field."
  field: SortByClauseEngagementsQuery

  "NULLs first"
  nullsFirst: SortByClauseEngagementsQuery

  "NULLs last"
  nullsLast: SortByClauseEngagementsQuery
}

"Available conditions for `input CaseModelQuery` (only one field allowed at a time)."
input SearchByConditionCaseModelQuery {
  "Unique primary key."
  id: SearchByScalarUUIDOrNull
}

"Available conditions for `input CaseModelQuery` (only one field allowed at a time)."
input SearchByRootCaseModelQuery {
  "Field."
  field: SearchByConditionCaseModelQuery

  "All of the conditions must be true."
  allOf: [SearchByRootCaseModelQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootCaseModelQuery!]

  "Not."
  not: SearchByRootCaseModelQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input CaseModelQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipCaseModelQuery {
  "Additional conditions."
  where: SearchByRootCaseModelQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionInteractablesQuery` (only one field allowed at a time)."
input SearchByConditionInteractionInteractablesQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery

  "Relationship condition."
  caseModel: SearchByRelationshipCaseModelQuery
}

"Available conditions for `input InteractionInteractablesQuery` (only one field allowed at a time)."
input SearchByRootInteractionInteractablesQuery {
  "Field."
  field: SearchByConditionInteractionInteractablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionInteractablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionInteractablesQuery!]

  "Not."
  not: SearchByRootInteractionInteractablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionInteractablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionInteractablesQuery {
  "Additional conditions."
  where: SearchByRootInteractionInteractablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `scalar InteractableId` (only one operator allowed at a time)."
input SearchByScalarInteractableIdOrNull {
  "Equal (`=`)."
  equal: InteractableId

  "Not Equal (`!=`)."
  notEqual: InteractableId

  "Within a set of values."
  in: [InteractableId!]

  "Outside a set of values."
  notIn: [InteractableId!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum InteractableType` (only one operator allowed at a time)."
input SearchByEnumInteractableTypeOrNull {
  "Equal (`=`)."
  equal: InteractableType

  "Not Equal (`!=`)."
  notEqual: InteractableType

  "Within a set of values."
  in: [InteractableType!]

  "Outside a set of values."
  notIn: [InteractableType!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionsQuery {
  "Additional conditions."
  where: SearchByRootInteractionsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionRelationQuery` (only one field allowed at a time)."
input SearchByConditionInteractionRelationQuery {
  "The unique primary key of the interaction relation."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction relation."
  name: SearchByScalarStringOrNull

  "The interactions related to this interaction relation."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction relation."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction relation."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction relation."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionRelationQuery` (only one field allowed at a time)."
input SearchByRootInteractionRelationQuery {
  "Field."
  field: SearchByConditionInteractionRelationQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionRelationQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionRelationQuery!]

  "Not."
  not: SearchByRootInteractionRelationQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionRelationQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionRelationQuery {
  "Additional conditions."
  where: SearchByRootInteractionRelationQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionDriverQuery` (only one field allowed at a time)."
input SearchByConditionInteractionDriverQuery {
  "The unique primary key of the interaction driver."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction driver."
  name: SearchByScalarStringOrNull

  "The interactions related to this interaction driver."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction driver."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction driver."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction driver."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionDriverQuery` (only one field allowed at a time)."
input SearchByRootInteractionDriverQuery {
  "Field."
  field: SearchByConditionInteractionDriverQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionDriverQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionDriverQuery!]

  "Not."
  not: SearchByRootInteractionDriverQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionDriverQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionDriverQuery {
  "Additional conditions."
  where: SearchByRootInteractionDriverQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionInitiativeQuery` (only one field allowed at a time)."
input SearchByConditionInteractionInitiativeQuery {
  "The unique primary key of the interaction initiative."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction relation."
  name: SearchByScalarStringOrNull

  "The interactions related to this interaction initiative."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction initiative."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction initiative."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction initiative."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionInitiativeQuery` (only one field allowed at a time)."
input SearchByRootInteractionInitiativeQuery {
  "Field."
  field: SearchByConditionInteractionInitiativeQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionInitiativeQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionInitiativeQuery!]

  "Not."
  not: SearchByRootInteractionInitiativeQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionInitiativeQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionInitiativeQuery {
  "Additional conditions."
  where: SearchByRootInteractionInitiativeQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `enum InteractionStatusColorOptions` (only one operator allowed at a time)."
input SearchByEnumInteractionStatusColorOptionsOrNull {
  "Equal (`=`)."
  equal: InteractionStatusColorOptions

  "Not Equal (`!=`)."
  notEqual: InteractionStatusColorOptions

  "Within a set of values."
  in: [InteractionStatusColorOptions!]

  "Outside a set of values."
  notIn: [InteractionStatusColorOptions!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input InteractionStatusesQuery` (only one field allowed at a time)."
input SearchByConditionInteractionStatusesQuery {
  "The unique primary key of the interaction status."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction status."
  name: SearchByScalarStringOrNull

  "The color of the interaction status."
  color: SearchByEnumInteractionStatusColorOptionsOrNull

  "The interactions related to this interaction status."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction status."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction status."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction status."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionStatusesQuery` (only one field allowed at a time)."
input SearchByRootInteractionStatusesQuery {
  "Field."
  field: SearchByConditionInteractionStatusesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionStatusesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionStatusesQuery!]

  "Not."
  not: SearchByRootInteractionStatusesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionStatusesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionStatusesQuery {
  "Additional conditions."
  where: SearchByRootInteractionStatusesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionOutcomeQuery` (only one field allowed at a time)."
input SearchByConditionInteractionOutcomeQuery {
  "The unique primary key of the interaction outcome."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction outcome."
  name: SearchByScalarStringOrNull

  "The interactions related to this interaction outcome."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction outcome."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction outcome."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction outcome."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionOutcomeQuery` (only one field allowed at a time)."
input SearchByRootInteractionOutcomeQuery {
  "Field."
  field: SearchByConditionInteractionOutcomeQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionOutcomeQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionOutcomeQuery!]

  "Not."
  not: SearchByRootInteractionOutcomeQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input InteractionOutcomeQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipInteractionOutcomeQuery {
  "Additional conditions."
  where: SearchByRootInteractionOutcomeQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input DivisionQuery` (only one field allowed at a time)."
input SearchByConditionDivisionQuery {
  "The name of the division."
  name: SearchByScalarStringOrNull
}

"Available conditions for `input DivisionQuery` (only one field allowed at a time)."
input SearchByRootDivisionQuery {
  "Field."
  field: SearchByConditionDivisionQuery

  "All of the conditions must be true."
  allOf: [SearchByRootDivisionQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootDivisionQuery!]

  "Not."
  not: SearchByRootDivisionQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input DivisionQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipDivisionQuery {
  "Additional conditions."
  where: SearchByRootDivisionQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input InteractionsQuery` (only one field allowed at a time)."
input SearchByConditionInteractionsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  subject: SearchByScalarStringOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  interactable: SearchByRelationshipInteractionInteractablesQuery

  "Field condition."
  interactable_id: SearchByScalarInteractableIdOrNull

  "Field condition."
  interactable_type: SearchByEnumInteractableTypeOrNull

  "Relationship condition."
  relation: SearchByRelationshipInteractionRelationQuery

  "Relationship condition."
  driver: SearchByRelationshipInteractionDriverQuery

  "Relationship condition."
  initiative: SearchByRelationshipInteractionInitiativeQuery

  "Relationship condition."
  status: SearchByRelationshipInteractionStatusesQuery

  "Relationship condition."
  outcome: SearchByRelationshipInteractionOutcomeQuery

  "Relationship condition."
  division: SearchByRelationshipDivisionQuery

  "Field condition."
  start_datetime: SearchByScalarDateTimeOrNull

  "Field condition."
  end_datetime: SearchByScalarDateTimeOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionsQuery` (only one field allowed at a time)."
input SearchByRootInteractionsQuery {
  "Field."
  field: SearchByConditionInteractionsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionsQuery!]

  "Not."
  not: SearchByRootInteractionsQuery
}

"Available conditions for `input InteractionTypeQuery` (only one field allowed at a time)."
input SearchByConditionInteractionTypeQuery {
  "The unique primary key of the interaction type."
  id: SearchByScalarUUIDOrNull

  "The name of the interaction relation."
  name: SearchByScalarStringOrNull

  "The interactions related to this interaction type."
  interactions: SearchByRelationshipInteractionsQuery

  "The created date of the interaction type."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the interaction type."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the interaction type."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input InteractionTypeQuery` (only one field allowed at a time)."
input SearchByRootInteractionTypeQuery {
  "Field."
  field: SearchByConditionInteractionTypeQuery

  "All of the conditions must be true."
  allOf: [SearchByRootInteractionTypeQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootInteractionTypeQuery!]

  "Not."
  not: SearchByRootInteractionTypeQuery
}

"Available conditions for `input UserSubscriptionSubscribablesQuery` (only one field allowed at a time)."
input SearchByConditionUserSubscriptionSubscribablesQuery {
  "Relationship condition."
  student: SearchByRelationshipStudentsQuery

  "Relationship condition."
  prospect: SearchByRelationshipProspectsQuery
}

"Available conditions for `input UserSubscriptionSubscribablesQuery` (only one field allowed at a time)."
input SearchByRootUserSubscriptionSubscribablesQuery {
  "Field."
  field: SearchByConditionUserSubscriptionSubscribablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootUserSubscriptionSubscribablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootUserSubscriptionSubscribablesQuery!]

  "Not."
  not: SearchByRootUserSubscriptionSubscribablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input UserSubscriptionSubscribablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipUserSubscriptionSubscribablesQuery {
  "Additional conditions."
  where: SearchByRootUserSubscriptionSubscribablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input SubscriptionsQuery` (only one field allowed at a time)."
input SearchByConditionSubscriptionsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  subscribable: SearchByRelationshipUserSubscriptionSubscribablesQuery

  "Field condition."
  subscribable_id: SearchByScalarEducatableIdOrNull

  "Field condition."
  subscribable_type: SearchByEnumEducatableTypeOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input SubscriptionsQuery` (only one field allowed at a time)."
input SearchByRootSubscriptionsQuery {
  "Field."
  field: SearchByConditionSubscriptionsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootSubscriptionsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootSubscriptionsQuery!]

  "Not."
  not: SearchByRootSubscriptionsQuery
}

"Sort clause for `input ProspectSourcesQuery` (only one field allowed at a time)."
input SortByRootProspectSourcesQuery {
  "Field."
  field: SortByClauseProspectSourcesQuery

  "NULLs first"
  nullsFirst: SortByClauseProspectSourcesQuery

  "NULLs last"
  nullsLast: SortByClauseProspectSourcesQuery
}

"Sort clause for `input ProspectStatusesQuery` (only one field allowed at a time)."
input SortByRootProspectStatusesQuery {
  "Field."
  field: SortByClauseProspectStatusesQuery

  "NULLs first"
  nullsFirst: SortByClauseProspectStatusesQuery

  "NULLs last"
  nullsLast: SortByClauseProspectStatusesQuery
}

"Sort clause for `input ProspectsQuery` (only one field allowed at a time)."
input SortByRootProspectsQuery {
  "Field."
  field: SortByClauseProspectsQuery

  "NULLs first"
  nullsFirst: SortByClauseProspectsQuery

  "NULLs last"
  nullsLast: SortByClauseProspectsQuery
}

"Sort clause for `input EnrollmentsQuery` (only one field allowed at a time)."
input SortByRootEnrollmentsQuery {
  "Field."
  field: SortByClauseEnrollmentsQuery

  "NULLs first"
  nullsFirst: SortByClauseEnrollmentsQuery

  "NULLs last"
  nullsLast: SortByClauseEnrollmentsQuery
}

"Sort clause for `input ProgramsQuery` (only one field allowed at a time)."
input SortByRootProgramsQuery {
  "Field."
  field: SortByClauseProgramsQuery

  "NULLs first"
  nullsFirst: SortByClauseProgramsQuery

  "NULLs last"
  nullsLast: SortByClauseProgramsQuery
}

"Sort clause for `input StudentsQuery` (only one field allowed at a time)."
input SortByRootStudentsQuery {
  "Field."
  field: SortByClauseStudentsQuery

  "NULLs first"
  nullsFirst: SortByClauseStudentsQuery

  "NULLs last"
  nullsLast: SortByClauseStudentsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input PromptTypesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipPromptTypesQuery {
  "Additional conditions."
  where: SearchByRootPromptTypesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input PromptsQuery` (only one field allowed at a time)."
input SearchByConditionPromptsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  title: SearchByScalarStringOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Field condition."
  prompt: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  type: SearchByRelationshipPromptTypesQuery
}

"Available conditions for `input PromptsQuery` (only one field allowed at a time)."
input SearchByRootPromptsQuery {
  "Field."
  field: SearchByConditionPromptsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootPromptsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootPromptsQuery!]

  "Not."
  not: SearchByRootPromptsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input PromptsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipPromptsQuery {
  "Additional conditions."
  where: SearchByRootPromptsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input PromptTypesQuery` (only one field allowed at a time)."
input SearchByConditionPromptTypesQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  title: SearchByScalarStringOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  prompts: SearchByRelationshipPromptsQuery
}

"Available conditions for `input PromptTypesQuery` (only one field allowed at a time)."
input SearchByRootPromptTypesQuery {
  "Field."
  field: SearchByConditionPromptTypesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootPromptTypesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootPromptTypesQuery!]

  "Not."
  not: SearchByRootPromptTypesQuery
}

"Sort clause for `input PromptsQuery` (only one field allowed at a time)."
input SortByClausePromptsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  title: SortByTypeDirection

  "Field clause."
  description: SortByTypeDirection

  "Field clause."
  prompt: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  type: SortByClausePromptTypesQuery
}

"Sort clause for `input PromptTypesQuery` (only one field allowed at a time)."
input SortByClausePromptTypesQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  title: SortByTypeDirection

  "Field clause."
  description: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  prompts: SortByClausePromptsQuery
}

"Sort clause for `input PromptTypesQuery` (only one field allowed at a time)."
input SortByRootPromptTypesQuery {
  "Field."
  field: SortByClausePromptTypesQuery

  "NULLs first"
  nullsFirst: SortByClausePromptTypesQuery

  "NULLs last"
  nullsLast: SortByClausePromptTypesQuery
}

"Sort clause for `input PromptsQuery` (only one field allowed at a time)."
input SortByRootPromptsQuery {
  "Field."
  field: SortByClausePromptsQuery

  "NULLs first"
  nullsFirst: SortByClausePromptsQuery

  "NULLs last"
  nullsLast: SortByClausePromptsQuery
}

"Directions for ordering a list of records."
enum SortOrder {
  "Sort records in ascending order."
  ASC

  "Sort records in descending order."
  DESC
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
  "Amount of items."
  COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
  "Average."
  AVG

  "Minimum."
  MIN

  "Maximum."
  MAX

  "Sum."
  SUM

  "Amount of items."
  COUNT
}

"Allows ordering a list of records."
input OrderByClause {
  "The column that is used for ordering."
  column: String!

  "The direction that is used for ordering."
  order: SortOrder!
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
  "Only return trashed results."
  ONLY

  "Return both trashed and non-trashed results."
  WITH

  "Only return non-trashed results."
  WITHOUT
}

"Dynamic WHERE conditions for queries."
input WhereConditions {
  "The column that is used for the condition."
  column: String

  "The operator that is used for the condition."
  operator: SQLOperator = EQ

  "The value that is used for the condition."
  value: Mixed

  "A set of conditions that requires all conditions to match."
  AND: [WhereConditions!]

  "A set of conditions that requires at least one condition to match."
  OR: [WhereConditions!]

  "Check whether a relation exists. Extra conditions or a minimum amount can be applied."
  HAS: WhereConditionsRelation
}

"Dynamic HAS conditions for WHERE condition queries."
input WhereConditionsRelation {
  "The relation that is checked."
  relation: String!

  "The comparison operator to test against the amount."
  operator: SQLOperator = GTE

  "The amount to test."
  amount: Int = 1

  "Additional condition logic."
  condition: WhereConditions
}

"The available SQL operators that are used to filter query results."
enum SQLOperator {
  "Equal operator (`=`)"
  EQ

  "Not equal operator (`!=`)"
  NEQ

  "Greater than operator (`>`)"
  GT

  "Greater than or equal operator (`>=`)"
  GTE

  "Less than operator (`<`)"
  LT

  "Less than or equal operator (`<=`)"
  LTE

  "Simple pattern matching (`LIKE`)"
  LIKE

  "Negation of simple pattern matching (`NOT LIKE`)"
  NOT_LIKE

  "Whether a value is within a set of values (`IN`)"
  IN

  "Whether a value is not within a set of values (`NOT IN`)"
  NOT_IN

  "Whether a value is within a range of values (`BETWEEN`)"
  BETWEEN

  "Whether a value is not within a range of values (`NOT BETWEEN`)"
  NOT_BETWEEN

  "Whether a value is null (`IS NULL`)"
  IS_NULL

  "Whether a value is not null (`IS NOT NULL`)"
  IS_NOT_NULL
}

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations."
type __Schema {
  "A list of all types supported by this server."
  types: [__Type!]!

  "The type that query operations will be rooted at."
  queryType: __Type!

  "If this server supports mutation, the type that mutation operations will be rooted at."
  mutationType: __Type

  "If this server support subscription, the type that subscription operations will be rooted at."
  subscriptionType: __Type

  "A list of all directives supported by this server."
  directives: [__Directive!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.

Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.
"""
type __Type {
  kind: __TypeKind!
  name: String
  description: String
  fields(includeDeprecated: Boolean = false): [__Field!]
  interfaces: [__Type!]
  possibleTypes: [__Type!]
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  inputFields(includeDeprecated: Boolean = false): [__InputValue!]
  ofType: __Type
}

"An enum describing what kind of type a given `__Type` is."
enum __TypeKind {
  "Indicates this type is a scalar."
  SCALAR

  "Indicates this type is an object. `fields` and `interfaces` are valid fields."
  OBJECT

  "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
  INTERFACE

  "Indicates this type is a union. `possibleTypes` is a valid field."
  UNION

  "Indicates this type is an enum. `enumValues` is a valid field."
  ENUM

  "Indicates this type is an input object. `inputFields` is a valid field."
  INPUT_OBJECT

  "Indicates this type is a list. `ofType` is a valid field."
  LIST

  "Indicates this type is a non-null. `ofType` is a valid field."
  NON_NULL
}

"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type."
type __Field {
  name: String!
  description: String
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value."
type __InputValue {
  name: String!
  description: String
  type: __Type!

  "A GraphQL-formatted string representing the default value for this input value."
  defaultValue: String

  isDeprecated: Boolean!
  deprecationReason: String
}

"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string."
type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  name: String!
  description: String
  isRepeatable: Boolean!
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
}

"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies."
enum __DirectiveLocation {
  "Location adjacent to a query operation."
  QUERY

  "Location adjacent to a mutation operation."
  MUTATION

  "Location adjacent to a subscription operation."
  SUBSCRIPTION

  "Location adjacent to a field."
  FIELD

  "Location adjacent to a fragment definition."
  FRAGMENT_DEFINITION

  "Location adjacent to a fragment spread."
  FRAGMENT_SPREAD

  "Location adjacent to an inline fragment."
  INLINE_FRAGMENT

  "Location adjacent to a variable definition."
  VARIABLE_DEFINITION

  "Location adjacent to a schema definition."
  SCHEMA

  "Location adjacent to a scalar definition."
  SCALAR

  "Location adjacent to an object type definition."
  OBJECT

  "Location adjacent to a field definition."
  FIELD_DEFINITION

  "Location adjacent to an argument definition."
  ARGUMENT_DEFINITION

  "Location adjacent to an interface definition."
  INTERFACE

  "Location adjacent to a union definition."
  UNION

  "Location adjacent to an enum definition."
  ENUM

  "Location adjacent to an enum value definition."
  ENUM_VALUE

  "Location adjacent to an input object type definition."
  INPUT_OBJECT

  "Location adjacent to an input object field definition."
  INPUT_FIELD_DEFINITION
}
